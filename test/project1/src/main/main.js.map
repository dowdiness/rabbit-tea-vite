{"version":3,"sources":["/Users/yorkin/.moon/lib/core/strconv/errors.mbt","/Users/yorkin/.moon/lib/core/strconv/int.mbt","/Users/yorkin/.moon/lib/core/string/view.mbt","/Users/yorkin/.moon/lib/core/string/utils.mbt","/Users/yorkin/.moon/lib/core/string/string.mbt","/Users/yorkin/.moon/lib/core/string/methods.mbt","/Users/yorkin/.moon/lib/core/string/deprecated.mbt","/Users/yorkin/.moon/lib/core/array/array.mbt","/Users/yorkin/.moon/lib/core/math/algebraic.mbt","/Users/yorkin/.moon/lib/core/option/option.mbt","/Users/yorkin/.moon/lib/core/builtin/intrinsics.mbt","/Users/yorkin/.moon/lib/core/builtin/hasher.mbt","/Users/yorkin/.moon/lib/core/builtin/stringbuilder_concat.mbt","/Users/yorkin/.moon/lib/core/builtin/failure.mbt","/Users/yorkin/.moon/lib/core/builtin/op.mbt","/Users/yorkin/.moon/lib/core/builtin/int64_js.mbt","/Users/yorkin/.moon/lib/core/builtin/output.mbt","/Users/yorkin/.moon/lib/core/builtin/autoloc.mbt","/Users/yorkin/.moon/lib/core/builtin/linked_hash_map.mbt","/Users/yorkin/.moon/lib/core/builtin/arrayview.mbt","/Users/yorkin/.moon/lib/core/builtin/arraycore_js.mbt","/Users/yorkin/.moon/lib/core/builtin/to_string.mbt","/Users/yorkin/.moon/lib/core/builtin/traits.mbt","/Users/yorkin/.moon/lib/core/builtin/iter.mbt","/Users/yorkin/source/moonbit/moonbit-frontend/rabbit-reactor/test/.mooncakes/Yoorkin/rabbit-tea/src/url/url.mbt","/Users/yorkin/source/moonbit/moonbit-frontend/rabbit-reactor/test/.mooncakes/rami3l/js-ffi/src/js/null.mbt","/Users/yorkin/source/moonbit/moonbit-frontend/rabbit-reactor/test/.mooncakes/Yoorkin/rabbit-tea/src/browser/sandbox.mbt","/Users/yorkin/source/moonbit/moonbit-frontend/rabbit-reactor/test/.mooncakes/Yoorkin/rabbit-tea/src/browser/command.mbt","/Users/yorkin/source/moonbit/moonbit-frontend/rabbit-reactor/test/.mooncakes/Yoorkin/rabbit-tea/src/internal/vdom/dom.mbt","/Users/yorkin/source/moonbit/moonbit-frontend/rabbit-reactor/test/.mooncakes/Yoorkin/rabbit-tea/src/html/html.mbt","/Users/yorkin/source/moonbit/moonbit-frontend/rabbit-reactor/test/.mooncakes/Yoorkin/rabbit-tea/src/html/attributes.mbt","/Users/yorkin/source/moonbit/moonbit-frontend/rabbit-reactor/test/.mooncakes/Yoorkin/rabbit-tea/src/top.mbt","/Users/yorkin/source/moonbit/moonbit-frontend/rabbit-reactor/test/src/views/views.mbt","/Users/yorkin/source/moonbit/moonbit-frontend/rabbit-reactor/test/src/main/main.mbt"],"sourcesContent":["// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub(all) type! StrConvError String\n\n///|\npub impl Show for StrConvError with output(self, logger) {\n  match self {\n    StrConvError(err) => logger.write_string(err)\n  }\n}\n\n///|\nlet range_err_str = \"value out of range\"\n\n///|\nlet syntax_err_str = \"invalid syntax\"\n\n///|\nlet base_err_str = \"invalid base\"\n\n///|\nfn range_err[T]() -> T!StrConvError {\n  raise StrConvError(range_err_str)\n}\n\n///|\nfn syntax_err[T]() -> T!StrConvError {\n  raise StrConvError(syntax_err_str)\n}\n\n///|\nfn base_err[T]() -> T!StrConvError {\n  raise StrConvError(base_err_str)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst INT_MIN = 0x80000000\n\n///|\nconst INT_MAX = 0x7fffffff\n\n///|\nconst INT64_MIN = -0x8000000000000000L\n\n///|\nconst INT64_MAX = 0x7fffffffffffffffL\n\n///|\n/// This function check whether the prefix of the string is consistent with the given base,\n/// and consume the prefix.\n/// The boolean flag `allow_underscore` is used to check validity of underscores.\nfn check_and_consume_base(\n  view : @string.StringView,\n  base : Int\n) -> (Int, @string.StringView, Bool)!StrConvError {\n  match view {\n    ['0', 'x' | 'X', .. rest] => {\n      guard base is (0 | 16) else { base_err!() }\n      (16, rest, true)\n    }\n    ['0', 'o' | 'O', .. rest] => {\n      guard base is (0 | 8) else { base_err!() }\n      (8, rest, true)\n    }\n    ['0', 'b' | 'B', .. rest] => {\n      guard base is (0 | 2) else { base_err!() }\n      (2, rest, true)\n    }\n    rest =>\n      match base {\n        0 => (10, rest, false)\n        2..=36 => (base, rest, false)\n        _ => base_err!()\n      }\n  }\n}\n\n///|\ntest {\n  inspect!(parse_int64?(\"0b01\", base=3), content=\"Err(invalid base)\")\n  inspect!(parse_int64?(\"0x01\", base=3), content=\"Err(invalid base)\")\n  inspect!(parse_int64?(\"0o01\", base=3), content=\"Err(invalid base)\")\n}\n\n///|\n/// Parses a string into an Int64 number using the specified base, or returns an error.\n/// The base must be 0 or between 2 and 36 (inclusive). If base is 0, it will be \n/// inferred from the string prefix:\n///   - \"0x\" or \"0X\" for base 16 (hex)\n///   - \"0o\" or \"0O\" for base 8 (octal) \n///   - \"0b\" or \"0B\" for base 2 (binary)\n///   - Default is base 10 (decimal)\n/// For readability, underscores may appear after base prefixes or between digits.\n/// These underscores do not affect the value.\n/// Examples:\n/// ```\n/// inspect!(parse_int64!(\"123\"), content=\"123\")\n/// inspect!(parse_int64!(\"0xff\", base=0), content=\"255\") \n/// inspect!(parse_int64!(\"0o10\"), content=\"8\")\n/// inspect!(parse_int64!(\"0b1010\"), content=\"10\")\n/// inspect!(parse_int64!(\"1_234\"), content=\"1234\")\n/// inspect!(parse_int64!(\"-123\"), content=\"-123\")\n/// inspect!(parse_int64!(\"ff\", base=16), content=\"255\")\n/// inspect!(parse_int64!(\"zz\", base=36), content=\"1295\")\n/// ```\n/// \npub fn parse_int64(str : String, base~ : Int = 0) -> Int64!StrConvError {\n  guard str != \"\" else { syntax_err!() }\n  let (neg, rest) = match str.view() {\n    ['+', .. rest] => (false, rest)\n    ['-', .. rest] => (true, rest)\n    rest => (false, rest)\n  }\n\n  // `allow_underscore` is used to check validity of underscores\n  let (num_base, rest, allow_underscore) = check_and_consume_base!(rest, base)\n\n  // calculate overflow threshold\n  let overflow_threshold = overflow_threshold(num_base, neg)\n  let has_digit = rest\n    is (['0'..='9' | 'a'..='z' | 'A'..='Z', ..]\n    | ['_', '0'..='9' | 'a'..='z' | 'A'..='Z', ..])\n  guard has_digit else { syntax_err!() }\n  // convert\n  loop rest, 0L, allow_underscore {\n    ['_'], _, _ =>\n      // the last character cannot be underscore\n      syntax_err!()\n    ['_', ..], _, false => syntax_err!()\n    ['_', .. rest], acc, true => continue rest, acc, false\n    [c, .. rest], acc, _ => {\n      let c = c.to_int()\n      let d = match c {\n        '0'..='9' => c - '0'\n        'a'..='z' => c + (10 - 'a')\n        'A'..='Z' => c + (10 - 'A')\n        _ => syntax_err!()\n      }\n      guard d < num_base else { syntax_err!() }\n      if neg {\n        guard acc >= overflow_threshold else { range_err!() }\n        let next_acc = acc * num_base.to_int64() - d.to_int64()\n        guard next_acc <= acc else { range_err!() }\n        continue rest, next_acc, true\n      } else {\n        guard acc < overflow_threshold else { range_err!() }\n        let next_acc = acc * num_base.to_int64() + d.to_int64()\n        guard next_acc >= acc else { range_err!() }\n        continue rest, next_acc, true\n      }\n    }\n    [], acc, _ => acc\n  }\n}\n\n///|\n/// Parse a string in the given base (0, 2 to 36), return a Int number or an error.\n/// If the `~base` argument is 0, the base will be inferred by the prefix.\npub fn parse_int(str : String, base~ : Int = 0) -> Int!StrConvError {\n  let n = parse_int64!(str, base~)\n  if n < INT_MIN.to_int64() || n > INT_MAX.to_int64() {\n    range_err!()\n  }\n  n.to_int()\n}\n\n///|\n// Check whether the underscores are correct.\n// Underscores must appear only between digits or between a base prefix and a digit.\nfn check_underscore(str : String) -> Bool {\n  // skip the sign\n  let rest = match str.view() {\n    ['+' | '-', .. rest] => rest\n    rest => rest\n  }\n\n  // base prefix\n  let (rest, allow_underscore, hex) = match rest {\n    ['0', 'x' | 'X', .. rest] => (rest, true, true)\n    ['0', 'o' | 'O', .. rest] => (rest, true, false)\n    ['0', 'b' | 'B', .. rest] => (rest, true, false)\n    rest => (rest, false, false)\n  }\n\n  // 'e' and 'E' are valid hex digits\n  // but are not treated as digits in decimal strings since they're used for scientific notation\n  fn is_digit(c : Char) -> Bool {\n    if hex {\n      ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F')\n    } else {\n      '0' <= c && c <= '9'\n    }\n  }\n\n  // Track whether the previous character was an underscore\n  let follow_underscore = false\n  loop rest, allow_underscore, follow_underscore {\n    // Empty string is valid\n    [], _, _ => true\n    // String ending with underscore is invalid\n    ['_'], _, _ => false\n    // Underscore not allowed in current position (e.g., between non-digits)\n    ['_', ..], false, _ => false\n    // Valid underscore - continue but mark that next char must be a digit\n    ['_', .. rest], true, _ => continue rest, false, true\n    // Handle non-underscore character\n    [c, .. rest], _, follow_underscore =>\n      if is_digit(c) {\n        // Digit found - allow underscore in next position\n        continue rest, true, false\n      } else if follow_underscore {\n        // Non-digit found after underscore - invalid\n        false\n      } else {\n        // Non-digit found (not after underscore) - continue but don't allow underscores\n        continue rest, false, false\n      }\n  }\n}\n\n///|\n// Determine the base of the value.\nfn determine_base(s : String) -> Int {\n  match s.view() {\n    ['0', 'x' | 'X', ..] => 16\n    ['0', 'o' | 'O', ..] => 8\n    ['0', 'b' | 'B', ..] => 2\n    _ => 10\n  }\n}\n\n///|\nfn overflow_threshold(base : Int, neg : Bool) -> Int64 {\n  if not(neg) {\n    if base == 10 {\n      INT64_MAX / 10L + 1L\n    } else if base == 16 {\n      INT64_MAX / 16L + 1L\n    } else {\n      INT64_MAX / base.to_int64() + 1L\n    }\n  } else if base == 10 {\n    INT64_MIN / 10L\n  } else if base == 16 {\n    INT64_MIN / 16L\n  } else {\n    INT64_MIN / base.to_int64()\n  }\n}\n\n///|\ntest \"check_underscore\" {\n  assert_true!(check_underscore(\"123\"))\n  assert_true!(check_underscore(\"0x123\"))\n  assert_true!(check_underscore(\"0o123\"))\n  assert_true!(check_underscore(\"0b101\"))\n  assert_true!(check_underscore(\"1_2_3\"))\n  assert_true!(check_underscore(\"0x_1_2_3_A_F\"))\n  assert_true!(check_underscore(\"0o_1_2_3\"))\n  assert_true!(check_underscore(\"0b_1_0_1\"))\n  assert_false!(check_underscore(\"1__2_3\"))\n  assert_false!(check_underscore(\"_123\"))\n  assert_false!(check_underscore(\"123_\"))\n}\n\n///|\ntest \"determine_base\" {\n  assert_eq!(determine_base(\"1234\"), 10)\n  assert_eq!(determine_base(\"0x1234\"), 16)\n  assert_eq!(determine_base(\"0X1234\"), 16)\n  assert_eq!(determine_base(\"0o1234\"), 8)\n  assert_eq!(determine_base(\"0O1234\"), 8)\n  assert_eq!(determine_base(\"0b1010\"), 2)\n  assert_eq!(determine_base(\"0B1010\"), 2)\n}\n\n///|\ntest \"parse_int64\" {\n  let tests : Array[(String, Result[Int64, String])] = [\n    (\"\", Err(syntax_err_str)),\n    (\"0\", Ok(0L)),\n    (\"-0\", Ok(0L)),\n    (\"+0\", Ok(0L)),\n    (\"1\", Ok(1L)),\n    (\"-1\", Ok(-1L)),\n    (\"+1\", Ok(1L)),\n    (\"12345\", Ok(12345L)),\n    (\"-12345\", Ok(-12345L)),\n    (\"012345\", Ok(12345L)),\n    (\"-012345\", Ok(-12345L)),\n    (\"9876543210\", Ok(9876543210L)),\n    (\"-9876543210\", Ok(-9876543210L)),\n    (\"9223372036854775807\", Ok(9223372036854775807L)),\n    (\"-9223372036854775807\", Ok(-9223372036854775807L)),\n    (\"9223372036854775808\", Err(range_err_str)),\n    (\"-9223372036854775808\", Ok(-9223372036854775808L)),\n    (\"9223372036854775809\", Err(range_err_str)),\n    (\"-9223372036854775809\", Err(range_err_str)),\n    (\"-1_2_3_4_5\", Ok(-12345L)),\n    (\"-_12345\", Err(syntax_err_str)),\n    (\"_12345\", Err(syntax_err_str)),\n    (\"1__2345\", Err(syntax_err_str)),\n    (\"12345_\", Err(syntax_err_str)),\n    (\"12345%\", Err(syntax_err_str)),\n  ]\n  for i in 0..<tests.length() {\n    let t = tests[i]\n    assert_eq!(\n      try {\n        Result::Ok(parse_int64!(t.0))\n      } catch {\n        StrConvError(err) => Err(err)\n      },\n      t.1,\n    )\n  }\n}\n\n///|\ntest \"parse_int64_base\" {\n  let tests : Array[(String, Int, Result[Int64, String])] = [\n    (\"\", 0, Err(syntax_err_str)),\n    (\"0\", 0, Ok(0L)),\n    (\"-0\", 0, Ok(0L)),\n    (\"1\", 0, Ok(1L)),\n    (\"-1\", 0, Ok(-1L)),\n    (\"12345\", 0, Ok(12345L)),\n    (\"-12345\", 0, Ok(-12345L)),\n    (\"012345\", 0, Ok(12345L)),\n    (\"-012345\", 0, Ok(-12345L)),\n    (\"0x12345\", 0, Ok(0x12345L)),\n    (\"-0x12345\", 0, Ok(-0x12345L)),\n    (\"9876543210\", 0, Ok(9876543210L)),\n    (\"-9876543210\", 0, Ok(-9876543210L)),\n    (\"9223372036854775807\", 0, Ok(9223372036854775807L)),\n    (\"-9223372036854775807\", 0, Ok(-9223372036854775807L)),\n    (\"9223372036854775808\", 0, Err(range_err_str)),\n    (\"12345x\", 0, Err(syntax_err_str)),\n    (\"-12345x\", 0, Err(syntax_err_str)),\n    (\"-9223372036854775808\", 0, Ok(-9223372036854775808L)),\n    (\"9223372036854775809\", 0, Err(range_err_str)),\n    (\"-9223372036854775809\", 0, Err(range_err_str)),\n    // other bases\n    (\"h\", 18, Ok(17L)),\n    (\"10\", 25, Ok(25L)),\n    (\n      \"moonbit\",\n      35,\n      Ok(\n        (\n          ((((22L * 35L + 24L) * 35L + 24L) * 35L + 23L) * 35L + 11L) * 35L +\n          18L\n        ) *\n        35L +\n        29L,\n      ),\n    ),\n    (\n      \"moonbit\",\n      36,\n      Ok(\n        (\n          ((((22L * 36L + 24L) * 36L + 24L) * 36L + 23L) * 36L + 11L) * 36L +\n          18L\n        ) *\n        36L +\n        29L,\n      ),\n    ),\n    // base 2\n    (\"0\", 2, Ok(0L)),\n    (\"-1\", 2, Ok(-1L)),\n    (\"1010\", 2, Ok(10L)),\n    (\"1000000000000000\", 2, Ok(1L << 15)),\n    (\n      \"111111111111111111111111111111111111111111111111111111111111111\",\n      2,\n      Ok((1L << 63) - 1L),\n    ),\n    (\n      \"1000000000000000000000000000000000000000000000000000000000000000\",\n      2,\n      Err(range_err_str),\n    ),\n    (\n      \"-1000000000000000000000000000000000000000000000000000000000000000\",\n      2,\n      Ok(-1L << 63),\n    ),\n    (\n      \"-1000000000000000000000000000000000000000000000000000000000000001\",\n      2,\n      Err(range_err_str),\n    ),\n    // base 8\n    (\"-10\", 8, Ok(-8L)),\n    (\"57635436545\", 8, Ok(0o57635436545L)),\n    (\"100000000\", 8, Ok(1L << 24)),\n    // base 16\n    (\"10\", 16, Ok(16L)),\n    (\"-123456789abcdef\", 16, Ok(-0x123456789abcdefL)),\n    (\"7fffffffffffffff\", 16, Ok((1L << 63) - 1L)),\n    // underscores\n    (\"-0x_1_2_3_4_5\", 0, Ok(-0x12345L)),\n    (\"0x_1_2_3_4_5\", 0, Ok(0x12345L)),\n    (\"-_0x12345\", 0, Err(syntax_err_str)),\n    (\"_-0x12345\", 0, Err(syntax_err_str)),\n    (\"_0x12345\", 0, Err(syntax_err_str)),\n    (\"0x__12345\", 0, Err(syntax_err_str)),\n    (\"0x1__2345\", 0, Err(syntax_err_str)),\n    (\"0x1234__5\", 0, Err(syntax_err_str)),\n    (\"0x12345_\", 0, Err(syntax_err_str)),\n    (\"-0_1_2_3_4_5\", 0, Ok(-12345L)),\n    (\"0_1_2_3_4_5\", 0, Ok(12345L)),\n    (\"-_012345\", 0, Err(syntax_err_str)),\n    (\"_-012345\", 0, Err(syntax_err_str)),\n    (\"_012345\", 0, Err(syntax_err_str)),\n    (\"0__12345\", 0, Err(syntax_err_str)),\n    (\"01234__5\", 0, Err(syntax_err_str)),\n    (\"012345_\", 0, Err(syntax_err_str)),\n    (\"+0xf\", 0, Ok(0xfL)),\n    (\"-0xf\", 0, Ok(-0xfL)),\n    (\"0x+f\", 0, Err(syntax_err_str)),\n    (\"0x-f\", 0, Err(syntax_err_str)),\n  ]\n  for i in 0..<tests.length() {\n    let t = tests[i]\n    assert_eq!(\n      try {\n        Result::Ok(parse_int64!(t.0, base=t.1))\n      } catch {\n        StrConvError(err) => Err(err)\n      },\n      t.2,\n    )\n  }\n}\n\n///|\ntest \"parse_int\" {\n  let tests : Array[(String, Result[Int, String])] = [\n    (\"\", Err(syntax_err_str)),\n    (\"0\", Ok(0)),\n    (\"-0\", Ok(0)),\n    (\"1\", Ok(1)),\n    (\"-1\", Ok(-1)),\n    (\"12345\", Ok(12345)),\n    (\"-12345\", Ok(-12345)),\n    (\"012345\", Ok(12345)),\n    (\"-012345\", Ok(-12345)),\n    (\"12345x\", Err(syntax_err_str)),\n    (\"-12345x\", Err(syntax_err_str)),\n    (\"987654321\", Ok(987654321)),\n    (\"-987654321\", Ok(-987654321)),\n    (\"2147483647\", Ok((1 << 31) - 1)),\n    (\"-2147483647\", Ok(-((1 << 31) - 1))),\n    (\"2147483648\", Err(range_err_str)),\n    (\"-2147483648\", Ok(-1 << 31)),\n    (\"2147483649\", Err(range_err_str)),\n    (\"-2147483649\", Err(range_err_str)),\n    (\"-1_2_3_4_5\", Ok(-12345)),\n    (\"-_12345\", Err(syntax_err_str)),\n    (\"_12345\", Err(syntax_err_str)),\n    (\"1__2345\", Err(syntax_err_str)),\n    (\"12345_\", Err(syntax_err_str)),\n    (\"123%45\", Err(syntax_err_str)),\n  ]\n  for i in 0..<tests.length() {\n    let t = tests[i]\n    assert_eq!(\n      try {\n        Result::Ok(parse_int!(t.0))\n      } catch {\n        StrConvError(err) => Err(err)\n      },\n      t.1,\n    )\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///| \n/// A `StringView` represents a view of a String that maintains proper Unicode\n/// character boundaries. It allows safe access to a substring while handling \n/// multi-byte characters correctly.\n/// alert deprecated \"use @string.View instead\"\nstruct StringView {\n  // # Fields\n  //\n  // - `str`: The source String being viewed\n  // - `start`: Starting UTF-16 code unit index into the string\n  // - `end`: Ending UTF-16 code unit index into the string (not included)\n  //\n  // `len` is not included because it will make the operation of `op_as_view`\n  // has complexity O(n) where n is the length of the code points in the view.\n  str : String\n  start : Int\n  end : Int\n}\n\n///|\n/// A `@string.View` represents a view of a String that maintains proper Unicode\n/// character boundaries. It allows safe access to a substring while handling \n/// multi-byte characters correctly.\npub typealias View = StringView\n\n///|\nfn len(self : View) -> Int {\n  self.end - self.start\n}\n\n///|\n/// Creates a `View` into a `String`.\n/// \n/// # Example\n/// \n/// ```\n/// let str = \"Hello🤣🤣🤣\"\n/// let view1 = str.view()\n/// inspect!(view1, content=\n///  \"Hello🤣🤣🤣\"\n///)\n/// let start_offset = str.offset_of_nth_char(1).unwrap()\n/// let end_offset = str.offset_of_nth_char(6).unwrap() // the second emoji\n/// let view2 = str.view(start_offset~, end_offset~)\n/// inspect!(view2, content=\n///  \"ello🤣\"\n///)\n/// ```\npub fn String::view(\n  self : String,\n  start_offset~ : Int = 0,\n  end_offset~ : Int = self.length()\n) -> View {\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"Invalid index for View\")\n  }\n  { str: self, start: start_offset, end: end_offset }\n}\n\n///|\n/// Returns a new view of the view with the given start and end offsets.\npub fn View::view(\n  self : View,\n  start_offset~ : Int = 0,\n  end_offset~ : Int = self.len()\n) -> View {\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.len() else {\n    abort(\"Invalid index for View\")\n  }\n  {\n    str: self.str,\n    start: self.start + start_offset,\n    end: self.start + end_offset,\n  }\n}\n\n///|\n/// Returns the UTF-16 index of the i-th (zero-indexed) Unicode character of\n/// the view. If i is negative, it returns the index of the (n + i)-th character\n/// where n is the total number of Unicode characters in the view.\npub fn View::offset_of_nth_char(self : View, i : Int) -> Int? {\n  if self.str.offset_of_nth_char(\n      i,\n      start_offset=self.start,\n      end_offset=self.end,\n    )\n    is Some(index) {\n    Some(index - self.start)\n  } else {\n    None\n  }\n}\n\n///|\n/// Returns the Unicode character at the given index.\n/// \n/// This method has O(n) complexity.\npub fn View::char_at(self : View, index : Int) -> Char {\n  guard index >= 0 && index < self.len() else { abort(\"Index out of bounds\") }\n  self.str.unsafe_char_at(self.start + index)\n}\n\n///|\n/// Returns the charcode(code unit) at the given index.\n/// \n/// This method has O(1) complexity.\npub fn View::charcode_at(self : View, index : Int) -> Int {\n  guard index >= 0 && index < self.len() else { abort(\"Index out of bounds\") }\n  self.str.unsafe_charcode_at(self.start + index)\n}\n\n///|\n/// Returns the charcode(code unit) at the given index without checking if the\n/// index is within bounds.\n/// \n/// This method has O(1) complexity.\npub fn View::unsafe_charcode_at(self : View, index : Int) -> Int {\n  self.str.unsafe_charcode_at(self.start + index)\n}\n\n///| \n/// Returns the number of Unicode characters in this view.\n/// \n/// Note this has O(n) complexity where n is the length of the code points in \n/// the view.\npub fn View::char_length(self : View) -> Int {\n  self.str.char_length(start_offset=self.start, end_offset=self.end)\n}\n\n///|\n/// Test if the length of the view is equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn View::char_length_eq(self : View, len : Int) -> Bool {\n  self.str.char_length_eq(len, start_offset=self.start, end_offset=self.end)\n}\n\n///|\n/// Test if the length of the view is greater than or equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn View::char_length_ge(self : View, len : Int) -> Bool {\n  self.str.char_length_ge(len, start_offset=self.start, end_offset=self.end)\n}\n\n///|\npub impl Show for View with output(self, logger) {\n  let substr = self.str.substring(start=self.start, end=self.end)\n  String::output(substr, logger)\n}\n\n///|\n/// Returns a new String containing a copy of the characters in this view.\n/// \n/// # Examples\n/// \n/// ```\n/// let str = \"Hello World\"\n/// let view = str[0:5]  // \"Hello\"\n/// inspect!(view.to_string(), content=\"Hello\")\n/// ```\npub impl Show for StringView with to_string(self) {\n  self.str.substring(start=self.start, end=self.end)\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view.\npub fn View::iter(self : View) -> Iter[Char] {\n  Iter::new(fn(yield_) {\n    for index in self.start..<self.end {\n      let c1 = self.str.unsafe_charcode_at(index)\n      if is_leading_surrogate(c1) && index + 1 < self.end {\n        let c2 = self.str.unsafe_charcode_at(index + 1)\n        if is_trailing_surrogate(c2) {\n          let c = code_point_of_surrogate_pair(c1, c2)\n          guard yield_(c) is IterContinue else { break IterEnd }\n          continue index + 2\n        }\n      }\n      guard yield_(Char::from_int(c1)) is IterContinue else { break IterEnd }\n\n    } else {\n      IterContinue\n    }\n  })\n}\n\n///|\npub fn View::iter2(self : View) -> Iter2[Int, Char] {\n  Iter2::new(fn(yield_) {\n    let len = self.len()\n    for index = 0, n = 0; index < len; index = index + 1, n = n + 1 {\n      let c1 = self.str.unsafe_charcode_at(self.start + index)\n      if is_leading_surrogate(c1) && index + 1 < len {\n        let c2 = self.str.unsafe_charcode_at(self.start + index + 1)\n        if is_trailing_surrogate(c2) {\n          let c = code_point_of_surrogate_pair(c1, c2)\n          guard yield_(n, c) is IterContinue else { break IterEnd }\n          continue index + 2, n + 1\n        }\n      }\n      guard yield_(n, Char::from_int(c1)) is IterContinue else { break IterEnd }\n\n    } else {\n      IterContinue\n    }\n  })\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view in reverse order.\npub fn View::rev_iter(self : View) -> Iter[Char] {\n  Iter::new(fn(yield_) {\n    for index = self.end - 1; index >= self.start; index = index - 1 {\n      let c1 = self.str.unsafe_charcode_at(index)\n      if is_trailing_surrogate(c1) && index - 1 >= 0 {\n        let c2 = self.str.unsafe_charcode_at(index - 1)\n        if is_leading_surrogate(c2) {\n          let c = code_point_of_surrogate_pair(c2, c1)\n          guard yield_(c) is IterContinue else { break IterEnd }\n          continue index - 2\n        }\n      }\n      guard yield_(Char::from_int(c1)) is IterContinue else { break IterEnd }\n\n    } else {\n      IterContinue\n    }\n  })\n}\n\n///|\n/// Compares two views for equality. Returns true only if both views\n/// have the same length and contain identical characters in the same order.\npub impl Eq for View with op_equal(self, other) {\n  let len = self.len()\n  guard len == other.len() else { return false }\n  if physical_equal(self.str, other.str) && self.start == other.start {\n    return true\n  }\n  for i in 0..<len {\n    guard self.str.unsafe_charcode_at(self.start + i) ==\n      other.str.unsafe_charcode_at(other.start + i) else {\n      return false\n    }\n\n  }\n  true\n}\n\n///|\n/// Views are ordered lexicographically by their charcodes(code unit). This \n/// orders Unicode characters based on their positions in the code charts. This is\n/// not necessarily the same as \"alphabetical\" order, which varies by language\n/// and locale.\npub impl Compare for View with compare(self, other) {\n  let self_len = self.len()\n  let other_len = other.len()\n  let cmp = self_len.compare(other_len)\n  guard cmp == 0 else { return cmp }\n  if physical_equal(self.str, other.str) && self.start == other.start {\n    return 0\n  }\n  for i in 0..<self_len {\n    let cmp = self.str\n      .unsafe_charcode_at(self.start + i)\n      .compare(other.str.unsafe_charcode_at(other.start + i))\n    guard cmp == 0 else { return cmp }\n\n  }\n  0\n}\n\n///|\n/// The empty view of a string\npub impl Default for View with default() {\n  // todo: remove .view() in new version\n  \"\".view()\n}\n\n///|\n/// Convert char array to string view.\npub fn View::from_array(chars : Array[Char]) -> View {\n  // todo: remove .view() in new version\n  String::from_array(chars).view()\n}\n\n///|\n/// Convert char iterator to string view.\npub fn View::from_iter(iter : Iter[Char]) -> View {\n  // todo: remove .view() in new version\n  String::from_iter(iter).view()\n}\n\n///|\n/// Create a new string by repeating the given character `value` `length` times.\npub fn View::make(length : Int, value : Char) -> View {\n  // todo: remove .view() in new version\n  String::make(length, value).view()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nlet min_leading_surrogate = 0xD800\n\n///|\nlet max_leading_surrogate = 0xDBFF\n\n///|\nlet min_trailing_surrogate = 0xDC00\n\n///|\nlet max_trailing_surrogate = 0xDFFF\n\n///|\nfn is_leading_surrogate(c : Int) -> Bool {\n  min_leading_surrogate <= c && c <= max_leading_surrogate\n}\n\n///|\ntest \"is_leading_surrogate\" {\n  inspect!(is_leading_surrogate(\"🤣\".charcode_at(0)), content=\"true\")\n  inspect!(is_leading_surrogate(\"🤣\".charcode_at(1)), content=\"false\")\n}\n\n///|\nfn is_trailing_surrogate(c : Int) -> Bool {\n  min_trailing_surrogate <= c && c <= max_trailing_surrogate\n}\n\n///|\ntest \"is_trailing_surrogate\" {\n  inspect!(is_trailing_surrogate(\"🤣\".charcode_at(0)), content=\"false\")\n  inspect!(is_trailing_surrogate(\"🤣\".charcode_at(1)), content=\"true\")\n}\n\n///|\nfn code_point_of_surrogate_pair(leading : Int, trailing : Int) -> Char {\n  Char::from_int((leading - 0xD800) * 0x400 + trailing - 0xDC00 + 0x10000)\n}\n\n///|\ntest \"code_point_of_surrogate_pair\" {\n  let s = \"😀\"\n  let leading = s.charcode_at(0)\n  let trailing = s.charcode_at(1)\n  inspect!(code_point_of_surrogate_pair(leading, trailing), content=\"😀\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Convert char array to string.\n///\n/// ```\n/// let s = @string.from_array(['H', 'e', 'l', 'l', 'o'])\n/// assert_eq!(s, \"Hello\")\n/// ```\n///\n/// Do not convert large datas to `Array[Char]` and build a string with `String::from_array`.\n///\n/// For efficiency considerations, it's recommended to use `Buffer` instead.\npub fn String::from_array(chars : Array[Char]) -> String {\n  let buf = StringBuilder::new(size_hint=chars.length() * 4)\n  for c in chars {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n\n///| same as `String::from_array`\npub fn from_array(chars : Array[Char]) -> String {\n  String::from_array(chars)\n}\n\n///|\n/// Convert char iterator to string,\n/// a simple wrapper for `from_array`.\npub fn String::from_iter(iter : Iter[Char]) -> String {\n  let chars = iter.collect()\n  String::from_array(chars)\n}\n\n///|\n/// same as `String::from_iter`\npub fn from_iter(iter : Iter[Char]) -> String {\n  let chars = iter.collect()\n  String::from_array(chars)\n}\n\n///|\n/// Concatenate strings.\n///\n/// ```\n/// let s = @string.concat([\"Hello\", \", \", \"world!\"])\n/// assert_eq!(s, \"Hello, world!\")\n/// let s = @string.concat([\"a\", \"b\", \"c\"], separator=\",\")\n/// assert_eq!(s, \"a,b,c\")\n/// ```\npub fn concat(strings : Array[String], separator~ : String = \"\") -> String {\n  match strings {\n    [] => \"\"\n    [hd, .. tl] => {\n      let mut size_hint = hd.length()\n      for s in tl {\n        size_hint += s.length() + separator.length()\n      }\n      size_hint = size_hint << 1\n      let buf = StringBuilder::new(size_hint~)\n      buf.write_string(hd)\n      if separator == \"\" {\n        for s in tl {\n          buf.write_string(s)\n        }\n      } else {\n        for s in tl {\n          buf.write_string(separator)\n          buf.write_string(s)\n        }\n      }\n      buf.to_string()\n    }\n  }\n}\n\n///|\n/// Strings are ordered lexicographically by their charcodes(code unit). This \n/// orders Unicode characters based on their positions in the code charts. This is\n/// not necessarily the same as \"alphabetical\" order, which varies by language\n/// and locale.\npub impl Compare for String with compare(self, other) {\n  let len = self.length()\n  match len.compare(other.length()) {\n    0 => {\n      for i in 0..<len {\n        let order = self\n          .unsafe_charcode_at(i)\n          .compare(other.unsafe_charcode_at(i))\n        if order != 0 {\n          return order\n        }\n      }\n      0\n    }\n    order => order\n  }\n}\n\n///|\n/// The empty string\npub impl Default for String with default() {\n  \"\"\n}\n\n///|\n/// same as `String::default`\npub fn default() -> String {\n  \"\"\n}\n\n///|\n/// `String` holds a sequence of UTF-16 code units encoded in little endian format\npub fn to_bytes(self : String) -> Bytes {\n  Bytes::of_string(self)\n}\n\n///|\n/// Converts the String into an array of Chars.\npub fn to_array(self : String) -> Array[Char] {\n  self\n  .iter()\n  .fold(init=Array::new(capacity=self.length()), fn(rv, c) {\n    rv.push(c)\n    rv\n  })\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string.\n///\n/// Note: This iterator yields Unicode characters, not Utf16 code units.\n/// As a result, the count of characters returned by `iter().count()` may not be equal to the length of the string returned by `length()`.\n///\n/// ```\n/// let s = \"Hello, World!🤣\";\n/// assert_eq!(s.iter().count(), 14); // Unicode characters\n/// assert_eq!(s.length(), 15); // Utf16 code units\n/// ```\npub fn iter(self : String) -> Iter[Char] {\n  Iter::new(fn(yield_) {\n    let len = self.length()\n    for index in 0..<len {\n      let c1 = self.unsafe_charcode_at(index)\n      if is_leading_surrogate(c1) && index + 1 < len {\n        let c2 = self.unsafe_charcode_at(index + 1)\n        if is_trailing_surrogate(c2) {\n          let c = code_point_of_surrogate_pair(c1, c2)\n          guard yield_(c) is IterContinue else { break IterEnd }\n          continue index + 2\n        }\n      }\n      //TODO: handle garbage input\n      guard yield_(Char::from_int(c1)) is IterContinue else { break IterEnd }\n\n    } else {\n      IterContinue\n    }\n  })\n}\n\n///|\npub fn iter2(self : String) -> Iter2[Int, Char] {\n  Iter2::new(fn(yield_) {\n    let len = self.length()\n    for index = 0, n = 0; index < len; index = index + 1, n = n + 1 {\n      let c1 = self.unsafe_charcode_at(index)\n      if is_leading_surrogate(c1) && index + 1 < len {\n        let c2 = self.unsafe_charcode_at(index + 1)\n        if is_trailing_surrogate(c2) {\n          let c = code_point_of_surrogate_pair(c1, c2)\n          guard yield_(n, c) is IterContinue else { break IterEnd }\n          continue index + 2, n + 1\n        }\n      }\n      //TODO: handle garbage input\n      guard yield_(n, Char::from_int(c1)) is IterContinue else { break IterEnd }\n\n    } else {\n      IterContinue\n    }\n  })\n}\n\n///|\n/// Note: This method operates on Unicode characters, not Utf16 code units.\n/// As a result, the count of characters passed to the folding function may not be equal to the length of the string.\npub fn fold[A](self : String, init~ : A, f : (A, Char) -> A) -> A {\n  let mut rv = init\n  for c in self {\n    rv = f(rv, c)\n  }\n  rv\n}\n\n///|\npub fn rev_fold[A](self : String, init~ : A, f : (A, Char) -> A) -> A {\n  let mut rv = init\n  for c in self.rev_iter() {\n    rv = f(rv, c)\n  }\n  rv\n}\n\n///|\n/// Returns an iterator that yields characters from the end to the start of the string. This function handles\n/// Unicode surrogate pairs correctly, ensuring that characters are not split across surrogate pairs.\n///\n/// # Parameters\n///\n/// - `self` : The input `String` to be iterated in reverse.\n///\n/// # Returns\n///\n/// - An `Iter[Char]` that yields characters from the end to the start of the string.\n///\n/// # Behavior\n///\n/// - The function iterates over the string in reverse order.\n/// - If a trailing surrogate is encountered, it checks for a preceding leading surrogate to form a complete Unicode code point.\n/// - Yields each character or combined code point to the iterator.\n/// - Stops iteration if the `yield_` function returns `IterEnd`.\n///\n/// # Examples\n///\n/// ```\n/// let input = \"Hello, World!\"\n/// let reversed = input.rev_iter().collect()\n/// assert_eq!(reversed, ['!', 'd', 'l', 'r', 'o', 'W', ' ', ',', 'o', 'l', 'l', 'e', 'H'])\n/// ```\npub fn rev_iter(self : String) -> Iter[Char] {\n  Iter::new(fn(yield_) {\n    let len = self.length()\n    for index = len - 1; index >= 0; index = index - 1 {\n      let c1 = self.unsafe_charcode_at(index)\n      if is_trailing_surrogate(c1) && index - 1 >= 0 {\n        let c2 = self.unsafe_charcode_at(index - 1)\n        if is_leading_surrogate(c2) {\n          let c = code_point_of_surrogate_pair(c2, c1)\n          guard yield_(c) is IterContinue else { break IterEnd }\n          continue index - 2\n        }\n      }\n      // TODO: handle garbage input\n      guard yield_(Char::from_int(c1)) is IterContinue else { break IterEnd }\n\n    } else {\n      IterContinue\n    }\n  })\n}\n\n///|\n/// Removes all leading and trailing spaces.\npub fn trim_space(self : String) -> String {\n  self.trim(\" \\n\\r\\t\")\n}\n\n///|\n/// Removes all leading and trailing chars contained in the given string.\npub fn trim(self : String, trim_set : String) -> String {\n  if self == \"\" || trim_set == \"\" {\n    self\n  } else {\n    self.trim_start(trim_set).trim_end(trim_set)\n  }\n}\n\n///|\npub fn contains_char(self : String, c : Char) -> Bool {\n  self.iter().any(fn(ch) { ch == c })\n}\n\n///|\n/// Removes all leading chars contained in the given string.\npub fn trim_start(self : String, trim_set : String) -> String {\n  let len = self.length()\n  for i in 0..<len {\n    let c1 = self.unsafe_charcode_at(i)\n    // check surrogate pair\n    if is_leading_surrogate(c1) && i + 1 < len {\n      let c2 = self.unsafe_charcode_at(i + 1)\n      if is_trailing_surrogate(c2) {\n        let ch = code_point_of_surrogate_pair(c1, c2)\n        if trim_set.contains_char(ch) {\n          continue i + 2\n        } else {\n          return self.substring(start=i)\n        }\n      }\n    }\n    if not(trim_set.contains_char(Char::from_int(self.unsafe_charcode_at(i)))) {\n      return self.substring(start=i)\n    }\n  } else {\n    \"\"\n  }\n}\n\n///|\n/// Removes all trailing chars contained in the given string.\npub fn trim_end(self : String, trim_set : String) -> String {\n  let len = self.length()\n  for i = len - 1; i >= 0; i = i - 1 {\n    let c2 = self.unsafe_charcode_at(i)\n    // check surrogate pair\n    if is_trailing_surrogate(c2) && i - 1 >= 0 {\n      let c1 = self.unsafe_charcode_at(i - 1)\n      if is_leading_surrogate(c1) {\n        let ch = code_point_of_surrogate_pair(c1, c2)\n        if trim_set.contains_char(ch) {\n          continue i - 2\n        } else {\n          return self.substring(end=i + 1)\n        }\n      }\n    }\n    if not(trim_set.contains_char(Char::from_int(self.unsafe_charcode_at(i)))) {\n      return self.substring(end=i + 1)\n    }\n  } else {\n    \"\"\n  }\n}\n\n///|\n/// Returns true if this string is empty.\npub fn is_empty(self : String) -> Bool {\n  self == \"\"\n}\n\n///|\n/// Returns true if this string is blank.\npub fn is_blank(self : String) -> Bool {\n  self.trim_space() == \"\"\n}\n\n///|\n#deprecated(\"Use `s.find(substr)` instead. If the optional argument `from` is not 0, take view from the string first. Please do not use an invalid `from` argument.\")\npub fn index_of(self : String, str : String, from~ : Int = 0) -> Int {\n  if from <= 0 {\n    if self.find(str.view()) is Some(idx) {\n      idx\n    } else {\n      -1\n    }\n  } else if from > self.length() {\n    if str.length() == 0 {\n      self.length()\n    } else {\n      -1\n    }\n  } else if self.view(start_offset=from).find(str.view()) is Some(idx) {\n    idx + from\n  } else {\n    -1\n  }\n}\n\n///|\n/// Returns the last index of the sub string.\n#deprecated(\"Use `s.rev_find(substr)` instead. If the optional argument `from` is not 0, take view from the string first. Please do not use an invalid `from` argument.\")\npub fn last_index_of(\n  self : String,\n  str : String,\n  from~ : Int = self.length()\n) -> Int {\n  if from >= self.length() {\n    if self.rev_find(str.view()) is Some(idx) {\n      idx\n    } else {\n      -1\n    }\n  } else if from < 0 {\n    if str.length() == 0 {\n      self.length()\n    } else {\n      -1\n    }\n  } else if self.view(end_offset=from).rev_find(str.view()) is Some(idx) {\n    idx\n  } else {\n    -1\n  }\n}\n\n///|\n/// Returns true if this string contains given sub string.\npub fn contains(self : String, str : String) -> Bool {\n  self.find(str.view()) is Some(_)\n}\n\n///|\n/// Returns true if this string starts with a sub string.\n#deprecated(\"Use `s.has_prefix(str)` instead.\")\npub fn starts_with(self : String, str : String) -> Bool {\n  self.has_prefix(str.view())\n}\n\n///|\n/// Returns true if this string ends with a sub string.\n#deprecated(\"Use `s.has_suffix(str)` instead.\")\npub fn ends_with(self : String, str : String) -> Bool {\n  self.has_suffix(str.view())\n}\n\n///|\n/// Splits the input `String` into an `Iter` of `String` using the specified `separator`.\n///\n/// # Parameters\n///\n/// - `self` : The input `String` to be split.\n/// - `separator` : The `String` used as the delimiter for splitting.\n///\n/// # Returns\n///\n/// - An `Iter` of `String` where each element is a substring of the original string, separated by the `separator`.\n///\n/// # Behavior\n///\n/// - If the `separator` is an empty string (`\"\"`), the function returns an `Iter` where each element is a single character from the input string converted to a `String`.\n/// - If the `separator` is not empty, the function searches for occurrences of the `separator` in the input string and yields substrings between these occurrences.\n/// - If no more occurrences of the `separator` are found, the remaining part of the string is yielded as the last element of the `Iter`.\n///\n/// # Examples\n///\n/// ```\n/// let input = \"a,b,c,d\"\n/// let separator = \",\"\n/// let result = input.split(separator).collect()\n/// assert_eq!(result, [\"a\", \"b\", \"c\", \"d\"])\n/// ```\npub fn split(self : String, separator : String) -> Iter[String] {\n  let len = self.length()\n  let sep_len = separator.length()\n  if sep_len == 0 {\n    return self.iter().map(fn(c) { c.to_string() })\n  }\n  Iter::new(fn(yield_) {\n    let mut start = 0\n    while start < len {\n      guard self.view(start_offset=start).find(separator.view()) is Some(end) else {\n        if yield_(self.substring(start~)) == IterEnd {\n          break IterEnd\n        }\n        break IterContinue\n      }\n      let end = start + end\n      if yield_(self.substring(start~, end~)) == IterEnd {\n        break IterEnd\n      }\n      start = end + sep_len\n    } else {\n      IterContinue\n    }\n  })\n}\n\n///|\n/// Replace the first old string in this string to new string.\npub fn replace(self : String, old~ : String, new~ : String) -> String {\n  guard self.find(old.view()) is Some(old_idx) else { self }\n  self.substring(end=old_idx) +\n  new +\n  self.substring(start=old_idx + old.length())\n}\n\n///|\n/// Replace all old string in this string to new string.\npub fn replace_all(self : String, old~ : String, new~ : String) -> String {\n  let buf = StringBuilder::new()\n  let len = self.length()\n  let old_len = old.length()\n  if old_len == 0 {\n    buf.write_string(new)\n    self\n    .iter()\n    .each(fn(c) {\n      buf.write_char(c)\n      buf.write_string(new)\n    })\n  } else {\n    let mut start = 0\n    while start < len {\n      guard self.view(start_offset=start).find(old.view()) is Some(end) else {\n        buf.write_string(self.substring(start~))\n        break\n      }\n      let end = start + end\n      buf.write_string(self.substring(start~, end~))\n      buf.write_string(new)\n      start = end + old_len\n    }\n  }\n  buf.to_string()\n}\n\n///|\n/// Converts this string to lowercase.\npub fn to_lower(self : String) -> String {\n  // TODO: deal with non-ascii characters\n  let buf = StringBuilder::new(size_hint=self.length())\n  for c in self {\n    if c >= 'A' && c <= 'Z' {\n      buf.write_char(Char::from_int(c.to_int() + 32))\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\n/// Converts this string to uppercase.\npub fn to_upper(self : String) -> String {\n  // TODO: deal with non-ascii characters\n  let buf = StringBuilder::new(size_hint=self.length())\n  for c in self {\n    if c >= 'a' && c <= 'z' {\n      buf.write_char(Char::from_int(c.to_int() - 32))\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\n/// Reverse string\n/// It respects Unicode characters and surrogate pairs but not grapheme clusters.\n/// TODO: make it an intrinsic function\npub fn rev(self : String) -> String {\n  let buf = StringBuilder::new(size_hint=self.length())\n  for c in self.rev_iter() {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n\n///|\n/// Repeats the string `n` times.\npub fn repeat(self : String, n : Int) -> String {\n  if n <= 0 {\n    return \"\"\n  }\n  if n == 1 {\n    return self\n  }\n  let len = self.length()\n  let buf = StringBuilder::new(size_hint=len * n)\n  for _ in 0..<n {\n    buf.write_string(self)\n  }\n  buf.to_string()\n}\n\n///|\n/// `pad_start` is a new string with `padding_char`s prefixed to `self` if `self.length() < total_width`. The length of the\n/// returned string is `total_width`.\n///\n/// Example:\n///\n/// ```\n/// assert_eq!(\"2\".pad_start(3, '0'), \"002\")\n/// ```\npub fn pad_start(\n  self : String,\n  total_width : Int,\n  padding_char : Char\n) -> String {\n  let len = self.length()\n  if len >= total_width {\n    self\n  } else {\n    let buf = StringBuilder::new(size_hint=total_width)\n    for i in 0..<(total_width - len) {\n      buf.write_char(padding_char)\n    }\n    buf.write_string(self)\n    buf.to_string()\n  }\n}\n\n///|\n/// `pad_end` is a new String with `padding_char`s suffixed to `self` if `self.length() < total_width`. The length of the\n/// returned string is `total_width`.\n///\n/// Example:\n///\n/// ```\n/// assert_eq!(\"2\".pad_end(3, 'x'), \"2xx\")\n/// ```\npub fn pad_end(self : String, total_width : Int, padding_char : Char) -> String {\n  let len = self.length()\n  if len >= total_width {\n    self\n  } else {\n    let buf = StringBuilder::new(size_hint=total_width)\n    buf.write_string(self)\n    for i in 0..<(total_width - len) {\n      buf.write_char(padding_char)\n    }\n    buf.to_string()\n  }\n}\n\n///|\n/// Returns the index of the n-th (zero-indexed) character within the range [start, end).\nfn String::offset_of_nth_char_forward(\n  self : String,\n  n : Int,\n  start_offset~ : Int,\n  end_offset~ : Int\n) -> Int? {\n  guard start_offset >= 0 && start_offset <= end_offset else {\n    abort(\"Invalid start index\")\n  }\n  let mut utf16_offset = start_offset\n  let mut char_count = 0\n  while utf16_offset < end_offset && char_count < n {\n    let c = self.unsafe_charcode_at(utf16_offset)\n    // check if this is a surrogate pair\n    if is_leading_surrogate(c) {\n      utf16_offset = utf16_offset + 2\n    } else {\n      utf16_offset = utf16_offset + 1\n    }\n    char_count = char_count + 1\n  }\n  // Return None if either:\n  // 1. We couldn't reach the requested character offset\n  // 2. The resulting offset is beyond the end of the string\n  // This handles the empty string case correctly.\n  if char_count < n || utf16_offset >= end_offset {\n    None\n  } else {\n    Some(utf16_offset)\n  }\n}\n\n///|\n/// Returns the index of the n-th (zero-indexed) character within the range [start, end).\n/// self[end] is counted as the 0-th character (though it might not exist if end = self.length()).\nfn String::offset_of_nth_char_backward(\n  self : String,\n  n : Int,\n  start_offset~ : Int,\n  end_offset~ : Int\n) -> Int? {\n  let mut char_count = 0\n  let mut utf16_offset = end_offset\n  // Iterating backwards from the end of the string. \n  // Invariant: utf16_offset always points to the previous character\n  while utf16_offset - 1 >= start_offset && char_count < n {\n    let c = self.unsafe_charcode_at(utf16_offset - 1)\n    if is_trailing_surrogate(c) {\n      utf16_offset = utf16_offset - 2\n    } else {\n      utf16_offset = utf16_offset - 1\n    }\n    char_count = char_count + 1\n  }\n  if char_count < n || utf16_offset < start_offset {\n    None\n  } else {\n    Some(utf16_offset)\n  }\n}\n\n///|\n/// Returns the UTF-16 index of the i-th (zero-indexed) Unicode character \n/// within the range [start, end). If i is negative, it returns the index of \n/// the (n + i)-th character where n is the number of Unicode characters \n/// in the range [start, end).\n/// \n/// This functions assumes that the string is valid UTF-16.\npub fn String::offset_of_nth_char(\n  self : String,\n  i : Int,\n  start_offset~ : Int = 0,\n  end_offset~ : Int = self.length()\n) -> Int? {\n  if i >= 0 {\n    // forward case\n    self.offset_of_nth_char_forward(i, start_offset~, end_offset~)\n  } else {\n    // backward case\n    self.offset_of_nth_char_backward(-i, start_offset~, end_offset~)\n  }\n}\n\n///|\n/// Returns the Unicode character at the given index.\npub fn String::char_at(self : String, index : Int) -> Char {\n  guard index >= 0 && index < self.length() else {\n    abort(\"index out of bounds\")\n  }\n  self.unsafe_char_at(index)\n}\n\n///|\n/// Test if the length of the string is equal to the given length.\n///\n/// This has O(n) complexity where n is the length in the parameter.\npub fn String::char_length_eq(\n  self : String,\n  len : Int,\n  start_offset~ : Int = 0,\n  end_offset~ : Int = self.length()\n) -> Bool {\n  for index = start_offset, count = 0\n      index < end_offset && count < len\n      index = index + 1, count = count + 1 {\n    let c1 = self.unsafe_charcode_at(index)\n    if is_leading_surrogate(c1) && index + 1 < end_offset {\n      let c2 = self.unsafe_charcode_at(index + 1)\n      if is_trailing_surrogate(c2) {\n        continue index + 2, count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    count == len && index == end_offset\n  }\n}\n\n///|\n/// Test if the length of the string is greater than or equal to the given length.\n///\n/// This has O(n) complexity where n is the length in the parameter.\npub fn String::char_length_ge(\n  self : String,\n  len : Int,\n  start_offset~ : Int = 0,\n  end_offset~ : Int = self.length()\n) -> Bool {\n  for index = start_offset, count = 0\n      index < end_offset && count < len\n      index = index + 1, count = count + 1 {\n    let c1 = self.unsafe_charcode_at(index)\n    if is_leading_surrogate(c1) && index + 1 < end_offset {\n      let c2 = self.unsafe_charcode_at(index + 1)\n      if is_trailing_surrogate(c2) {\n        continue index + 2, count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    count >= len\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the offset (charcode index) of the first occurrence of the given\n/// substring. If the substring is not found, it returns None.\npub fn View::find(self : View, str : View) -> Int? {\n  let len = self.len()\n  let sub_len = str.len()\n  // Handle empty substring case\n  guard sub_len > 0 else { return Some(0) }\n  // If substring is longer than string, it can't be found\n  guard sub_len <= len else { return None }\n  let max_idx = len - sub_len\n  let first = str.unsafe_charcode_at(0)\n  let mut i = 0\n  while i <= max_idx {\n    // find first character\n    while i < len && self.unsafe_charcode_at(i) != first {\n      i += 1\n    }\n    // check the rest\n    if i <= max_idx {\n      for j in 1..<sub_len {\n        if self.unsafe_charcode_at(i + j) != str.unsafe_charcode_at(j) {\n          break\n        }\n      } else {\n        // the substring is found\n        return Some(i)\n      }\n    }\n    i += 1\n  }\n  None\n}\n\n///|\n/// Returns the offset of the first occurrence of the given substring. If the\n/// substring is not found, it returns None.\npub fn String::find(self : String, str : View) -> Int? {\n  self.view().find(str)\n}\n\n///|\ntest \"find\" {\n  // todo: remove .view() when new version is released\n  inspect!(\"hello\".find(\"o\".view()), content=\"Some(4)\")\n  inspect!(\"hello\".find(\"l\".view()), content=\"Some(2)\")\n  inspect!(\"hello\".find(\"hello\".view()), content=\"Some(0)\")\n  inspect!(\"hello\".find(\"h\".view()), content=\"Some(0)\")\n  inspect!(\"hello\".find(\"\".view()), content=\"Some(0)\")\n  inspect!(\"hello\".find(\"world\".view()), content=\"None\")\n  inspect!(\"\".find(\"\".view()), content=\"Some(0)\")\n  inspect!(\"\".find(\"a\".view()), content=\"None\")\n  inspect!(\"hello hello\".find(\"hello\".view()), content=\"Some(0)\")\n  inspect!(\"aaa\".find(\"aa\".view()), content=\"Some(0)\")\n  inspect!(\"😀😀\".find(\"😀\".view()), content=\"Some(0)\")\n}\n\n///|\n/// Returns the offset of the last occurrence of the given substring. If the\n/// substring is not found, it returns None.\npub fn View::rev_find(self : View, str : View) -> Int? {\n  let len = self.len()\n  let sub_len = str.len()\n  guard sub_len > 0 else { return Some(len) }\n  guard sub_len <= len else { return None }\n  let min_idx = sub_len - 1\n  let last = str.unsafe_charcode_at(sub_len - 1)\n  let mut i = len - 1\n  while i >= min_idx {\n    while i >= 0 && self.unsafe_charcode_at(i) != last {\n      i -= 1\n    }\n    if i >= min_idx {\n      for j in 1..<sub_len {\n        if self.unsafe_charcode_at(i - j) !=\n          str.unsafe_charcode_at(sub_len - 1 - j) {\n          break\n        }\n      } else {\n        return Some(i - sub_len + 1)\n      }\n    }\n    i -= 1\n  }\n  None\n}\n\n///|\n/// Returns the offset (charcode index) of the last occurrence of the given\n/// substring. If the substring is not found, it returns None.\npub fn String::rev_find(self : String, str : View) -> Int? {\n  self.view().rev_find(str)\n}\n\n///|\ntest \"rev_find\" {\n  // todo: remove .view() when new version is released\n  inspect!(\"hello\".rev_find(\"o\".view()), content=\"Some(4)\")\n  inspect!(\"hello\".rev_find(\"l\".view()), content=\"Some(3)\")\n  inspect!(\"hello\".rev_find(\"hello\".view()), content=\"Some(0)\")\n  inspect!(\"hello\".rev_find(\"h\".view()), content=\"Some(0)\")\n  inspect!(\"hello\".rev_find(\"\".view()), content=\"Some(5)\")\n  inspect!(\"hello\".rev_find(\"world\".view()), content=\"None\")\n  inspect!(\"\".rev_find(\"\".view()), content=\"Some(0)\")\n  inspect!(\"\".rev_find(\"a\".view()), content=\"None\")\n  inspect!(\"hello hello\".rev_find(\"hello\".view()), content=\"Some(6)\")\n  inspect!(\"aaa\".rev_find(\"aa\".view()), content=\"Some(1)\")\n  inspect!(\"😀😀\".rev_find(\"😀\".view()), content=\"Some(2)\")\n}\n\n///| \n/// Returns true if the given substring is suffix of this string.\npub fn View::has_suffix(self : View, str : View) -> Bool {\n  self.rev_find(str) is Some(i) && i == self.len() - str.len()\n}\n\n///|\n/// Returns true if the given substring is suffix of this string.\npub fn String::has_suffix(self : String, str : View) -> Bool {\n  self.view().has_suffix(str)\n}\n\n///|\ntest \"has_suffix\" {\n  // todo: remove .view() when new version is released\n  inspect!(\"hello\".has_suffix(\"lo\".view()), content=\"true\")\n  inspect!(\"hello\".has_suffix(\"hello\".view()), content=\"true\")\n  inspect!(\"hello\".has_suffix(\"\".view()), content=\"true\")\n  inspect!(\"hello\".has_suffix(\"world\".view()), content=\"false\")\n  inspect!(\"hello\".has_suffix(\"hel\".view()), content=\"false\")\n  inspect!(\"\".has_suffix(\"\".view()), content=\"true\")\n  inspect!(\"\".has_suffix(\"a\".view()), content=\"false\")\n  inspect!(\"hello world\".has_suffix(\"world\".view()), content=\"true\")\n  inspect!(\"😀😀\".has_suffix(\"😀\".view()), content=\"true\")\n  inspect!(\"😀😀\".has_suffix(\"😀😀\".view()), content=\"true\")\n}\n\n///|\n/// Returns true if this string starts with the given substring.\npub fn View::has_prefix(self : View, str : View) -> Bool {\n  self.find(str) is Some(i) && i == 0\n}\n\n///|\n/// Returns true if this string starts with the given substring.\npub fn String::has_prefix(self : String, str : View) -> Bool {\n  self.view().has_prefix(str)\n}\n\n///|\ntest \"has_prefix\" {\n  // todo: remove .view() when new version is released\n  inspect!(\"hello\".has_prefix(\"h\".view()), content=\"true\")\n  inspect!(\"hello\".has_prefix(\"he\".view()), content=\"true\")\n  inspect!(\"hello\".has_prefix(\"\".view()), content=\"true\")\n  inspect!(\"hello\".has_prefix(\"world\".view()), content=\"false\")\n  inspect!(\"hello\".has_prefix(\"lo\".view()), content=\"false\")\n  inspect!(\"\".has_prefix(\"\".view()), content=\"true\")\n  inspect!(\"\".has_prefix(\"a\".view()), content=\"false\")\n  inspect!(\"😀hello\".has_prefix(\"😀\".view()), content=\"true\")\n  inspect!(\"😀😃hello\".has_prefix(\"😀😃\".view()), content=\"true\")\n  inspect!(\"😀hello\".has_prefix(\"😃\".view()), content=\"false\")\n  inspect!(\"hello😀\".has_prefix(\"😀\".view()), content=\"false\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n#deprecated(\"Use `@string.concat` instead\")\npub fn String::concat(self : Array[String], separator~ : String = \"\") -> String {\n  concat(self, separator~)\n}\n\n///|\ntype StringIndex Int derive(Show, Eq)\n\n///|\n#deprecated(\"StringIndex is deprecated, use String::index_of_nth_char instead\")\npub fn index_at(\n  self : String,\n  offset_by : Int,\n  start~ : StringIndex = 0\n) -> StringIndex? {\n  self.index_at_(offset_by, start~)\n}\n\n///|\n#deprecated(\"StringIndex is deprecated, use String::index_of_nth_char instead\")\npub fn index_at_rev(\n  self : String,\n  offset_by : Int,\n  end? : StringIndex\n) -> StringIndex? {\n  self.index_at_rev_(offset_by, end?)\n}\n\n///|\nfn index_at_(\n  self : String,\n  offset_by : Int,\n  start~ : StringIndex = 0\n) -> StringIndex? {\n  if self.offset_of_nth_char(offset_by, start_offset=start._) is Some(index) {\n    Some(index)\n  } else if offset_by == self.char_length(start_offset=start._) {\n    Some(self.length())\n  } else {\n    None\n  }\n}\n\n///|\nfn index_at_rev_(\n  self : String,\n  offset_by : Int,\n  end? : StringIndex\n) -> StringIndex? {\n  match end {\n    Some(end) =>\n      if offset_by == 0 {\n        Some(end)\n      } else if self.offset_of_nth_char(-offset_by, end_offset=end._)\n        is Some(index) {\n        Some(index)\n      } else {\n        None\n      }\n    None =>\n      if offset_by == 0 {\n        Some(self.length())\n      } else if self.offset_of_nth_char(-offset_by) is Some(index) {\n        Some(index)\n      } else {\n        None\n      }\n  }\n}\n\n///|\n#deprecated(\"use str.view(start = str.index_of_nth_char(i).unwrap(), end = str.index_of_nth_char(j).unwrap()) to replace str[i:j]\")\npub fn String::op_as_view(self : String, start~ : Int = 0, end? : Int) -> View {\n  let str_len = self.length()\n  let start = if start >= 0 {\n    index_at_(self, start, start=0).unwrap()._\n  } else {\n    index_at_rev_(self, -start, end=str_len).unwrap()._\n  }\n  let end = match end {\n    Some(end) =>\n      if end >= 0 {\n        index_at_(self, end, start=0).unwrap()._\n      } else {\n        index_at_rev_(self, -end, end=str_len).unwrap()._\n      }\n    None => str_len\n  }\n  guard start >= 0 && start <= end && end <= str_len else {\n    abort(\"Invalid index for View\")\n  }\n  { str: self, start, end }\n}\n\n///|\n#deprecated(\"use view.view(start = view.index_of_nth_char(i).unwrap(), end = view.index_of_nth_char(j).unwrap()) to replace view[i:j]\")\npub fn View::op_as_view(self : View, start~ : Int = 0, end? : Int) -> View {\n  let start = if start >= 0 {\n    index_at_(self.str, start, start=self.start).unwrap()._\n  } else {\n    index_at_rev_(self.str, -start, end=self.end).unwrap()._\n  }\n  let end = match end {\n    Some(end) =>\n      if end >= 0 {\n        index_at_(self.str, end, start=self.start).unwrap()._\n      } else {\n        index_at_rev_(self.str, -end, end=self.end).unwrap()._\n      }\n    None => self.end\n  }\n  guard start >= self.start &&\n    start <= self.end &&\n    end >= self.start &&\n    end <= self.end &&\n    start <= end else {\n    abort(\"Invalid index for View\")\n  }\n  { str: self.str, start, end }\n}\n\n///|\n#deprecated(\"use View::char_length instead\")\npub fn View::length(self : View) -> Int {\n  self.char_length()\n}\n\n///|\n#deprecated(\"use View::char_length_eq instead\")\npub fn length_eq(self : View, len : Int) -> Bool {\n  self.char_length_eq(len)\n}\n\n///|\n#deprecated(\"use View::char_length_ge instead\")\npub fn length_ge(self : View, len : Int) -> Bool {\n  self.char_length_ge(len)\n}\n\n///|\n/// Returns the character at the given index from the end of the string.\n///\n/// # Examples\n///\n/// ```moonbit\n/// let s = \"Hello🤣🤣🤣\"\n/// inspect!(s.rev_get(0), content=\"🤣\")\n/// inspect!(s.rev_get(4), content=\"l\")\n/// ```\n///\n/// # Panics\n///\n/// @alert unsafe \"Panics if the index is out of bounds.\"\n#deprecated(\"use String::rev_iter().nth(index).unwrap() instead\")\npub fn String::rev_get(self : String, index : Int) -> Char {\n  guard index >= 0\n  self.nth_char(-index - 1)\n}\n\n///|\n/// Test if the length of the string is equal to the given length.\n///\n/// This has O(n) complexity where n is the length in the parameter.\n#deprecated(\"use String::char_length_eq instead\")\npub fn String::length_eq(self : String, len : Int) -> Bool {\n  self.char_length_eq(len)\n}\n\n///|\n/// Test if the length of the string is greater than or equal to the given length.\n///\n/// This has O(n) complexity where n is the length in the parameter.\n#deprecated(\"use String::char_length_ge instead\")\npub fn String::length_ge(self : String, len : Int) -> Bool {\n  self.char_length_ge(len)\n}\n\n///|\n/// Return the character at the given index.\n/// \n/// The time complexity is O(n) where n is the given index, as it needs to scan\n/// through the UTF-16 code units to find the nth Unicode character.\n/// \n/// # Example\n/// \n/// ```\n/// let str = \"Hello🤣🤣🤣\"\n/// let view = str[1:6]\n/// inspect!(view[0], content=\"e\")\n/// inspect!(view[4], content=\"🤣\")\n/// ```\n#deprecated(\"use View::iter().nth(index).unwrap() instead\")\npub fn View::op_get(self : View, index : Int) -> Char {\n  guard index >= 0\n  self.str.nth_char(index, start_offset=self.start, end_offset=self.end)\n}\n\n///|\n/// Returns the character at the given index from the end of the view.\n/// \n/// The time complexity is O(n) where n is the given index, as it needs to scan\n/// through the UTF-16 code units to find the nth Unicode character.\n/// \n/// # Example\n/// \n/// ```\n/// let str = \"Hello🤣🤣🤣\"\n/// let view = str[1:6]\n/// inspect!(view.rev_get(0), content=\"🤣\")\n/// inspect!(view.rev_get(4), content=\"e\")\n/// ```\n#deprecated(\"use View::rev_iter().nth(index).unwrap() instead\")\npub fn rev_get(self : View, index : Int) -> Char {\n  guard index >= 0\n  self.str.nth_char(-index - 1, start_offset=self.start, end_offset=self.end)\n}\n\n///|\nfn String::nth_char(\n  self : String,\n  i : Int,\n  start_offset~ : Int = 0,\n  end_offset~ : Int = self.length()\n) -> Char {\n  if self.offset_of_nth_char(i, start_offset~, end_offset~) is Some(index) {\n    self.unsafe_char_at(index)\n  } else {\n    abort(\"index out of bounds\")\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Creates a new array containing all elements from an iterator.\n///\n/// Parameters:\n///\n/// * `iterator` : An iterator containing elements of type `T`.\n///\n/// Returns a new array containing all elements from the iterator in the same\n/// order.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Array::from_iter\" {\n///   let iter = Iter::singleton(42)\n///   let arr = Array::from_iter(iter)\n///   inspect!(arr, content=\"[42]\")\n/// }\n/// ```\npub fn Array::from_iter[T](iter : Iter[T]) -> Array[T] {\n  iter.collect()\n}\n\n///|\n/// Adds all elements from an iterator to the end of the array.\n///\n/// This function iterates over each element in the provided iterator\n/// and adds them to the array using the `push` method.\n///\n/// # Example\n/// ```\n/// let u = [1, 2, 3]\n/// let v = [4, 5, 6]\n/// u.push_iter(v.iter())\n/// assert_eq!(u, [1, 2, 3, 4, 5, 6])\n/// ```\npub fn push_iter[T](self : Array[T], iter : Iter[T]) -> Unit {\n  for x in iter {\n    self.push(x)\n  }\n}\n\n///|\n/// Creates a new array of the specified length, where each element is\n/// initialized using an index-based initialization function.\n///\n/// Parameters:\n///\n/// * `length` : The length of the new array. If `length` is less than or equal\n/// to 0, returns an empty array.\n/// * `initializer` : A function that takes an index (starting from 0) and\n/// returns a value of type `T`. This function is called for each index to\n/// initialize the corresponding element.\n///\n/// Returns a new array of type `Array[T]` with the specified length, where each\n/// element is initialized using the provided function.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Array::makei\" {\n///   let arr = Array::makei(3, fn(i) { i * 2 })\n///   inspect!(arr, content=\"[0, 2, 4]\")\n/// }\n/// ```\npub fn Array::makei[T](length : Int, value : (Int) -> T) -> Array[T] {\n  if length <= 0 {\n    []\n  } else {\n    let array = Array::make(length, value(0))\n    for i in 1..<length {\n      array[i] = value(i)\n    }\n    array\n  }\n}\n\n///|\n/// Shuffle the array using Knuth shuffle\n/// \n/// To use this function, you need to provide a rand function, which takes an integer as it upper bound\n/// and returns an integer.\n/// *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n/// # Example\n/// \n/// ```\n/// let arr = [1, 2, 3, 4, 5]\n/// fn rand(upper : Int) -> Int {\n///   let rng = @random.new()\n///   rng.int(limit=upper)\n/// }\n/// Array::shuffle_in_place(arr, rand=rand)\n/// ```\npub fn shuffle_in_place[T](self : Array[T], rand~ : (Int) -> Int) -> Unit {\n  let n = self.length()\n  for i = n - 1; i > 0; i = i - 1 {\n    let j = rand(i + 1) % (i + 1)\n    // for safety, perf is not a concern here\n    // TODO: maybe return an error later\n    self.swap(i, j)\n  }\n}\n\n///|\n/// Shuffle the array using Knuth shuffle\n/// \n/// To use this function, you need to provide a rand function, which takes an integer as it upper bound\n/// and returns an integer.\n/// *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n/// # Example\n/// \n/// ```\n/// let arr = [1, 2, 3, 4, 5]\n/// fn rand(upper : Int) -> Int {\n///   let rng = @random.new()\n///   rng.int(limit=upper)\n/// }\n/// let _shuffled = Array::shuffle(arr, rand=rand)\n/// ```\npub fn shuffle[T](self : Array[T], rand~ : (Int) -> Int) -> Array[T] {\n  let new_arr = self.copy()\n  Array::shuffle_in_place(new_arr, rand~)\n  new_arr\n}\n\n///|\n/// Returns a new array containing the elements of the original array that satisfy the given predicate.\n/// \n/// # Arguments\n/// \n/// * `self` - The array to filter.\n/// * `f` - The predicate function.\n/// \n/// # Returns\n/// \npub fn filter_map[A, B](self : Array[A], f : (A) -> B?) -> Array[B] {\n  let result = []\n  for x in self {\n    if f(x) is Some(x) {\n      result.push(x)\n    }\n  }\n  result\n}\n\n///|\n/// Returns the last element of the array, or `None` if the array is empty.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the last element from.\n///\n/// Returns an optional value containing the last element of the array. The\n/// result is `None` if the array is empty, or `Some(x)` where `x` is the last\n/// element of the array.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"last\" {\n///   let arr = [1, 2, 3]\n///   inspect!(arr.last(), content=\"Some(3)\")\n///   let empty : Array[Int] = []\n///   inspect!(empty.last(), content=\"None\")\n/// }\n/// ```\npub fn last[A](self : Array[A]) -> A? {\n  match self {\n    [] => None\n    [.., last] => Some(last)\n  }\n}\n\n///|\npub impl[X : @quickcheck.Arbitrary] @quickcheck.Arbitrary for Array[X] with arbitrary(\n  size,\n  rs\n) {\n  let len = if size == 0 { 0 } else { rs.next_positive_int() % size }\n  Array::makei(len, fn(x) { X::arbitrary(x, rs) })\n}\n\n///|\npub fn join(self : Array[String], separator : String) -> String {\n  @string.concat(self, separator~)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Compares and returns the maximum of two values.\n///\n/// Returns the second argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```\n/// assert_eq!(@math.maximum(1, 2), 2)\n/// assert_eq!(@math.maximum(2, 2), 2)\n/// ```\npub fn maximum[T : Compare](x : T, y : T) -> T {\n  if x > y {\n    x\n  } else {\n    y\n  }\n}\n\n///|\n/// Compares and returns the minimum of two values.\n///\n/// Returns the first argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```\n/// assert_eq!(@math.minimum(1, 2), 1)\n/// assert_eq!(@math.minimum(2, 2), 2)\n/// ```\npub fn minimum[T : Compare](x : T, y : T) -> T {\n  if x > y {\n    y\n  } else {\n    x\n  }\n}\n\n///|\n/// Calculates the cube root of a number.\n///\n/// # Examples\n///\n/// ```\n/// assert_eq!(@math.cbrt(1), 1)\n/// assert_eq!(@math.cbrt(27), 3)\n/// assert_eq!(@math.cbrt(125), 5)\n/// assert_eq!(@math.cbrt(1000), 10)\n/// ```\npub fn cbrt(x : Double) -> Double {\n  x.cbrt()\n}\n\n///|\n/// Returns the hypotenuse of a right-angled triangle whose legs are `x` and `y`.\n///\n/// # Examples\n///\n/// ```\n/// assert_eq!(@math.hypot(3, 4), 5)\n/// assert_eq!(@math.hypot(5, 12), 13)\n/// assert_eq!(@math.hypot(8, 15), 17)\n/// ```\npub fn hypot(x : Double, y : Double) -> Double {\n  x.hypot(y)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Creates an `Option` containing a value if the given condition is true, otherwise returns `None`.\n///\n/// # Arguments\n///\n/// * `condition`: A boolean value indicating whether the option should contain a value.\n/// * `value`: A function that returns the value to be contained in the option.\n///\n/// # Returns\n///\n/// An `Option` containing the value if the condition is true, otherwise `None`.\n///\n/// # Example\n///\n/// ```\n/// let result = @option.when(true, fn(){ \"Hello, World!\" })\n/// assert_eq!(result, Some(\"Hello, World!\"))\n/// ```\npub fn when[T](condition : Bool, value : () -> T) -> T? {\n  if condition {\n    Some(value())\n  } else {\n    None\n  }\n}\n\n///|\ntest \"when\" {\n  let result = when(true, fn() { \"Hello, World!\" })\n  let result2 = when(false, fn() { \"Hello, World!\" })\n  assert_eq!(result, Some(\"Hello, World!\"))\n  assert_eq!(result2, None)\n}\n\n///|\n/// The `unless` function returns an `Option` value based on a condition.\n///\n/// `unless(condition, value)` is equivalent to `when(not(condition), value)`.\n///\n/// # Arguments\n///\n/// * `condition`: A boolean value indicating whether the condition is true or false.\n/// * `value`: A function that returns a value of type `T`.\n///\n/// # Returns\n///\n/// An `Option` value that is `Some(value())` if the condition is false, otherwise `None`.\n///\npub fn unless[T](condition : Bool, value : () -> T) -> T? {\n  when(not(condition), value)\n}\n\n///|\ntest \"unless\" {\n  let result = unless(true, fn() { \"Hello, World!\" })\n  let result2 = unless(false, fn() { \"Hello, World!\" })\n  assert_eq!(result, None)\n  assert_eq!(result2, Some(\"Hello, World!\"))\n}\n\n///|\n/// Creates an empty `Option` of type `T`.\npub fn empty[T]() -> T? {\n  None\n}\n\n///|\ntest \"empty\" {\n  let x : Int? = None\n  let y : Int? = empty()\n  assert_eq!(x, y)\n}\n\n///|\n/// Creates an `Option` that contains a value.\npub fn some[T](value : T) -> T? {\n  Some(value)\n}\n\n///|\ntest \"some\" {\n  let x : Int? = Some(5)\n  let y : Int? = some(5)\n  assert_eq!(x, y)\n}\n\n///|\n/// Maps the value of an `Option` using a provided function.\n///\n/// # Example\n///\n/// ```\n/// let a = Some(5)\n/// assert_eq!(a.map(fn(x){ x * 2 }), Some(10))\n///\n/// let b = None\n/// assert_eq!(b.map(fn(x){ x * 2 }), None)\n/// ```\npub fn map[T, U](self : T?, f : (T) -> U) -> U? {\n  match self {\n    Some(t) => Some(f(t))\n    None => None\n  }\n}\n\n///|\ntest \"map\" {\n  let a = Option::Some(5)\n  let b : Int? = None\n  assert_eq!(a.map(fn(x) { x * 2 }), Some(10))\n  assert_eq!(b.map(fn(x) { x * 2 }), None)\n}\n\n///|\n/// Returns the provided default result (if none), or applies a function to the contained value (if any).\n/// Arguments passed to map_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use `map_or_else`, which is lazily evaluated.\n///\n/// # Example\n///\n/// ```\n/// let a = Some(5)\n/// assert_eq!(a.map_or(3, fn(x){ x * 2 }), 10)\n/// ```\npub fn map_or[T, U](self : T?, default : U, f : (T) -> U) -> U {\n  match self {\n    None => default\n    Some(x) => f(x)\n  }\n}\n\n///|\ntest \"map_or\" {\n  let a = Option::Some(\"foo\")\n  let b : String? = Option::None\n  assert_eq!(a.map_or(42, fn(x) { x.length() }), 3)\n  assert_eq!(b.map_or(42, fn(x) { x.length() }), 42)\n}\n\n///|\n/// Computes a default function result (if none), or applies a different function to the contained value (if any).\n///\n/// # Example\n///\n/// ```\n/// let a = Some(5)\n/// assert_eq!(a.map_or_else(fn(){ 3 }, fn(x){ x * 2 }), 10)\n/// ```\npub fn map_or_else[T, U](self : T?, default : () -> U, f : (T) -> U) -> U {\n  match self {\n    None => default()\n    Some(x) => f(x)\n  }\n}\n\n///|\ntest \"map_or_else\" {\n  let k = 21\n  let a = Option::Some(\"foo\")\n  let b : String? = Option::None\n  assert_eq!(a.map_or_else(fn() { 2 * k }, fn(x) { x.length() }), 3)\n  assert_eq!(b.map_or_else(fn() { 2 * k }, fn(x) { x.length() }), 42)\n}\n\n///|\n/// Binds an option to a function that returns another option.\n///\n/// # Example\n///\n/// ```\n/// let a = Option::Some(5)\n/// let r1 = a.bind(fn(x){ Some(x * 2) })\n/// assert_eq!(r1, Some(10))\n/// let b : Option[Int] = None\n/// let r2 = b.bind(fn(x){ Some(x * 2) })\n/// assert_eq!(r2, None)\n/// ```\npub fn bind[T, U](self : T?, f : (T) -> U?) -> U? {\n  match self {\n    Some(t) => f(t)\n    None => None\n  }\n}\n\n///|\ntest \"bind\" {\n  let a = Option::Some(5)\n  let b : Int? = None\n  assert_eq!(a.bind(fn(x) { Some(x * 2) }), Some(10))\n  assert_eq!(b.bind(fn(x) { Some(x * 2) }), None)\n}\n\n///|\n/// Flattens an `Option` of `Option` into a single `Option`.\n///\n/// If the input `Option` is `Some(Some(value))`, the function returns `Some(value)`.\n///\n/// # Example\n///\n/// ```\n/// let a = Some(Some(42));\n/// assert_eq!(@option.flatten(a), Some(42))\n/// let b : Int?? = Some(None)\n/// assert_eq!(@option.flatten(b), None)\n/// ```\npub fn flatten[T](self : T??) -> T? {\n  match self {\n    Some(inner) => inner\n    None => None\n  }\n}\n\n///|\ntest \"flatten\" {\n  let a : Int?? = Some(Some(42))\n  assert_eq!(flatten(a), Some(42))\n  let b : Int?? = Some(None)\n  assert_eq!(flatten(b), None)\n}\n\n///|\n/// Checks if the option is empty.\npub fn is_empty[T](self : T?) -> Bool {\n  self is None\n}\n\n///|\ntest \"is_empty\" {\n  let x = Option::Some(3)\n  let y : Int? = None\n  assert_false!(x.is_empty())\n  assert_true!(y.is_empty())\n}\n\n///|\n/// Filters the option by applying the given predicate function `f`.\n///\n/// If the predicate function `f` returns `true` for the value contained in the option,\n/// the same option is returned. Otherwise, `None` is returned.\n///\n/// # Example\n/// ```\n/// let x = Some(3)\n/// assert_eq!(x.filter(fn(x){ x > 5 }), None)\n/// assert_eq!(x.filter(fn(x){ x < 5 }), Some(3))\n/// ```\npub fn filter[T](self : T?, f : (T) -> Bool) -> T? {\n  match self {\n    Some(t) => if f(t) { self } else { None }\n    None => None\n  }\n}\n\n///|\ntest \"filter\" {\n  let x = Option::Some(3)\n  assert_eq!(x.filter(fn(x) { x > 5 }), None)\n  assert_eq!(x.filter(fn(x) { x < 5 }), Some(3))\n}\n\n///|\n/// Return the contained `Some` value or the provided default.\npub fn or[T](self : T?, default : T) -> T {\n  match self {\n    None => default\n    Some(t) => t\n  }\n}\n\n///|\ntest \"or\" {\n  let x = Option::Some(3)\n  assert_eq!(x.or(5), 3)\n  assert_eq!((None : Int?).or(5), 5)\n}\n\n///|\n/// Return the contained `Some` value or the provided default.\n///\n/// Default is lazily evaluated\npub fn or_else[T](self : T?, default : () -> T) -> T {\n  match self {\n    None => default()\n    Some(t) => t\n  }\n}\n\n///|\ntest \"or else\" {\n  let x = Option::Some(3)\n  assert_eq!(x.or_else(fn() { 5 }), 3)\n  assert_eq!((None : Int?).or_else(fn() { 5 }), 5)\n}\n\n///|\n/// Return the contained `Some` value or the result of the `T::default()`.\npub fn or_default[T : Default](self : T?) -> T {\n  match self {\n    None => T::default()\n    Some(t) => t\n  }\n}\n\n///|\ntest \"or default\" {\n  let x = Option::Some(3)\n  assert_eq!(x.or_default(), 3)\n  assert_eq!((None : Int?).or_default(), 0)\n}\n\n///|\npub impl[X : Compare] Compare for X? with compare(self, other) {\n  match (self, other) {\n    (Some(x), Some(y)) => x.compare(y)\n    (Some(_), None) => 1\n    (None, Some(_)) => -1\n    (None, None) => 0\n  }\n}\n\n///|\ntest \"compare\" {\n  let some1 = Option::Some(1)\n  let some2 = Option::Some(2)\n  let none = Option::None\n  assert_eq!(0, some1.compare(Option::Some(1)))\n  assert_eq!(-1, some1.compare(some2))\n  assert_eq!(1, some2.compare(some1))\n  assert_eq!(0, none.compare(none))\n  assert_eq!(-1, none.compare(some1))\n  assert_eq!(1, some2.compare(none))\n}\n\n///|\n/// `None`\npub impl[X] Default for X? with default() {\n  None\n}\n\n///|\npub fn iter[T](self : T?) -> Iter[T] {\n  match self {\n    Some(v) => Iter::singleton(v)\n    None => Iter::empty()\n  }\n}\n\n///|\ntest \"iter\" {\n  let x = Option::Some(42)\n  let exb = StringBuilder::new(size_hint=0)\n  x\n  .iter()\n  .each(fn(x) {\n    exb.write_string(x.to_string())\n    exb.write_char('\\n')\n  })\n  inspect!(\n    exb,\n    content=\n      #|42\n      #|\n    ,\n  )\n  exb.reset()\n  let y : Int? = None\n  y\n  .iter()\n  .each(fn(x) {\n    exb.write_string(x.to_string())\n    exb.write_char('\\n')\n  })\n  inspect!(exb, content=\"\")\n}\n\n///|\npub fn or_error[T, Err : Error](self : T?, err : Err) -> T!Err {\n  match self {\n    Some(v) => v\n    None => raise err\n  }\n}\n\n///|\ntest \"or error\" {\n  assert_eq!(\n    try {\n      (None : String?).or_error!(Failure(\"This is serious\"))\n    } catch {\n      Failure(err) => err\n    },\n    \"This is serious\",\n  )\n  assert_eq!(\n    try {\n      Some(\"This is ok\").or_error!(Failure(\"This is serious\"))\n    } catch {\n      Failure(err) => err\n    },\n    \"This is ok\",\n  )\n}\n\n///|\npub impl[X : @quickcheck.Arbitrary] @quickcheck.Arbitrary for X? with arbitrary(\n  i,\n  rs\n) {\n  if rs.next_double() < 0.3 {\n    None\n  } else {\n    Some(@quickcheck.Arbitrary::arbitrary(i, rs))\n  }\n}\n\n///|\ntest \"arbitrary\" {\n  let samples : Array[Int?] = @quickcheck.samples(10)\n  inspect!(\n    samples,\n    content=\"[None, None, Some(-1), Some(0), None, Some(0), Some(-5), Some(2), None, Some(4)]\",\n  )\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Evaluates an expression and discards its result. This is useful when you want\n/// to execute an expression for its side effects but don't care about its return\n/// value, or when you want to explicitly indicate that a value is intentionally\n/// unused.\n///\n/// Parameters:\n///\n/// * `value` : The value to be ignored. Can be of any type.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"ignore\" {\n///   let x = 42\n///   ignore(x) // Explicitly ignore the value\n///   let mut sum = 0\n///   ignore([1, 2, 3].iter().each(fn(x) { sum = sum + x })) // Ignore the Unit return value of each()\n/// }\n/// ```\npub fn ignore[T](t : T) -> Unit = \"%ignore\"\n\n///|\n/// Tests if two values are physically equal (i.e., point to the same memory\n/// location). Unlike structural equality testing (`==`), this function checks if\n/// two references point to exactly the same object in memory.\n///\n/// Parameters:\n///\n/// * `first` : The first value to compare.\n/// * `second` : The second value to compare.\n/// * `T` : The type parameter representing the type of values being compared.\n///\n/// Returns `true` if both values refer to the same object in memory, `false`\n/// otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"physical_equal\" {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = arr1\n///   let arr3 = [1, 2, 3]\n///   inspect!(physical_equal(arr1, arr2), content=\"true\") // Same object\n///   inspect!(physical_equal(arr1, arr3), content=\"false\") // Different objects with same content\n/// }\n/// ```\npub fn physical_equal[T](a : T, b : T) -> Bool = \"%refeq\"\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"panic abort/with_message\" {\n///   let x : Int = abort(\"Something went wrong\") // specify return type as Int\n///   ignore(x)\n/// }\n/// ```\npub fn abort[T](msg : String) -> T {\n  ignore(msg)\n  panic()\n}\n\n///|\npub fn panic[T]() -> T = \"%panic\"\n\n// Bool primitive ops\n\n///|\n/// Performs logical negation on a boolean value.\n///\n/// Parameters:\n///\n/// * `value` : The boolean value to negate.\n///\n/// Returns the logical NOT of the input value: `true` if the input is `false`,\n/// and `false` if the input is `true`.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"not\" {\n///   inspect!(not(true), content=\"false\")\n///   inspect!(not(false), content=\"true\")\n/// }\n/// ```\npub fn not(x : Bool) -> Bool = \"%bool_not\"\n\n///|\n/// Compares two boolean values for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare.\n///\n/// Returns `true` if both boolean values are equal (either both `true` or both\n/// `false`), `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Bool::op_equal\" {\n///   inspect!(true == true, content=\"true\")\n///   inspect!(false == true, content=\"false\")\n///   inspect!(true == false, content=\"false\")\n///   inspect!(false == false, content=\"true\")\n/// }\n/// ```\npub impl Eq for Bool with op_equal(self : Bool, other : Bool) -> Bool = \"%bool_eq\"\n\n///|\n/// Compares two boolean values and returns their relative order. This is a\n/// deprecated method and users should use `compare` instead.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other` (i.e., `self` is `false`\n/// and `other` is `true`)\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other` (i.e., `self` is `true`\n/// and `other` is `false`)\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Bool::op_compare/deprecated\" {\n///   let t = true\n///   let f = false\n///   // This usage is deprecated, use compare() instead\n///   inspect!(t.compare(f), content=\"1\")\n///   inspect!(f.compare(t), content=\"-1\")\n///   inspect!(t.compare(t), content=\"0\")\n/// }\n/// ```\n///\n#deprecated(\"Use `compare` instead\")\n#coverage.skip\npub fn Bool::op_compare(self : Bool, other : Bool) -> Int = \"%bool_compare\"\n\n///|\n/// Compares two boolean values and returns their relative order. The comparison\n/// follows the rule that `false` is less than `true`.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is `false` and `other` is `true`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is `true` and `other` is `false`\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Bool::compare\" {\n///   inspect!(true.compare(false), content=\"1\") // true > false\n///   inspect!(false.compare(true), content=\"-1\") // false < true\n///   inspect!(true.compare(true), content=\"0\") // true = true\n/// }\n/// ```\npub impl Compare for Bool with compare(self, other) = \"%bool_compare\"\n\n///|\n/// Returns the default value for the `Bool` type, which is `false`.\n///\n/// Returns a `Bool` value that represents the default state of a boolean value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Bool::default\" {\n///   let b : Bool = Bool::default()\n///   inspect!(b, content=\"false\")\n/// }\n/// ```\npub impl Default for Bool with default() = \"%bool_default\"\n\n// int32 primitive ops\n\n///|\n/// Performs arithmetic negation on an integer value, returning its additive\n/// inverse.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to negate.\n///\n/// Returns the negation of the input value. For all inputs except\n/// `Int::min_value()`, returns the value with opposite sign. When the input is\n/// `Int::min_value()`, returns `Int::min_value()` due to two's complement\n/// representation.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::op_neg\" {\n///   inspect!(-42, content=\"-42\")\n///   inspect!(42, content=\"42\")\n///   inspect!(--2147483647, content=\"2147483647\") // negating near min value\n/// }\n/// ```\npub impl Neg for Int with op_neg(self) = \"%i32_neg\"\n\n///|\n/// Adds two 32-bit signed integers. Performs two's complement arithmetic, which\n/// means the operation will wrap around if the result exceeds the range of a\n/// 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer that is the sum of the two operands. If the\n/// mathematical sum exceeds the range of a 32-bit integer (-2,147,483,648 to\n/// 2,147,483,647), the result wraps around according to two's complement rules.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::op_add\" {\n///   inspect!(42 + 1, content=\"43\")\n///   inspect!(2147483647 + 1, content=\"-2147483648\") // Overflow wraps around to minimum value\n/// }\n/// ```\npub impl Add for Int with op_add(self, other) = \"%i32_add\"\n\n///|\n/// Performs subtraction between two 32-bit integers, following standard two's\n/// complement arithmetic rules. When the result overflows or underflows, it\n/// wraps around within the 32-bit integer range.\n///\n/// Parameters:\n///\n/// * `self` : The minuend (the number being subtracted from).\n/// * `other` : The subtrahend (the number to subtract).\n///\n/// Returns the difference between `self` and `other`.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::op_sub\" {\n///   let a = 42\n///   let b = 10\n///   inspect!(a - b, content=\"32\")\n///   let max = 2147483647 // Int maximum value\n///   inspect!(max - -1, content=\"-2147483648\") // Overflow case\n/// }\n/// ```\npub impl Sub for Int with op_sub(self, other) = \"%i32_sub\"\n\n///|\n/// Multiplies two 32-bit integers. This is the implementation of the `*`\n/// operator for `Int`.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns the product of the two integers. If the result overflows the range of\n/// `Int`, it wraps around according to two's complement arithmetic.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::op_mul\" {\n///   inspect!(42 * 2, content=\"84\")\n///   inspect!(-10 * 3, content=\"-30\")\n///   let max = 2147483647 // Int.max_value\n///   inspect!(max * 2, content=\"-2\") // Overflow wraps around\n/// }\n/// ```\npub impl Mul for Int with op_mul(self, other) = \"%i32_mul\"\n\n///|\n/// Performs integer division between two 32-bit integers. The result is\n/// truncated towards zero (rounds down for positive numbers and up for negative\n/// numbers).\n///\n/// Parameters:\n///\n/// * `dividend` : The first integer operand to be divided.\n/// * `divisor` : The second integer operand that divides the dividend.\n///\n/// Returns the quotient of the division operation.\n///\n/// Throws a panic if `divisor` is zero.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::op_div\" {\n///   inspect!(10 / 3, content=\"3\") // truncates towards zero\n///   inspect!(-10 / 3, content=\"-3\")\n///   inspect!(10 / -3, content=\"-3\")\n/// }\n///\n/// test \"panic Int::op_div/division_by_zero\" {\n///   ignore(42 / 0) // Panics with division by zero\n/// }\n/// ```\npub impl Div for Int with op_div(self, other) = \"%i32_div\"\n\n///|\n/// Calculates the remainder of dividing one integer by another. The result\n/// follows the formula `dividend - (dividend / divisor) * divisor`, maintaining\n/// the same sign as the dividend.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number being divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns the remainder of the division. If `other` is 0, the behavior is\n/// undefined.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::op_mod\" {\n///   inspect!(7 % 3, content=\"1\")\n///   inspect!(-7 % 3, content=\"-1\")\n///   inspect!(7 % -3, content=\"1\")\n/// }\n///\n/// test \"panic Int::op_mod/division_by_zero\" {\n///   ignore(7 % 0) // Panics with division by zero\n/// }\n/// ```\npub impl Mod for Int with op_mod(self, other) = \"%i32_mod\"\n\n///|\n/// Performs a bitwise NOT operation on a 32-bit integer. Flips each bit in the\n/// integer's binary representation (0 becomes 1 and 1 becomes 0).\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit integer on which to perform the bitwise NOT operation.\n///\n/// Returns a new integer with all bits flipped from the input value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::lnot\" {\n///   let a = -1 // All bits are 1\n///   let b = 0 // All bits are 0\n///   inspect!(a.lnot(), content=\"0\")\n///   inspect!(b.lnot(), content=\"-1\")\n/// }\n/// ```\npub fn Int::lnot(self : Int) -> Int = \"%i32_lnot\"\n\n///|\n/// Performs a bitwise AND operation between two 32-bit integers. Each bit in the\n/// result is set to 1 only if the corresponding bits in both operands are 1.\n///\n/// Parameters:\n///\n/// * `self` : The first 32-bit integer operand.\n/// * `other` : The second 32-bit integer operand.\n///\n/// Returns the result of the bitwise AND operation. The resulting value has a\n/// bit set to 1 at each position where both input integers have a bit set to 1.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::land\" {\n///   let x = 0xF0 // 11110000\n///   let y = 0xAA // 10101010\n///   inspect!(x & y, content=\"160\") // 10100000 = 160\n/// }\n/// ```\npub fn Int::land(self : Int, other : Int) -> Int = \"%i32_land\"\n\n///|\n/// Performs a bitwise OR operation between two 32-bit integers. For each bit\n/// position, the result is 1 if at least one of the corresponding bits in either\n/// operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if at least one of the\n/// corresponding bits in either operand is 1, and 0 otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::lor\" {\n///   let x = 0xF0F0 // 1111_0000_1111_0000\n///   let y = 0x0F0F // 0000_1111_0000_1111\n///   inspect!(x | y, content=\"65535\") // 1111_1111_1111_1111 = 65535\n/// }\n/// ```\npub fn Int::lor(self : Int, other : Int) -> Int = \"%i32_lor\"\n\n///|\n/// Performs a bitwise XOR operation between two integers.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if the corresponding bits in\n/// the operands are different, and 0 if they are the same.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::lxor\" {\n///   let x = 0xF0F0 // 1111_0000_1111_0000\n///   let y = 0x0F0F // 0000_1111_0000_1111\n///   inspect!(x ^ y, content=\"65535\") // 1111_1111_1111_1111\n///   inspect!(x ^ x, content=\"0\") // XOR with self gives 0\n/// }\n/// ```\npub fn Int::lxor(self : Int, other : Int) -> Int = \"%i32_lxor\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the\n/// rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift. Must be a non-negative value\n/// less than 32. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new integer with bits shifted left by the specified number of\n/// positions. For each position shifted, the rightmost bit is filled with 0, and\n/// the leftmost bit is discarded.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::op_shl\" {\n///   let x = 1\n///   inspect!(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = -4\n///   inspect!(y << 2, content=\"-16\") // Binary: 100 -> 10000\n/// }\n/// ```\npub impl Shl for Int with op_shl(self, other) = \"%i32_shl\"\n\n///|\n/// Performs an arithmetic right shift operation on an integer value. Shifts the\n/// bits of the first operand to the right by the number of positions specified\n/// by the second operand. The sign bit is preserved and copied to the leftmost\n/// positions.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the right. Must be\n/// non-negative.\n///\n/// Returns an integer representing the result of the arithmetic right shift\n/// operation.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::op_shr\" {\n///   let n = -16\n///   inspect!(n >> 2, content=\"-4\") // Sign bit is preserved during shift\n///   let p = 16\n///   inspect!(p >> 2, content=\"4\") // Regular right shift for positive numbers\n/// }\n/// ```\npub impl Shr for Int with op_shr(self, other) = \"%i32_shr\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the vacated\n/// bit positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the left.\n///\n/// Returns an integer containing the result of shifting `self` left by `shift`\n/// positions.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::lsl\" {\n///   let x = 1\n///   inspect!(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = 42\n///   inspect!(y << 2, content=\"168\") // Binary: 101010 -> 10101000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::lsl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts the bits of the\n/// first operand to the left by the specified number of positions. The rightmost\n/// positions are filled with zeros.\n///\n/// Parameters:\n///\n/// * `value` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift left. Must be non-negative and\n/// less than 32.\n///\n/// Returns a new integer value after performing the left shift operation. The\n/// value is equal to multiplying the input by 2 raised to the power of the shift\n/// count.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::shl\" {\n///   let x = 1\n///   inspect!(x << 3, content=\"8\") // Equivalent to x << 3\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::shl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a logical right shift operation on a signed 32-bit integer. In a\n/// logical right shift, zeros are shifted in from the left, regardless of the\n/// sign bit. This function is DEPRECATED and users should use `UInt` type with\n/// the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The signed 32-bit integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a signed 32-bit integer containing the same bits as if the input were\n/// treated as an unsigned integer and shifted right logically.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::lsr\" {\n///   let x = -4 // Binary: 11111...11100\n///   let unsigned = x.reinterpret_as_uint() // Convert to UInt first\n///   inspect!(unsigned >> 1, content=\"2147483646\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use UInt type and infix operator `>>` instead\")\n#coverage.skip\npub fn Int::lsr(self : Int, other : Int) -> Int {\n  (self.reinterpret_as_uint() >> other).reinterpret_as_int()\n}\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer value,\n/// preserving the sign bit by replicating it into the positions vacated by the\n/// shift. This is a deprecated function; use the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new integer value that is the result of arithmetically shifting\n/// `self` right by `shift` positions.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::asr\" {\n///   let x = -16\n///   inspect!(x >> 2, content=\"-4\") // Right shift preserves sign bit\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::asr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer by the\n/// specified number of positions. The operation preserves the sign bit,\n/// replicating it into the positions vacated by the shift.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right.\n///\n/// Returns a new integer representing the result of shifting `self` right by\n/// `shift` positions.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::shr\" {\n///   let n = -1024\n///   inspect!(n >> 3, content=\"-128\") // Preserves sign bit during right shift\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::shr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Counts the number of consecutive zero bits at the least significant end of\n/// the integer's binary representation.\n///\n/// Parameters:\n///\n/// * `self` : The integer value whose trailing zeros are to be counted.\n///\n/// Returns the number of trailing zero bits (0 to 32). For example, returns 0 if\n/// the value is odd (least significant bit is 1), returns 32 if the value is 0\n/// (all bits are zeros).\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::ctz\" {\n///   let x = 0\n///   inspect!(x.ctz(), content=\"32\") // All bits are zero\n///   let y = 1\n///   inspect!(y.ctz(), content=\"0\") // No trailing zeros\n///   let z = 16\n///   inspect!(z.ctz(), content=\"4\") // Binary: ...10000\n/// }\n/// ```\npub fn Int::ctz(self : Int) -> Int = \"%i32_ctz\"\n\n///|\npub fn Int::clz(self : Int) -> Int = \"%i32_clz\"\n\n///|\n/// Counts the number of set bits (1s) in the binary representation of a 32-bit\n/// integer.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer whose bits are to be counted.\n///\n/// Returns the number of bits set to 1 in the binary representation of the input\n/// integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::popcnt\" {\n///   let x = 0b1011 // Binary: 1011 (3 bits set)\n///   inspect!(x.popcnt(), content=\"3\")\n///   let y = -1 // All bits set in two's complement\n///   inspect!(y.popcnt(), content=\"32\")\n/// }\n/// ```\npub fn Int::popcnt(self : Int) -> Int = \"%i32_popcnt\"\n\n///|\n/// Compares two integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::op_equal\" {\n///   inspect!(42 == 42, content=\"true\")\n///   inspect!(42 == -42, content=\"false\")\n/// }\n/// ```\npub impl Eq for Int with op_equal(self : Int, other : Int) -> Bool = \"%i32_eq\"\n\n///|\n/// Compares two integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::compare\" {\n///   let a = 42\n///   let b = 24\n///   inspect!(a.compare(b), content=\"1\") // 42 > 24\n///   inspect!(b.compare(a), content=\"-1\") // 24 < 42\n///   inspect!(a.compare(a), content=\"0\") // 42 = 42\n/// }\n/// ```\npub impl Compare for Int with compare(self, other) = \"%i32_compare\"\n\n///|\npub fn Int::is_pos(self : Int) -> Bool = \"%i32_is_pos\"\n\n///|\n/// Tests whether an integer is negative.\n///\n/// Parameters:\n///\n/// * `self` : The integer to test.\n///\n/// Returns `true` if the integer is negative, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::is_neg\" {\n///   let neg = -42\n///   let zero = 0\n///   let pos = 42\n///   inspect!(neg.is_neg(), content=\"true\")\n///   inspect!(zero.is_neg(), content=\"false\")\n///   inspect!(pos.is_neg(), content=\"false\")\n/// }\n/// ```\npub fn Int::is_neg(self : Int) -> Bool = \"%i32_is_neg\"\n\n///|\npub fn Int::is_non_pos(self : Int) -> Bool = \"%i32_is_non_pos\"\n\n///|\npub fn Int::is_non_neg(self : Int) -> Bool = \"%i32_is_non_neg\"\n\n///|\n/// Returns the default value for integers, which is 0.\n///\n/// Returns an integer value of 0.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::default\" {\n///   let x : Int = Int::default()\n///   inspect!(x, content=\"0\")\n/// }\n/// ```\npub impl Default for Int with default() = \"%i32_default\"\n\n///|\n/// Converts a 32-bit integer to a double-precision floating-point number. The\n/// conversion preserves the exact value since all integers in the range of `Int`\n/// can be represented exactly as `Double` values.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that represents the same\n/// numerical value as the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::to_double\" {\n///   let n = 42\n///   inspect!(n.to_double(), content=\"42\")\n///   let neg = -42\n///   inspect!(neg.to_double(), content=\"-42\")\n/// }\n/// ```\npub fn Int::to_double(self : Int) -> Double = \"%i32_to_f64\"\n\n///|\n/// Converts a double-precision floating-point number to an unsigned 32-bit\n/// integer by truncating the decimal part. When the input is NaN or negative,\n/// returns 0. When the input exceeds the maximum value of UInt (4294967295),\n/// returns 4294967295.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the truncated value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::trunc_double\" {\n///   inspect!(UInt::trunc_double(42.75), content=\"42\")\n/// }\n/// ```\npub fn UInt::trunc_double(val : Double) -> UInt = \"%f64.to_u32\"\n\n///|\n/// reinterpret the signed int as unsigned int, when the value is\n/// non-negative, i.e, 0..=2^31-1, the value is the same. When the\n/// value is negative, it turns into a large number,\n/// for example, -1 turns into 2^32-1\npub fn Int::reinterpret_as_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n\n///|\n/// Reinterprets a signed 32-bit integer as an unsigned 32-bit integer. For\n/// numbers within the range \\[0, 2^31-1], the value remains the same. For\n/// negative numbers, they are reinterpreted as large positive numbers in the\n/// range \\[2^31, 2^32-1].\n///\n/// Parameters:\n///\n/// * `value` : The signed 32-bit integer to be reinterpreted.\n///\n/// Returns an unsigned 32-bit integer that has the same bit pattern as the\n/// input.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::to_uint\" {\n///   let pos = 42\n///   let neg = -1\n///   inspect!(pos.reinterpret_as_uint(), content=\"42\")\n///   inspect!(neg.reinterpret_as_uint(), content=\"4294967295\") // 2^32 - 1\n/// }\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_uint` instead\")\n#coverage.skip\npub fn Int::to_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n// Double primitive ops\n\n///|\n/// Converts a 32-bit signed integer to an unsigned 64-bit integer by first\n/// converting it to a signed 64-bit integer and then reinterpreting the bits as\n/// an unsigned value.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted.\n///\n/// Returns an unsigned 64-bit integer representing the same bit pattern as the\n/// input value when extended to 64 bits.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::to_uint64\" {\n///   let pos = 42\n///   inspect!(pos.to_uint64(), content=\"42\")\n///   let neg = -1\n///   inspect!(neg.to_uint64(), content=\"18446744073709551615\") // 2^64 - 1\n/// }\n/// ```\npub fn Int::to_uint64(self : Int) -> UInt64 {\n  self.to_int64().reinterpret_as_uint64()\n}\n\n///|\n/// Negates a double-precision floating-point number. For non-NaN inputs, changes\n/// the sign of the number. For NaN inputs, returns NaN.\n///\n/// Parameters:\n///\n/// * `number` : The double-precision floating-point number to negate.\n///\n/// Returns a new double-precision floating-point number that is the negation of\n/// the input number.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Double::op_neg\" {\n///   inspect!(-42.0, content=\"-42\")\n///   inspect!(--42.0, content=\"42\")\n///   inspect!(-(0.0 / 0.0), content=\"NaN\") // Negating NaN returns NaN\n/// }\n/// ```\npub impl Neg for Double with op_neg(self) = \"%f64_neg\"\n\n///|\n/// Adds two double-precision floating-point numbers together following IEEE 754\n/// standards.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number.\n/// * `other` : The second double-precision floating-point number to add.\n///\n/// Returns the sum of the two numbers. Special cases follow IEEE 754 rules:\n///\n/// * If either operand is NaN, returns NaN\n/// * If adding +∞ and -∞, returns NaN\n/// * If adding ±∞ with any finite number, returns ±∞\n/// * If adding +0.0 and -0.0, returns +0.0\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Double::op_add\" {\n///   inspect!(2.5 + 3.7, content=\"6.2\")\n///   inspect!(1.0 / 0.0 + -1.0 / 0.0, content=\"NaN\") // Infinity + -Infinity = NaN\n/// }\n/// ```\npub impl Add for Double with op_add(self, other) = \"%f64_add\"\n\n///|\n/// Performs subtraction between two double-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first operand (minuend).\n/// * `other` : The second operand (subtrahend).\n///\n/// Returns the difference between the two numbers according to IEEE 754\n/// double-precision arithmetic rules.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Double::op_sub\" {\n///   let a = 5.0\n///   let b = 3.0\n///   inspect!(a - b, content=\"2\")\n///   inspect!(0.0 / 0.0 - 1.0, content=\"NaN\") // NaN - anything = NaN\n/// }\n/// ```\npub impl Sub for Double with op_sub(self, other) = \"%f64_sub\"\n\n///|\n/// Multiplies two double-precision floating-point numbers. This is the\n/// implementation of the `*` operator for `Double` type.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point operand.\n/// * `other` : The second double-precision floating-point operand.\n///\n/// Returns a new double-precision floating-point number representing the product\n/// of the two operands. Special cases follow IEEE 754 standard:\n///\n/// * If either operand is NaN, returns NaN\n/// * If one operand is infinity and the other is zero, returns NaN\n/// * If one operand is infinity and the other is a non-zero finite number,\n/// returns infinity with the appropriate sign\n/// * If both operands are infinity, returns infinity with the appropriate sign\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Double::op_mul\" {\n///   inspect!(2.5 * 2.0, content=\"5\")\n///   inspect!(-2.0 * 3.0, content=\"-6\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect!(nan * 1.0, content=\"NaN\")\n/// }\n/// ```\npub impl Mul for Double with op_mul(self, other) = \"%f64_mul\"\n\n///|\n/// Performs division between two double-precision floating-point numbers.\n/// Follows IEEE 754 standard for floating-point arithmetic, including handling\n/// of special cases like division by zero (returns infinity) and operations\n/// involving NaN.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (numerator) in the division operation.\n/// * `other` : The divisor (denominator) in the division operation.\n///\n/// Returns the result of dividing `self` by `other`. Special cases follow IEEE\n/// 754:\n///\n/// * Division by zero returns positive or negative infinity based on the\n/// dividend's sign\n/// * Operations involving NaN return NaN\n/// * Division of infinity by infinity returns NaN\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Double::op_div\" {\n///   inspect!(6.0 / 2.0, content=\"3\")\n///   inspect!(-6.0 / 2.0, content=\"-3\")\n///   inspect!(1.0 / 0.0, content=\"Infinity\")\n/// }\n/// ```\npub impl Div for Double with op_div(self, other) = \"%f64_div\"\n\n///|\n/// Calculates the square root of a double-precision floating-point number. For\n/// non-negative numbers, returns the positive square root. For negative numbers\n/// or NaN, returns NaN.\n///\n/// Parameters:\n///\n/// * `self` : The double-precision floating-point number whose square root is to\n/// be calculated.\n///\n/// Returns the square root of the input number, or NaN if the input is negative\n/// or NaN.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Double::sqrt\" {\n///   inspect!(4.0.sqrt(), content=\"2\")\n///   inspect!(0.0.sqrt(), content=\"0\")\n///   inspect!((-1.0).sqrt(), content=\"NaN\")\n/// }\n/// ```\npub fn Double::sqrt(self : Double) -> Double = \"%f64_sqrt\"\n\n///|\n/// Compares two double-precision floating-point numbers for equality following\n/// IEEE 754 rules. Returns `true` if both numbers are equal, including when both\n/// are `NaN`. Note that this differs from the standard IEEE 754 behavior where\n/// `NaN` is not equal to any value, including itself.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare.\n///\n/// Returns `true` if both numbers are equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Double::op_equal\" {\n///   let a = 3.14\n///   let b = 3.14\n///   let c = 2.718\n///   inspect!(a == b, content=\"true\")\n///   inspect!(a == c, content=\"false\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect!(nan == nan, content=\"false\") // Note: NaN equals itself in MoonBit\n/// }\n/// ```\npub impl Eq for Double with op_equal(self : Double, other : Double) -> Bool = \"%f64_eq\"\n\n///|\n/// Tests for inequality between two double-precision floating-point numbers.\n/// Takes into account special cases like NaN, where two NaN values are\n/// considered not equal to each other.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare.\n///\n/// Returns `true` if the two numbers are not equal according to IEEE 754 rules,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Double::op_neq\" {\n///   inspect!(1.0 != 2.0, content=\"true\")\n///   inspect!(1.0 != 1.0, content=\"false\")\n///   inspect!(0.0 / 0.0 != 0.0 / 0.0, content=\"true\") // NaN != NaN\n/// }\n/// ```\npub fn Double::op_neq(self : Double, other : Double) -> Bool = \"%f64_ne\"\n\n///|\n/// Compares two double-precision floating-point numbers and returns their\n/// relative order. Follows IEEE 754 rules for floating-point comparisons,\n/// including handling of special values like NaN.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare\n/// against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n/// * If either value is NaN, returns an implementation-defined value that is\n/// consistent with total ordering\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Double::compare\" {\n///   let a = 3.14\n///   let b = 2.718\n///   inspect!(a.compare(b), content=\"1\") // 3.14 > 2.718\n///   inspect!(b.compare(a), content=\"-1\") // 2.718 < 3.14\n///   inspect!(a.compare(a), content=\"0\") // 3.14 = 3.14\n/// }\n/// ```\npub impl Compare for Double with compare(self, other) = \"%f64_compare\"\n\n///|\n/// Returns the default value for double-precision floating-point numbers (0.0).\n///\n/// Returns a `Double` value initialized to 0.0.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Double::default\" {\n///   inspect!(Double::default(), content=\"0\")\n/// }\n/// ```\npub impl Default for Double with default() = \"%f64_default\"\n\n///|\nfn Double::to_unchecked_int(self : Double) -> Int = \"%f64_to_i32\"\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Double::convert_uint\" {\n///   let n = 42U\n///   inspect!(Double::convert_uint(n), content=\"42\")\n///   let max = 4294967295U // maximum value of UInt\n///   inspect!(Double::convert_uint(max), content=\"4294967295\")\n/// }\n/// ```\npub fn Double::convert_uint(val : UInt) -> Double = \"%u32.to_f64\"\n\n// Char primitive ops\n\n///|\n/// Converts a character to its Unicode code point value as an integer.\n///\n/// Parameters:\n///\n/// * `self` : The character to be converted.\n///\n/// Returns an integer representing the Unicode code point value of the\n/// character.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Char::to_int\" {\n///   inspect!('A'.to_int(), content=\"65\") // ASCII value of 'A'\n///   inspect!('あ'.to_int(), content=\"12354\") // Unicode code point of 'あ'\n/// }\n/// ```\npub fn Char::to_int(self : Char) -> Int = \"%char_to_int\"\n\n///|\n/// Converts a Unicode character to its unsigned 32-bit integer code point\n/// representation. The character's code point value is first converted to a\n/// signed integer and then reinterpreted as an unsigned integer.\n///\n/// Parameters:\n///\n/// * `character` : The Unicode character to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the character's Unicode code\n/// point.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Char::to_uint\" {\n///   let c = 'A'\n///   inspect!(c.to_uint(), content=\"65\") // ASCII value of 'A'\n///   let emoji = '🤣'\n///   inspect!(emoji.to_uint(), content=\"129315\") // Unicode code point U+1F923\n/// }\n/// ```\npub fn Char::to_uint(self : Char) -> UInt {\n  self.to_int().reinterpret_as_uint()\n}\n\n///|\n///\npub fn Char::from_int(val : Int) -> Char = \"%char_from_int\"\n\n///|\n/// Compares two characters for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare.\n///\n/// Returns `true` if both characters represent the same Unicode code point,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Char::op_equal\" {\n///   let a = 'A'\n///   let b = 'A'\n///   let c = 'B'\n///   inspect!(a == b, content=\"true\")\n///   inspect!(a == c, content=\"false\")\n/// }\n/// ```\npub impl Eq for Char with op_equal(self : Char, other : Char) -> Bool = \"%char_eq\"\n\n///|\n/// Compares two characters based on their Unicode code points. Returns a\n/// negative value if the first character comes before the second, zero if they\n/// are equal, and a positive value if the first character comes after the\n/// second.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare against.\n///\n/// Returns an integer indicating the relative ordering:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Char::compare\" {\n///   inspect!('a'.compare('b'), content=\"-1\")\n///   inspect!('b'.compare('a'), content=\"1\")\n///   inspect!('a'.compare('a'), content=\"0\")\n/// }\n/// ```\npub impl Compare for Char with compare(self, other) = \"%char_compare\"\n\n///|\n/// Returns the default value for the `Char` type, which is the null character\n/// (`'\\x00'`).\n///\n/// Returns a `Char` value representing the null character.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Char::default\" {\n///   assert_true!(Char::default().to_string() == \"\\x00\")\n/// }\n/// ```\npub impl Default for Char with default() = \"%char_default\"\n\n// Bytes primitive ops\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to access.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a byte value from the specified position in the sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Bytes::op_get\" {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect!(bytes[1], content=\"b'\\\\x02'\")\n/// }\n///\n/// test \"panic Bytes::op_get/out_of_bounds\" {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   ignore(bytes[3]) // Index out of bounds\n/// }\n/// ```\npub fn Bytes::op_get(self : Bytes, idx : Int) -> Byte = \"%bytes_get\"\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence without\n/// performing bounds checking. This is a low-level operation that should be used\n/// with caution.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to retrieve the byte from.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a single byte from the specified position in the byte sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Bytes::unsafe_get\" {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect!(bytes.unsafe_get(1), content=\"b'\\\\x02'\")\n/// }\n///\n/// test \"panic Bytes::unsafe_get/out_of_bounds\" {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   ignore(bytes.unsafe_get(3)) // Index out of bounds\n/// }\n/// ```\n///\n/// @alert unsafe \"Panic if index is out of bounds\"\npub fn Bytes::unsafe_get(self : Bytes, idx : Int) -> Byte = \"%bytes_get\"\n\n///|\n/// Returns the number of bytes in a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence whose length is to be determined.\n///\n/// Returns an integer representing the length (number of bytes) of the sequence.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Bytes::length\" {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect!(bytes.length(), content=\"3\")\n///   let empty = b\"\"\n///   inspect!(empty.length(), content=\"0\")\n/// }\n/// ```\npub fn Bytes::length(self : Bytes) -> Int = \"%bytes_length\"\n\n///|\n/// Creates a new byte sequence of the specified length, where each byte is\n/// initialized to the given value. Returns an empty byte sequence if the\n/// length is negative.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be non-negative.\n/// * `initial_value` : The byte value used to initialize each position in the\n/// sequence.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Bytes::make\" {\n///   let bytes = Bytes::make(3, b'\\xFF')\n///   inspect!(bytes, content=\n///   #|b\"\\xff\\xff\\xff\"\n/// )\n///   let empty = Bytes::make(0, b'\\x00')\n///   inspect!(empty, content=\"b\\\"\\\"\")\n/// }\n/// ```\npub fn Bytes::make(len : Int, init : Byte) -> Bytes {\n  if len < 0 {\n    return []\n  }\n  Bytes::unsafe_make(len, init)\n}\n\n///|\nfn Bytes::unsafe_make(len : Int, init : Byte) -> Bytes = \"%bytes_make\"\n\n///|\n/// Creates a new byte sequence filled with zero bytes.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be a\n/// non-negative integer.\n///\n/// Returns a new byte sequence of the specified length, with all bytes\n/// initialized to zero.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Bytes::new\" {\n///   let bytes = Bytes::new(3)\n///   inspect!(bytes, content=\"b\\\"\\\\x00\\\\x00\\\\x00\\\"\")\n/// }\n///\n/// test \"Bytes::new/empty\" {\n///   let bytes = Bytes::new(0)\n///   inspect!(bytes, content=\"b\\\"\\\"\")\n/// }\n/// ```\npub fn Bytes::new(len : Int) -> Bytes {\n  Bytes::make(len, b'\\x00')\n}\n\n///|\n/// Converts a 32-bit signed integer to a byte by taking its least significant 8\n/// bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::to_byte\" {\n///   let n = 258 // In binary: 100000010\n///   inspect!(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n///   let neg = -1 // In binary: all 1's\n///   inspect!(neg.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// }\n/// ```\npub fn Int::to_byte(self : Int) -> Byte = \"%i32_to_byte\"\n\n///|\n/// Converts an unsigned 64-bit integer to a byte by truncating it to fit within\n/// the byte range (0 to 255).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt64::to_byte\" {\n///   let n = 258UL // In binary: 100000010\n///   inspect!(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n/// }\n/// ```\npub fn UInt64::to_byte(self : UInt64) -> Byte {\n  self.to_int().to_byte()\n}\n\n// FixedArray primitive ops\n\n///|\n/// Retrieves an element at the specified index from a fixed-size array. This\n/// function implements the array indexing operator `[]`.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to access.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (negative or greater\n/// than or equal to the length of the array).\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"FixedArray::op_get\" {\n///   let arr = FixedArray::make(3, 42)\n///   inspect!(arr[1], content=\"42\")\n/// }\n///\n/// test \"panic FixedArray::op_get/out_of_bounds\" {\n///   let arr = FixedArray::make(3, 0)\n///   ignore(arr[3]) // Index out of bounds\n/// }\n/// ```\npub fn FixedArray::op_get[T](self : FixedArray[T], idx : Int) -> T = \"%fixedarray.get\"\n\n///|\n/// Retrieves an element from a fixed-size array at the specified index without\n/// performing bounds checking. This is an unsafe operation that may cause\n/// undefined behavior if used incorrectly.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to retrieve the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index in the array.\n///\n/// Throws a panic if the index is out of bounds (negative or greater than or\n/// equal to the array's length).\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"FixedArray::unsafe_get\" {\n///   let arr = FixedArray::make(3, 42)\n///   inspect!(arr.unsafe_get(1), content=\"42\")\n/// }\n///\n/// test \"panic FixedArray::unsafe_get/out_of_bounds\" {\n///   let arr = FixedArray::make(3, 42)\n///   ignore(arr.unsafe_get(3)) // Index out of bounds\n/// }\n/// ```\n///\n/// @alert unsafe \"Panic if index is out of bounds\"\npub fn FixedArray::unsafe_get[T](self : FixedArray[T], idx : Int) -> T = \"%fixedarray.unsafe_get\"\n\n///|\n/// Retrieves an element at the specified index from a fixed-size array. This\n/// function is similar to `op_get` but provides explicit bounds checking.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to access.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the length of the array).\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"FixedArray::get\" {\n///   let arr = [1, 2, 3]\n///   inspect!(arr.get(1), content=\"Some(2)\")\n/// }\n///\n/// test \"FixedArray::get/out_of_bounds\" {\n///   let arr = [1, 2, 3]\n///   inspect!(arr.get(3), content=\"None\")\n/// }\n/// ```\npub fn FixedArray::get[T](self : FixedArray[T], idx : Int) -> T = \"%fixedarray.get\"\n\n///|\n/// Sets a value at the specified index in a fixed-size array. The original value\n/// at that index is overwritten.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to modify.\n/// * `index` : The position in the array where the value will be set.\n/// * `value` : The new value to assign at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the length of the array).\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"FixedArray::op_set\" {\n///   let arr = [1, 2, 3]\n///   arr[1] = 42\n///   inspect!(arr, content=\"[1, 42, 3]\")\n/// }\n///\n/// test \"panic FixedArray::op_set/out_of_bounds\" {\n///   let arr = [1, 2, 3]\n///   arr[3] = 42 // Index out of bounds\n/// }\n/// ```\n///\n/// @alert unsafe \"Panic if index is out of bounds.\"\n#intrinsic(\"%fixedarray.set\")\npub fn FixedArray::op_set[T](self : FixedArray[T], idx : Int, val : T) -> Unit = \"%fixedarray.set\"\n\n///|\n/// Sets the value at the specified index in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to be modified.\n/// * `index` : The index at which to set the value. Must be non-negative and\n/// less than the array's length.\n/// * `value` : The value to be set at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the array's length).\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"FixedArray::set\" {\n///   let arr = FixedArray::make(3, 0)\n///   arr.set(1, 42)\n///   inspect!(arr[1], content=\"42\")\n/// }\n///\n/// test \"panic FixedArray::set/out_of_bounds\" {\n///   let arr = FixedArray::make(3, 0)\n///   ignore(arr.set(3, 42)) // Panic: index out of bounds\n/// }\n/// ```\npub fn FixedArray::set[T](self : FixedArray[T], idx : Int, val : T) -> Unit = \"%fixedarray.set\"\n\n///|\n/// Returns the number of elements in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array whose length is to be determined.\n///\n/// Returns an integer representing the number of elements in the array.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"FixedArray::length\" {\n///   let arr = FixedArray::make(3, 42)\n///   inspect!(arr.length(), content=\"3\")\n/// }\n/// ```\npub fn FixedArray::length[T](self : FixedArray[T]) -> Int = \"%fixedarray.length\"\n\n///|\n/// Creates a new fixed-size array with the specified length, initializing all\n/// elements with the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be non-negative.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new fixed-size array of type `FixedArray[T]` with `length`\n/// elements, where each element is initialized to `initial_value`.\n///\n/// Throws a panic if `length` is negative.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"FixedArray::make\" {\n///   let arr = FixedArray::make(3, 42)\n///   inspect!(arr[0], content=\"42\")\n///   inspect!(arr.length(), content=\"3\")\n/// }\n///\n/// test \"panic FixedArray::make/negative_length\" {\n///   ignore(FixedArray::make(-1, 0))\n/// }\n/// ```\npub fn FixedArray::make[T](len : Int, init : T) -> FixedArray[T] = \"%fixedarray.make\"\n\n// String primitive ops\n\n///|\n/// Returns the number of UTF-16 code units in the string. Note that this is not\n/// necessarily equal to the number of Unicode characters (code points) in the\n/// string, as some characters may be represented by multiple UTF-16 code units.\n///\n/// Parameters:\n///\n/// * `string` : The string whose length is to be determined.\n///\n/// Returns the number of UTF-16 code units in the string.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"String::length\" {\n///   inspect!(\"hello\".length(), content=\"5\")\n///   inspect!(\"🤣\".length(), content=\"2\") // Emoji uses two UTF-16 code units\n///   inspect!(\"\".length(), content=\"0\") // Empty string\n/// }\n/// ```\npub fn String::length(self : String) -> Int = \"%string_length\"\n\n///|\n#deprecated(\"use `length` instead\")\npub fn String::charcode_length(self : String) -> Int = \"%string_length\"\n\n///|\n/// Retrieves the character at the specified index in a string. Each character in\n/// the string is represented as a UTF-16 code unit.\n///\n/// Parameters:\n///\n/// * `string` : The string from which to retrieve the character.\n/// * `index` : The position in the string from which to retrieve the character.\n///\n/// Returns the character at the specified index.\n///\n/// Throws a runtime error if `index` is negative or greater than or equal to the\n/// length of the string.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"String::op_get\" {\n///   let s = \"Hello, 世界!\"\n///   inspect!(s[0], content=\"H\")\n///   inspect!(s[7], content=\"世\")\n/// }\n///\n/// test \"panic String::op_get/out_of_bounds\" {\n///   let s = \"Hello\"\n///   ignore(s[5]) // Index out of bounds\n/// }\n/// ```\n///\n/// @alert unsafe \"Panic if index is out of bounds\"\npub fn String::op_get(self : String, idx : Int) -> Char = \"%string_get\"\n\n///|\n/// Retrieves the character at the specified index in a string.\n///\n/// Parameters:\n///\n/// * `string` : The string to access.\n/// * `index` : The position in the string from which to retrieve the character.\n///\n/// Returns a Unicode character at the specified position in the string.\n///\n/// Throws a runtime error if the index is negative or greater than or equal to\n/// the length of the string.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"String::get\" {\n///   let s = \"Hello, 世界\"\n///   inspect!(s.get(0), content=\"H\")\n///   inspect!(s.get(7), content=\"世\")\n/// }\n///\n/// test \"panic String::get/out_of_bounds\" {\n///   let s = \"Hello\"\n///   ignore(s.get(-1)) // Negative index\n///   ignore(s.get(5)) // Index equals length\n/// }\n/// ```\n#deprecated(\"use `charcode_at` instead\")\npub fn String::get(self : String, idx : Int) -> Char = \"%string_get\"\n\n///|\n/// Returns the UTF-16 code unit at a given position in the string without\n/// performing bounds checking. This is a low-level function that provides direct\n/// access to the internal representation of the string.\n///\n/// Parameters:\n///\n/// * `string` : The string from which to retrieve the code unit.\n/// * `index` : The position of the code unit to retrieve.\n///\n/// Returns the UTF-16 code unit at the specified position as an integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"String::unsafe_charcode_at\" {\n///   let s = \"Hello🤣\"\n///   inspect!(s.unsafe_charcode_at(0), content=\"72\") // 'H'\n///   inspect!(s.unsafe_charcode_at(5), content=\"55358\") // First surrogate of 🤣\n///   inspect!(s.unsafe_charcode_at(6), content=\"56611\") // Second surrogate of 🤣\n/// }\n/// ```\n///\n/// @alert unsafe \"Panic if index is out of bounds.\"\npub fn String::unsafe_charcode_at(self : String, idx : Int) -> Int = \"%string.unsafe_get\"\n\n///|\n/// Concatenates two strings, creating a new string that contains all characters\n/// from the first string followed by all characters from the second string.\n///\n/// Parameters:\n///\n/// * `self` : The first string to concatenate.\n/// * `other` : The second string to concatenate.\n///\n/// Returns a new string containing the concatenation of both input strings.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"String::op_add\" {\n///   let hello = \"Hello\"\n///   let world = \" World!\"\n///   inspect!(hello + world, content=\"Hello World!\")\n///   inspect!(\"\" + \"abc\", content=\"abc\") // concatenating with empty string\n/// }\n/// ```\npub impl Add for String with op_add(self, other) = \"%string_add\"\n\n///|\n/// Tests whether two strings are equal by comparing their characters.\n///\n/// Parameters:\n///\n/// * `self` : The first string to compare.\n/// * `other` : The second string to compare.\n///\n/// Returns `true` if both strings contain exactly the same sequence of\n/// characters, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"String::op_equal\" {\n///   let str1 = \"hello\"\n///   let str2 = \"hello\"\n///   let str3 = \"world\"\n///   inspect!(str1 == str2, content=\"true\")\n///   inspect!(str1 == str3, content=\"false\")\n/// }\n/// ```\npub impl Eq for String with op_equal(self : String, other : String) -> Bool = \"%string_eq\"\n\n///|\n/// Returns the string itself without any modifications. This method is primarily\n/// used to implement the `Show` trait, which requires a `to_string` function.\n///\n/// Parameters:\n///\n/// * `string` : The string value to be returned.\n///\n/// Returns the same string that was passed in.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"String::to_string\" {\n///   let s = \"hello\"\n///   inspect!(s.to_string(), content=\"hello\")\n/// }\n/// ```\npub fn String::to_string(self : String) -> String = \"%string_to_string\"\n\n///|\n// For internal use only\npriv extern type UnsafeMaybeUninit[_]\n\n///|\n/// Converts a byte value to a 32-bit signed integer. The resulting integer will\n/// have the same binary representation as the byte value, preserving the\n/// numerical value in the range \\[0, 255].\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an integer.\n///\n/// Returns a 32-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Byte::to_int\" {\n///   let b = b'\\xFF' // byte with value 255\n///   inspect!(b.to_int(), content=\"255\")\n///   let zero = b'\\x00'\n///   inspect!(zero.to_int(), content=\"0\")\n/// }\n/// ```\npub fn Byte::to_int(self : Byte) -> Int = \"%byte_to_int\"\n\n///|\n/// Converts a byte value to a 64-bit signed integer by first converting it to a\n/// 32-bit integer and then extending it to a 64-bit integer.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 64-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Byte::to_int64\" {\n///   let b = b'\\xFF'\n///   inspect!(b.to_int64(), content=\"255\")\n/// }\n/// ```\npub fn Byte::to_int64(self : Byte) -> Int64 {\n  self.to_int().to_int64()\n}\n\n///|\n/// reinterpret the unsigned int as signed int\n/// For number within the range of 0..=2^31-1,\n/// the value is the same. For number within the range of 2^31..=2^32-1,\n/// the value is negative\npub fn UInt::reinterpret_as_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Reinterprets an unsigned 32-bit integer as a signed 32-bit integer. For\n/// values within the range of 0 to 2^31-1, the value remains the same. For\n/// values within the range of 2^31 to 2^32-1, the value becomes negative due to\n/// two's complement representation.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be reinterpreted.\n///\n/// Returns a signed 32-bit integer that has the same bit pattern as the input\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::to_int\" {\n///   let a = 42U\n///   inspect!(a.reinterpret_as_int(), content=\"42\")\n///   let b = 4294967295U // maximum value of UInt (2^32 - 1)\n///   inspect!(b.reinterpret_as_int(), content=\"-1\") // becomes -1 when reinterpreted as Int\n/// }\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_int` instead\")\n#coverage.skip\npub fn UInt::to_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Performs addition between two unsigned 32-bit integers. If the result\n/// overflows, it wraps around according to the rules of modular arithmetic\n/// (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand to be added.\n///\n/// Returns the sum of the two unsigned integers, wrapped around if necessary.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::op_add\" {\n///   let a = 42U\n///   let b = 100U\n///   inspect!(a + b, content=\"142\")\n///\n///   // Demonstrate overflow behavior\n///   let max = 4294967295U // UInt::max_value\n///   inspect!(max + 1U, content=\"0\")\n/// }\n/// ```\npub impl Add for UInt with op_add(self, other) = \"%u32.add\"\n\n///|\n/// Performs subtraction between two unsigned 32-bit integers. When the result\n/// would be negative, the function wraps around using modular arithmetic (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer (minuend).\n/// * `other` : The second unsigned 32-bit integer to subtract from the first\n/// (subtrahend).\n///\n/// Returns a new unsigned 32-bit integer representing the difference between the\n/// two numbers. If the result would be negative, it wraps around to a positive\n/// number by adding 2^32 repeatedly until the result is in range.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::op_sub\" {\n///   let a = 5U\n///   let b = 3U\n///   inspect!(a - b, content=\"2\")\n///   let c = 3U\n///   let d = 5U\n///   inspect!(c - d, content=\"4294967294\") // wraps around to 2^32 - 2\n/// }\n/// ```\npub impl Sub for UInt with op_sub(self, other) = \"%u32.sub\"\n\n///|\n/// Performs multiplication between two unsigned 32-bit integers. The result\n/// wraps around if it exceeds the maximum value of `UInt`.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand.\n///\n/// Returns the product of the two unsigned integers. If the result exceeds the\n/// maximum value of `UInt` (4294967295), it wraps around to the corresponding\n/// value modulo 2^32.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::op_mul\" {\n///   let a = 3U\n///   let b = 4U\n///   inspect!(a * b, content=\"12\")\n///   let max = 4294967295U\n///   inspect!(max * 2U, content=\"4294967294\") // Wraps around to max * 2 % 2^32\n/// }\n/// ```\npub impl Mul for UInt with op_mul(self, other) = \"%u32.mul\"\n\n///|\n/// Performs division between two unsigned 32-bit integers. The operation follows\n/// standard unsigned integer division rules, where the result is truncated\n/// towards zero.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number to be divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns an unsigned 32-bit integer representing the quotient of the division.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::op_div\" {\n///   let a = 42U\n///   let b = 5U\n///   inspect!(a / b, content=\"8\") // Using infix operator\n/// }\n///\n/// test \"panic UInt::op_div/division_by_zero\" {\n///   let a = 42U\n///   ignore(a / 0U) // Throws runtime error: division by zero\n/// }\n/// ```\npub impl Div for UInt with op_div(self, other) = \"%u32.div\"\n\n///|\n/// Calculates the remainder of dividing one unsigned integer by another.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned integer dividend.\n/// * `other` : The unsigned integer divisor.\n///\n/// Returns the remainder of the division operation.\n///\n/// Throws a panic if `other` is zero.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::op_mod\" {\n///   let a = 17U\n///   let b = 5U\n///   inspect!(a % b, content=\"2\") // 17 divided by 5 gives quotient 3 and remainder 2\n///   inspect!(7U % 4U, content=\"3\")\n/// }\n///\n/// test \"panic UInt::op_mod/division_by_zero\" {\n///   let a = 42U\n///   ignore(a % 0U) // Panics: division by zero\n/// }\n/// ```\npub impl Mod for UInt with op_mod(self, other) = \"%u32.mod\"\n\n///|\n/// Compares two unsigned 32-bit integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand to compare with.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::op_equal\" {\n///   let a = 42U\n///   let b = 42U\n///   let c = 24U\n///   inspect!(a == b, content=\"true\")\n///   inspect!(a == c, content=\"false\")\n/// }\n/// ```\npub impl Eq for UInt with op_equal(self : UInt, other : UInt) -> Bool = \"%u32.eq\"\n\n///|\n/// Checks if two unsigned 32-bit integers are not equal.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer to compare.\n/// * `other` : The second unsigned integer to compare.\n///\n/// Returns `true` if the two integers are not equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::op_neq\" {\n///   let a = 42U\n///   let b = 24U\n///   inspect!(a != b, content=\"true\")\n///   inspect!(a != a, content=\"false\")\n/// }\n/// ```\npub fn UInt::op_neq(self : UInt, other : UInt) -> Bool = \"%u32.ne\"\n\n///|\n/// Compares two unsigned 32-bit integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer to compare.\n/// * `other` : The second unsigned integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::compare\" {\n///   let a = 42U\n///   let b = 24U\n///   inspect!(a.compare(b), content=\"1\") // 42 > 24\n///   inspect!(b.compare(a), content=\"-1\") // 24 < 42\n///   inspect!(a.compare(a), content=\"0\") // 42 = 42\n/// }\n/// ```\npub impl Compare for UInt with compare(self, other) = \"%u32.compare\"\n\n///|\n/// Performs a bitwise AND operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if the bits at that position in both\n/// operands are 1, and 0 otherwise.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns an unsigned 32-bit integer representing the result of the bitwise AND\n/// operation.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::land\" {\n///   let a = 0xF0F0U // 1111_0000_1111_0000\n///   let b = 0xFF00U // 1111_1111_0000_0000\n///   inspect!(a & b, content=\"61440\") // 1111_0000_0000_0000 = 61440\n/// }\n/// ```\npub fn UInt::land(self : UInt, other : UInt) -> UInt = \"%u32.bitand\"\n\n///|\n/// Performs a bitwise OR operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if at least one of the corresponding bits\n/// in either operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise OR operation as an unsigned 32-bit integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::lor\" {\n///   let a = 0xF0F0U // Binary: 1111_0000_1111_0000\n///   let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n///   inspect!(a | b, content=\"65535\") // Binary: 1111_1111_1111_1111\n/// }\n/// ```\npub fn UInt::lor(self : UInt, other : UInt) -> UInt = \"%u32.bitor\"\n\n///|\n/// Performs a bitwise XOR (exclusive OR) operation between two unsigned 32-bit\n/// integers. Each bit in the result is set to 1 if the corresponding bits in the\n/// operands are different, and 0 if they are the same.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise XOR operation.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::lxor\" {\n///   let a = 0xFF00U // Binary: 1111_1111_0000_0000\n///   let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n///   inspect!(a ^ b, content=\"61455\") // Binary: 1111_0000_0000_1111\n/// }\n/// ```\npub fn UInt::lxor(self : UInt, other : UInt) -> UInt = \"%u32.bitxor\"\n\n///|\n/// Performs a bitwise NOT operation on an unsigned 32-bit integer. Flips all\n/// bits in the number (changes each 0 to 1 and each 1 to 0).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer value on which to perform the bitwise\n/// NOT operation.\n///\n/// Returns a new unsigned 32-bit integer where each bit is inverted from the\n/// input value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::lnot\" {\n///   let x = 0xFF00U // Binary: 1111_1111_0000_0000\n///   inspect!(x.lnot(), content=\"4294902015\") // Binary: ...0000_0000_1111_1111\n/// }\n/// ```\npub fn UInt::lnot(self : UInt) -> UInt = \"%u32.bitnot\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the number to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift the bits. Must be non-negative\n/// and less than 32. Values outside this range are wrapped to fit within it\n/// (i.e., `shift & 31`).\n///\n/// Returns a new `UInt` value representing the result of shifting the bits left\n/// by the specified number of positions. Each position shifted multiplies the\n/// number by 2.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::lsl\" {\n///   let x = 1U\n///   inspect!(x << 3, content=\"8\") // Using the recommended operator\n///   let y = 8U\n///   inspect!(y << 1, content=\"16\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::lsl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the integer to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift left. Must be between 0 and 31\n/// inclusive. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new `UInt` value containing the result of the left shift operation.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::shl\" {\n///   let x = 1U\n///   inspect!(x << 3, content=\"8\") // Binary: 1 -> 1000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::shl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift on an unsigned 32-bit integer. Each bit in the\n/// input value is shifted right by the specified number of positions, with zeros\n/// shifted in from the left. DEPRECATED: Use the `>>` operator instead.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value representing the result of the logical right shift\n/// operation.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::lsr\" {\n///   let x = 0xF0000000U\n///   inspect!(x >> 4, content=\"251658240\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::lsr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer by a\n/// specified number of positions. All bits shifted in from the left are zeros.\n///\n/// Parameters:\n///\n/// * `number` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value that represents the result of shifting all bits in\n/// `number` to the right by `shift` positions.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::shr\" {\n///   let x = 0xFF000000U\n///   inspect!(x >> 8, content=\"16711680\") // 0x00FF0000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::shr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Each bit in\n/// the integer is shifted left by the specified number of positions, and zeros\n/// are filled in from the right.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift. Only the least significant 5\n/// bits are used, effectively making the shift count always between 0 and 31.\n///\n/// Returns a new unsigned 32-bit integer that is the result of shifting `self`\n/// left by `shift` positions.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::op_shl\" {\n///   let x = 1U\n///   inspect!(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = 0xFFFFFFFFU\n///   inspect!(y << 16, content=\"4294901760\") // All bits after position 16 are discarded\n/// }\n/// ```\npub impl Shl for UInt with op_shl(self, shift) = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer. The\n/// operation shifts all bits to the right by a specified number of positions,\n/// filling the leftmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. If this value is\n/// negative, the behavior is undefined. Values larger than 31 are masked with `&\n/// 31`.\n///\n/// Returns a new unsigned 32-bit integer containing the result of the right\n/// shift operation.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::op_shr\" {\n///   let x = 0xFF000000U\n///   inspect!(x >> 8, content=\"16711680\") // 0x00FF0000\n///   inspect!(x >> 24, content=\"255\") // 0x000000FF\n/// }\n///\n/// test \"UInt::op_shr/large_shift\" {\n///   let x = 0xFF000000U\n///   inspect!(x >> 32, content=\"4278190080\") // Same as x >> 0 due to masking\n/// }\n/// ```\npub impl Shr for UInt with op_shr(self, shift) = \"%u32.shr\"\n\n///|\n/// Counts the number of leading zero bits in an unsigned 32-bit integer,\n/// starting from the most significant bit.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer whose leading zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros starting from the most significant\n/// bit. For a zero value, returns 32.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::clz\" {\n///   inspect!(0U.clz(), content=\"32\")\n///   inspect!(1U.clz(), content=\"31\")\n///   inspect!(0x80000000U.clz(), content=\"0\")\n/// }\n/// ```\npub fn UInt::clz(self : UInt) -> Int = \"%u32.clz\"\n\n///|\n/// Counts the number of trailing zero bits in an unsigned 32-bit integer,\n/// starting from the least significant bit. For a zero input, returns 32.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose trailing zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros at the least significant end of the\n/// binary representation. Returns 32 if the input is zero.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::ctz\" {\n///   let x = 24U // Binary: ...011000\n///   inspect!(x.ctz(), content=\"3\") // 3 trailing zeros\n///   let y = 0U\n///   inspect!(y.ctz(), content=\"32\") // All bits are zero\n/// }\n/// ```\npub fn UInt::ctz(self : UInt) -> Int = \"%u32.ctz\"\n\n///|\n/// Counts the number of 1 bits (population count) in the binary representation\n/// of an unsigned 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose bits are to be counted.\n///\n/// Returns an integer representing the count of set bits (1s) in the binary\n/// representation.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::popcnt\" {\n///   let x = 0xF0F0U // Binary: 1111 0000 1111 0000\n///   inspect!(x.popcnt(), content=\"8\") // Has 8 bits set to 1\n/// }\n/// ```\npub fn UInt::popcnt(self : UInt) -> Int = \"%u32.popcnt\"\n\n///|\n/// Converts an unsigned 32-bit integer to an unsigned 64-bit integer by\n/// zero-extending it. The resulting value preserves the original number's\n/// magnitude while using 64 bits to represent it.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer (`UInt`) to be converted.\n///\n/// Returns an unsigned 64-bit integer (`UInt64`) representing the same numerical\n/// value as the input.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::to_uint64\" {\n///   let n = 42U\n///   inspect!(n.to_uint64(), content=\"42\")\n///   let max = 4294967295U // Maximum value of UInt\n///   inspect!(max.to_uint64(), content=\"4294967295\")\n/// }\n/// ```\npub fn UInt::to_uint64(self : UInt) -> UInt64 {\n  UInt64::extend_uint(self)\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a byte by taking its least significant\n/// 8 bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::to_byte\" {\n///   let n = 258U // In binary: 100000010\n///   inspect!(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n///   let big = 4294967295U // Maximum value of UInt\n///   inspect!(big.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// }\n/// ```\npub fn UInt::to_byte(self : UInt) -> Byte {\n  self.reinterpret_as_int().to_byte()\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Double::convert_uint\" {\n///   let n = 42U\n///   inspect!(n.to_double(), content=\"42\")\n///   let max = 4294967295U // maximum value of UInt\n///   inspect!(max.to_double(), content=\"4294967295\")\n/// }\n/// ```\npub fn UInt::to_double(self : UInt) -> Double = \"%u32.to_f64\"\n\n///|\n/// Performs unary negation on a 32-bit floating-point number. Returns the\n/// arithmetic inverse of the operand.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to negate.\n///\n/// Returns a new floating-point number with the same magnitude but opposite sign\n/// as the input. Special cases:\n///\n/// * Negating NaN returns NaN\n/// * Negating +0.0 returns -0.0\n/// * Negating -0.0 returns +0.0\n/// * Negating +Infinity returns -Infinity\n/// * Negating -Infinity returns +Infinity\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Float::op_neg\" {\n///   let f = 3.14.to_float()\n///   inspect!((-f).to_double(), content=\"-3.140000104904175\")\n///   let zero = 0.0.to_float()\n///   inspect!((-zero).to_double(), content=\"0\")\n/// }\n/// ```\npub impl Neg for Float with op_neg(self) = \"%f32.neg\"\n\n///|\n/// Performs addition between two single-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point operand.\n/// * `other` : The second floating-point operand to be added to the first\n/// operand.\n///\n/// Returns a single-precision floating-point number representing the sum of the\n/// two operands.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Float::op_add\" {\n///   let a = 3.14.to_float()\n///   let b = 2.86.to_float()\n///   let sum = a + b\n///   inspect!(sum.to_double(), content=\"6\")\n/// }\n/// ```\npub impl Add for Float with op_add(self, other) = \"%f32.add\"\n\n///|\n/// Performs subtraction between two single-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number (minuend).\n/// * `other` : The second floating-point number (subtrahend).\n///\n/// Returns a new floating-point number representing the difference between\n/// `self` and `other`.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Float::op_sub\" {\n///   let x = 3.14.to_float()\n///   let y = 1.0.to_float()\n///   let result = x - y\n///   inspect!(result.to_double(), content=\"2.140000104904175\")\n/// }\n/// ```\npub impl Sub for Float with op_sub(self, other) = \"%f32.sub\"\n\n///|\n/// Performs multiplication between two single-precision floating-point numbers\n/// according to IEEE 754 rules.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number operand.\n/// * `other` : The second floating-point number operand to multiply with the\n/// first.\n///\n/// Returns a single-precision floating-point number that is the product of the\n/// two operands.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Float::op_mul\" {\n///   let x = Int::to_float(2)\n///   let y = Int::to_float(3)\n///   let z = x * y\n///   inspect!(z.to_double(), content=\"6\")\n/// }\n/// ```\npub impl Mul for Float with op_mul(self, other) = \"%f32.mul\"\n\n///|\n/// Performs division between two 32-bit floating-point numbers according to IEEE\n/// 754 rules.\n///\n/// Parameters:\n///\n/// * `self` : The dividend floating-point number.\n/// * `other` : The divisor floating-point number.\n///\n/// Returns a new floating-point number representing the quotient of the\n/// division. Special cases follow IEEE 754 rules:\n///\n/// * Division by zero returns infinity (with the appropriate sign)\n/// * Division of zero by zero returns NaN\n/// * Division of infinity by infinity returns NaN\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Float::op_div\" {\n///   let a = 6.0.to_float()\n///   let b = 2.0.to_float()\n///   let result = (a / b).to_double()\n///   inspect!(result, content=\"3\")\n///   inspect!((0.0.to_float() / 0.0.to_float()).to_double(), content=\"NaN\")\n/// }\n/// ```\npub impl Div for Float with op_div(self, other) = \"%f32.div\"\n\n///|\n/// Calculates the square root of a floating-point number. For non-negative\n/// numbers, returns the principal square root. For negative numbers or NaN,\n/// returns NaN.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number whose square root is to be calculated.\n///\n/// Returns a 32-bit floating-point number representing the square root of the\n/// input value:\n///\n/// * For a positive number, returns its principal square root\n/// * For zero (positive or negative), returns zero with the same sign\n/// * For NaN or negative numbers, returns NaN\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Float::sqrt\" {\n///   let x = 16.0.to_float()\n///   let root = x.sqrt()\n///   inspect!(root.to_double(), content=\"4\")\n///   let neg = (-4.0).to_float()\n///   let neg_root = neg.sqrt()\n///   inspect!(neg_root.to_double(), content=\"NaN\")\n/// }\n/// ```\npub fn Float::sqrt(self : Float) -> Float = \"%f32.sqrt\"\n\n///|\n/// Tests two floating-point numbers for equality. Follows IEEE 754 equality\n/// comparison rules, where NaN values are not equal to any value, including\n/// themselves.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n///\n/// Returns `true` if both numbers are equal, `false` otherwise. Note that `-0.0`\n/// and `+0.0` are considered equal.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Float::op_equal\" {\n///   let x = 3.14\n///   let y = 3.14\n///   let z = 0.0 / 0.0 // NaN\n///   inspect!(x == y, content=\"true\")\n///   inspect!(z == z, content=\"false\") // NaN is not equal to itself\n/// }\n/// ```\npub impl Eq for Float with op_equal(self : Float, other : Float) -> Bool = \"%f32.eq\"\n\n///|\n/// Tests if two single-precision floating-point numbers are not equal. This\n/// operation follows IEEE 754 rules for floating-point comparison, including\n/// special handling of NaN values.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n///\n/// Returns `true` if the two floating-point numbers are not equal, `false` if\n/// they are equal. Note that if either operand is NaN, the result is `true`.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Float::op_neq\" {\n///   let x = 1.0.to_float()\n///   let y = 2.0.to_float()\n///   let nan = (0.0 / 0.0).to_float()\n///   inspect!(x != y, content=\"true\")\n///   inspect!(x != x, content=\"false\")\n///   inspect!(nan != nan, content=\"true\") // NaN is not equal to itself\n/// }\n/// ```\npub fn Float::op_neq(self : Float, other : Float) -> Bool = \"%f32.ne\"\n\n///|\n/// Compares two 32-bit floating-point numbers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Float::compare\" {\n///   let a = 3.14\n///   let b = 2.718\n///   inspect!(a.compare(b), content=\"1\") // 3.14 > 2.718\n///   inspect!(b.compare(a), content=\"-1\") // 2.718 < 3.14\n///   inspect!(a.compare(a), content=\"0\") // 3.14 = 3.14\n/// }\n/// ```\npub impl Compare for Float with compare(self, other) = \"%f32.compare\"\n\n///|\n/// Converts a 32-bit floating-point number to a double-precision (64-bit)\n/// floating-point number.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit floating-point number to be converted.\n///\n/// Returns a double-precision floating-point number that preserves the exact\n/// value of the input. Since double-precision has more bits than\n/// single-precision, this conversion is always exact and never loses precision.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Float::to_double\" {\n///   let f = 3.14.to_float()\n///   inspect!(f.to_double(), content=\"3.140000104904175\")\n/// }\n/// ```\npub fn Float::to_double(self : Float) -> Double = \"%f32.to_f64\"\n\n///|\n/// Reinterprets the bits of a 32-bit floating-point number as a 32-bit signed\n/// integer without performing any numeric conversion. The bit pattern is\n/// preserved exactly, only the type interpretation changes.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit floating-point number whose bits are to be\n/// reinterpreted.\n///\n/// Returns a 32-bit signed integer that has the same bit pattern as the input\n/// floating-point number.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Float::reinterpret_as_int\" {\n///   let f = 1.0.to_float()\n///   // IEEE 754 representation of 1.0 is 0x3F800000\n///   inspect!(f.reinterpret_as_int(), content=\"1065353216\")\n/// }\n/// ```\npub fn Float::reinterpret_as_int(self : Float) -> Int = \"%f32.to_i32_reinterpret\"\n\n///|\n/// Reinterprets the bits of a 32-bit floating-point number as an unsigned 32-bit\n/// integer without performing any numeric conversion. Preserves the exact bit\n/// pattern of the input value, only changing how these bits are interpreted.\n///\n/// Parameters:\n///\n/// * `float` : The 32-bit floating-point number whose bits are to be\n/// reinterpreted.\n///\n/// Returns an unsigned 32-bit integer (`UInt`) that has the same bit pattern as\n/// the input floating-point number.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Float::reinterpret_as_uint\" {\n///   let x : Float = 1.0\n///   inspect!(x.reinterpret_as_uint(), content=\"1065353216\") // Decimal representation of 0x3F800000\n/// }\n/// ```\npub fn Float::reinterpret_as_uint(self : Float) -> UInt = \"%f32.to_i32_reinterpret\"\n\n///|\n/// Converts an integer to a 32-bit floating-point number. The conversion is\n/// exact for small integers, but may lose precision for large integers due to\n/// the limited precision of the floating-point format.\n///\n/// Parameters:\n///\n/// * `number` : The integer value to be converted to a floating-point number.\n///\n/// Returns a 32-bit floating-point number representing the same value as the\n/// input integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::to_float\" {\n///   let n = 42\n///   let f = n.to_float()\n///   // Convert back to double for comparison since Float doesn't implement Show\n///   inspect!(f.to_double(), content=\"42\")\n/// }\n/// ```\npub fn Int::to_float(self : Int) -> Float = \"%i32.to_f32\"\n\n///|\n/// Reinterprets the bits of a 32-bit integer as a single-precision\n/// floating-point number according to IEEE 754 standard. The bit pattern of the\n/// input is preserved, only the type interpretation changes.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer whose bits are to be reinterpreted as a\n/// single-precision floating-point number.\n///\n/// Returns a 32-bit floating-point number (`Float`) that has the same bit\n/// pattern as the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::reinterpret_as_float\" {\n///   // 0x3F800000 represents 1.0 in IEEE 754 single-precision format\n///   let n = 1065353216 // 0x3F800000\n///   inspect!(n.reinterpret_as_float().to_double(), content=\"1\")\n/// }\n/// ```\npub fn Int::reinterpret_as_float(self : Int) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n/// Reinterprets the bits of an unsigned 32-bit integer as a single-precision\n/// floating-point number (IEEE 754). The bit pattern is preserved exactly, only\n/// the type interpretation changes.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose bits are to be reinterpreted as\n/// a single-precision floating-point number.\n///\n/// Returns a single-precision floating-point number (`Float`) whose bit pattern\n/// is identical to the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::reinterpret_as_float\" {\n///   let n = 0x3F800000U // Bit pattern for 1.0f\n///   inspect!(n.reinterpret_as_float().to_double(), content=\"1\")\n/// }\n/// ```\npub fn UInt::reinterpret_as_float(self : UInt) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n/// Converts a byte value to a 32-bit floating-point number (IEEE 754\n/// single-precision format). The byte value is treated as an unsigned 8-bit\n/// integer during the conversion.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to a float.\n///\n/// Returns a 32-bit floating-point number representing the byte value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Byte::to_float\" {\n///   let b = b'\\xFF' // 255 in decimal\n///   let f = b.to_float()\n///   // Convert to double for comparison since Float doesn't implement Show\n///   inspect!(f.to_double(), content=\"255\")\n/// }\n/// ```\npub fn Byte::to_float(self : Byte) -> Float = \"%byte.to_f32\"\n\n///| TODO: use intrinsics implement this\npub fn Byte::to_double(self : Byte) -> Double {\n  self.to_int().to_double()\n}\n\n///|\n/// Converts a double-precision floating-point number to a single-precision\n/// floating-point number. The conversion may result in a loss of precision due\n/// to the reduced number of bits available in the single-precision format.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to be converted.\n///\n/// Returns a single-precision floating-point number that represents the closest\n/// possible value to the input double-precision number.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Double::to_float\" {\n///   let d = 3.14159265359\n///   inspect!(d.to_float().to_double(), content=\"3.1415927410125732\") // Note the loss of precision\n/// }\n/// ```\npub fn Double::to_float(self : Double) -> Float = \"%f64.to_f32\"\n\n///|\n/// Converts an unsigned 32-bit integer to a single-precision floating-point\n/// number. Due to the limited precision of the 32-bit floating-point format,\n/// values above 16777216 (2^24) may lose precision during conversion.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a 32-bit floating-point number that represents the same numerical\n/// value as the input unsigned integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::to_float\" {\n///   let n = 42U\n///   inspect!(n.to_float().to_double(), content=\"42\")\n///   let big = 16777216U // 2^24\n///   inspect!(big.to_float().to_double(), content=\"16777216\") // Last precisely representable integer\n/// }\n/// ```\npub fn UInt::to_float(self : UInt) -> Float = \"%u32.to_f32\"\n\n///|\n/// Converts a 16-bit signed integer to a 32-bit signed integer by sign\n/// extension.\n///\n/// Parameters:\n///\n/// * `value` : The 16-bit signed integer to be converted.\n///\n/// Returns a 32-bit signed integer that has the same value as the input.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int16::to_int\" {\n///   let n = Int::to_int16(42)\n///   inspect!(n.to_int(), content=\"42\")\n///   let neg = Int::to_int16(-42)\n///   inspect!(neg.to_int(), content=\"-42\")\n/// }\n/// ```\npub fn Int16::to_int(self : Int16) -> Int = \"%i16_to_i32\"\n\n///|\n/// Converts a 16-bit signed integer to a byte by truncating its value to fit\n/// within the byte range (0 to 255). Only the least significant 8 bits of the\n/// integer are retained.\n///\n/// Parameters:\n///\n/// * `value` : The 16-bit signed integer to be converted to a byte.\n///\n/// Returns a byte containing the least significant 8 bits of the input value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int16::to_byte\" {\n///   let x = Int::to_int16(258) // In binary: 0000_0001_0000_0010\n///   inspect!(x.to_byte(), content=\"b'\\\\x02'\") // Only keeps 0000_0010\n/// }\n/// ```\npub fn Int16::to_byte(self : Int16) -> Byte = \"%i16_to_byte\"\n\n///|\npub fn Int::to_int16(self : Int) -> Int16 = \"%i32_to_i16\"\n\n///|\n/// Converts a byte value to a 16-bit signed integer. The byte value is\n/// sign-extended to 16 bits during the conversion.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an `Int16`.\n///\n/// Returns a 16-bit signed integer representing the same value as the input\n/// byte.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Byte::to_int16\" {\n///   let b = b'\\xFF' // -1 as a signed byte\n///   inspect!(b.to_int16(), content=\"255\") // Sign is preserved\n///   let p = b'\\x7F' // 127 as a signed byte\n///   inspect!(p.to_int16(), content=\"127\")\n/// }\n/// ```\npub fn Byte::to_int16(self : Byte) -> Int16 = \"%byte_to_i16\"\n\n///|\n/// Converts an unsigned 16-bit integer to a 32-bit signed integer. The value is\n/// zero-extended to fill the higher bits.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 16-bit integer to be converted.\n///\n/// Returns a 32-bit signed integer. Since the input value is always non-negative\n/// and less than 65536, the conversion never results in overflow.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt16::to_int\" {\n///   let x = Int::to_uint16(42)\n///   inspect!(x.to_int(), content=\"42\")\n///   let max = Int::to_uint16(65535) // maximum value of UInt16\n///   inspect!(max.to_int(), content=\"65535\")\n/// }\n/// ```\npub fn UInt16::to_int(self : UInt16) -> Int = \"%u16_to_i32\"\n\n///|\n/// Converts a 16-bit unsigned integer to an 8-bit byte by truncating the higher\n/// bits.\n///\n/// Parameters:\n///\n/// * `value` : The 16-bit unsigned integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt16::to_byte\" {\n///   let x = Int::to_uint16(258) // Binary: 0000_0001_0000_0010\n///   inspect!(x.to_byte(), content=\"b'\\\\x02'\") // Only keeps 0000_0010\n/// }\n/// ```\npub fn UInt16::to_byte(self : UInt16) -> Byte = \"%u16_to_byte\"\n\n///|\n/// Converts a 32-bit signed integer to a 16-bit unsigned integer by truncating\n/// its value to fit within the range of 0 to 65535.\n///\n/// Parameters:\n///\n/// * `integer` : The 32-bit signed integer to be converted. Values outside the\n/// range of UInt16 will be truncated to fit.\n///\n/// Returns a 16-bit unsigned integer containing the lower 16 bits of the input\n/// value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::to_uint16\" {\n///   let n = 42\n///   inspect!(n.to_uint16(), content=\"42\")\n///   let neg = -1\n///   inspect!(neg.to_uint16(), content=\"65535\") // -1 becomes max value of UInt16\n///   let large = 65536\n///   inspect!(large.to_uint16(), content=\"0\") // Values wrap around\n/// }\n/// ```\npub fn Int::to_uint16(self : Int) -> UInt16 = \"%i32_to_u16\"\n\n///|\n/// Converts a byte value to a 16-bit unsigned integer by zero-extending it.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 16-bit unsigned integer (`UInt16`) representing the same value as\n/// the input byte.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Byte::to_uint16\" {\n///   let b = b'\\xFF' // byte with value 255\n///   inspect!(b.to_uint16(), content=\"255\")\n///   let zero = b'\\x00'\n///   inspect!(zero.to_uint16(), content=\"0\")\n/// }\n/// ```\npub fn Byte::to_uint16(self : Byte) -> UInt16 = \"%byte_to_u16\"\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst GPRIME1 : UInt = 0x9E3779B1\n\n///|\nconst GPRIMES2 : UInt = 0x85EBCA77\n\n///|\nconst GPRIME3 : UInt = 0xC2B2AE3D\n\n///|\nconst GPRIME4 : UInt = 0x27D4EB2F\n\n///|\nconst GPRIME5 : UInt = 0x165667B1\n\n///|\n/// Represents a hasher that implements the xxHash32 algorithm. The hasher\n/// maintains a mutable accumulator that is updated with each value added to the\n/// hash computation.\n///\n/// This struct provides methods for combining different types of values into a\n/// single hash value, making it suitable for implementing hash functions for\n/// custom types.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher/basic\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_int(42)\n///   hasher.combine_string(\"hello\")\n///   inspect!(hasher.finalize(), content=\"860601284\")\n/// }\n/// ```\nstruct Hasher {\n  mut acc : UInt\n}\n\n///|\n/// Creates a new hasher with an optional seed value.\n///\n/// Parameters:\n///\n/// * `seed` : An integer value used to initialize the hasher's internal state.\n/// Defaults to 0.\n///\n/// Returns a new `Hasher` instance initialized with the given seed value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::new\" {\n///   let h1 = Hasher::new() // Create a hasher with default seed\n///   let h2 = Hasher::new(seed=42) // Create a hasher with custom seed\n///   let x = 123\n///   h1.combine(x)\n///   h2.combine(x)\n///   inspect!(h1.finalize() != h2.finalize(), content=\"true\") // Different seeds produce different hashes\n/// }\n/// ```\npub fn Hasher::new(seed~ : Int = 0) -> Hasher {\n  { acc: seed.reinterpret_as_uint() + GPRIME5 }\n}\n\n///|\n/// Combines a hashable value with the current state of the hasher. This is\n/// typically used to incrementally build a hash value from multiple components.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The value to be combined with the current hash state. Must\n/// implement the `Hash` trait.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::combine\" {\n///   let hasher = Hasher::new()\n///   hasher.combine(42)\n///   hasher.combine(\"hello\")\n///   inspect!(hasher.finalize(), content=\"860601284\")\n/// }\n/// ```\npub fn Hasher::combine[T : Hash](self : Hasher, value : T) -> Unit {\n  value.hash_combine(self)\n}\n\n///|\n/// Combines the unit value (i.e., `()`) into the hasher's internal state by\n/// hashing it as an integer value of 0.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to combine the unit value into.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::combine_unit\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_unit()\n///   inspect!(hasher.finalize(), content=\"148298089\")\n/// }\n/// ```\npub fn Hasher::combine_unit(self : Hasher) -> Unit {\n  self.combine_uint(0)\n}\n\n///|\n/// Combines a boolean value into the current hash state. The boolean value is\n/// converted to an integer (1 for true, 0 for false) before being combined with\n/// the hash.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The boolean value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::combine_bool\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_bool(true)\n///   inspect!(hasher.finalize(), content=\"-205818221\")\n/// }\n/// ```\npub fn Hasher::combine_bool(self : Hasher, value : Bool) -> Unit {\n  self.combine_uint(if value { 1 } else { 0 })\n}\n\n///|\n/// Combines a 32-bit integer value into the hasher's internal state. The value\n/// is processed\n/// as a 4-byte sequence, and the internal accumulator is updated accordingly.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : A 32-bit integer value to be incorporated into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::combine_int\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_int(42)\n///   inspect!(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub fn Hasher::combine_int(self : Hasher, value : Int) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\n/// Combines a 64-bit integer value into the hash state by splitting it into two\n/// 32-bit parts and processing them separately. This method is used internally\n/// by the hash implementation to incorporate 64-bit integers into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object whose internal state will be updated.\n/// * `value` : The 64-bit integer value to be incorporated into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::combine_int64\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_int64(42L)\n///   inspect!(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub fn Hasher::combine_int64(self : Hasher, value : Int64) -> Unit {\n  self.acc += 8\n  self.consume4(value.reinterpret_as_uint64().to_uint())\n  self.consume4((value.reinterpret_as_uint64() >> 32).to_uint())\n}\n\n///|\n/// Combines an unsigned 32-bit integer into the hasher's internal state by\n/// reinterpreting it as a signed integer and incorporating it into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update.\n/// * `value` : The unsigned 32-bit integer value to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::combine_uint\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_uint(42U)\n///   inspect!(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub fn Hasher::combine_uint(self : Hasher, value : UInt) -> Unit {\n  self.acc += 4\n  self.consume4(value)\n}\n\n///|\n/// Combines a 64-bit unsigned integer into the hasher's internal state. Useful\n/// for hashing `UInt64` values as part of a larger composite structure.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The 64-bit unsigned integer value to be incorporated into the\n/// hash.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::combine_uint64\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_uint64(42UL)\n///   inspect!(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub fn Hasher::combine_uint64(self : Hasher, value : UInt64) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a double-precision floating-point number into the hasher's internal\n/// state by reinterpreting its bits as a 64-bit integer. Maintains consistent\n/// hashing behavior regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher to combine the value into.\n/// * `value` : The double-precision floating-point number to be combined into\n/// the hash.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::combine_double\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_double(3.14)\n///   inspect!(hasher.finalize(), content=\"-428265677\")\n/// }\n/// ```\npub fn Hasher::combine_double(self : Hasher, value : Double) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a 32-bit floating-point value into the hasher by reinterpreting its\n/// bit pattern as a 32-bit integer. The operation maintains the same hash result\n/// regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object that maintains the internal state of the\n/// hashing operation.\n/// * `value` : The 32-bit floating-point value to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::combine_float\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_float(3.14)\n///   inspect!(hasher.finalize(), content=\"635116317\") // Hash of the bits of 3.14\n/// }\n/// ```\npub fn Hasher::combine_float(self : Hasher, value : Float) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\n/// Combines a byte value into the hash state.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte value.\n/// * `byte` : The byte value to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::combine_byte\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_byte(b'\\xFF')\n///   inspect!(hasher.finalize(), content=\"1955036104\")\n/// }\n/// ```\npub fn Hasher::combine_byte(self : Hasher, value : Byte) -> Unit {\n  self.consume1(value)\n}\n\n///|\n/// Combines a byte sequence into the hasher's internal state using xxHash32\n/// algorithm. Processes the input bytes in chunks of 4 bytes for efficiency,\n/// with remaining bytes processed individually.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte sequence.\n/// * `bytes` : The byte sequence to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::combine_bytes\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_bytes(b\"\\xFF\\x00\\xFF\\x00\")\n///   inspect!(hasher.finalize(), content=\"-686861102\")\n/// }\n/// ```\npub fn Hasher::combine_bytes(self : Hasher, value : Bytes) -> Unit {\n  let mut remain = value.length()\n  let mut cur = 0\n  while remain >= 4 {\n    self.consume4(endian32(value, cur))\n    cur += 4\n    remain -= 4\n  }\n  while remain >= 1 {\n    self.consume1(value[cur])\n    cur += 1\n    remain -= 1\n  }\n}\n\n///|\n/// Combines a string value into the current hash state by processing each\n/// character in the string sequentially.\n///\n/// Parameters:\n///\n/// * `self` : The hasher object whose state will be updated.\n/// * `value` : The string value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::combine_string\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_string(\"hello\")\n///   inspect!(hasher.finalize(), content=\"-655549713\")\n/// }\n/// ```\npub fn Hasher::combine_string(self : Hasher, value : String) -> Unit {\n  for i in 0..<value.length() {\n    self.combine_uint(value.unsafe_charcode_at(i).reinterpret_as_uint())\n  }\n}\n\n///|\n/// Combines a character value into the hasher's internal state. The character is\n/// first converted to its Unicode code point (as an integer) before being\n/// combined.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The character value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::combine_char\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_char('A')\n///   inspect!(hasher.finalize(), content=\"-1625495534\")\n/// }\n/// ```\npub fn Hasher::combine_char(self : Hasher, value : Char) -> Unit {\n  self.combine_uint(value.to_uint())\n}\n\n///|\n/// Finalizes the hashing process and returns the computed hash value. Applies an\n/// avalanche function to improve the distribution of the hash value.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object containing the accumulated hash state.\n///\n/// Returns a 32-bit integer representing the final hash value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Hasher::finalize\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_byte(b'\\xFF')\n///   inspect!(hasher.finalize(), content=\"1955036104\")\n/// }\n/// ```\npub fn Hasher::finalize(self : Hasher) -> Int {\n  self.avalanche().reinterpret_as_int()\n}\n\n///|\nfn Hasher::avalanche(self : Hasher) -> UInt {\n  let mut acc = self.acc\n  acc = acc ^ (acc >> 15)\n  acc *= GPRIMES2\n  acc = acc ^ (acc >> 13)\n  acc *= GPRIME3\n  acc = acc ^ (acc >> 16)\n  acc\n}\n\n///|\nfn Hasher::consume4(self : Hasher, input : UInt) -> Unit {\n  self.acc = rotl(self.acc + input * GPRIME3, 17) * GPRIME4\n}\n\n///|\nfn Hasher::consume1(self : Hasher, input : Byte) -> Unit {\n  self.acc = rotl(self.acc + input.to_uint() * GPRIME5, 11) * GPRIME1\n}\n\n///|\nfn rotl(x : UInt, r : Int) -> UInt {\n  (x << r) | (x >> (32 - r))\n}\n\n///|\nfn endian32(input : Bytes, cur : Int) -> UInt {\n  input[cur + 0].to_uint() |\n  (\n    (input[cur + 1].to_uint() << 8) |\n    (input[cur + 2].to_uint() << 16) |\n    (input[cur + 3].to_uint() << 24)\n  )\n}\n\n///|\n/// Implements the `Hash` trait for `String` type, providing a method to combine\n/// a string's hash value with a hasher's state.\n///\n/// Parameters:\n///\n/// * `self` : The string value to be hashed.\n/// * `hasher` : The hasher object that will be updated with the string's hash\n/// value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"String::hash\" {\n///   let s1 = \"hello\"\n///   let s2 = \"hello\"\n///   let s3 = \"world\"\n///   inspect!(Hash::hash(s1) == Hash::hash(s2), content=\"true\")\n///   inspect!(Hash::hash(s1) == Hash::hash(s3), content=\"false\")\n/// }\n/// ```\npub impl Hash for String with hash_combine(self, hasher) {\n  hasher.combine_string(self)\n}\n\n///|\n/// Implements the `Hash` trait for integer values using a combination of shifts\n/// and multiplications to produce a well-distributed hash value. Based on the\n/// hash algorithm from hash-prospector\n/// (https://github.com/skeeto/hash-prospector).\n///\n/// Parameters:\n///\n/// * `integer` : The integer value to be hashed. The value will be reinterpreted\n/// as an unsigned integer before hashing to ensure consistent behavior across\n/// positive and negative values.\n///\n/// Returns a 32-bit hash value derived from the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::hash\" {\n///   let x = 42\n///   inspect!(Hash::hash(x), content=\"-1704501356\")\n///   let y = -42\n///   inspect!(Hash::hash(y), content=\"1617647962\")\n/// }\n/// ```\n/// TODO: This implementation is **different** from the default implementation of the hash trait. \n/// So it will be replaced with the default implementation in the future **(breaking change)**, \n/// and users should not rely on this particular hash value\n/// ```moonbit \n/// test {\n///   let x = 42\n///   assert_not_eq!(Hash::hash(x),Hasher::new()..combine(x).finalize())\n/// }\n/// ```\npub impl Hash for Int with hash(self) {\n  let self = self.reinterpret_as_uint()\n  let mut x = self ^ (self >> 17)\n  x = x * 0xed5ad4bb\n  x = x ^ (x >> 11)\n  x = x * 0xac4c1b51\n  x = x ^ (x >> 15)\n  x = x * 0x31848bab\n  x = x ^ (x >> 14)\n  x.reinterpret_as_int()\n}\n\n///|\n/// Implements hash combination for integers by combining the integer value with\n/// a hasher. This implementation ensures that integers can be used as keys in\n/// hash-based collections like hash maps and hash sets.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be hashed.\n/// * `hasher` : A `Hasher` object that accumulates the hash value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Int::hash_combine\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_int(42)\n///   inspect!(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub impl Hash for Int with hash_combine(self, hasher) {\n  hasher.combine_int(self)\n}\n\n///|\n/// Combines the hash value of an unsigned integer with a hasher object. This is\n/// useful when you need to hash a data structure that contains unsigned\n/// integers.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned integer to be combined with the hasher.\n/// * `hasher` : The hasher object that will incorporate the hash value of the\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt::hash_combine\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_uint(42U)\n///   inspect!(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub impl Hash for UInt with hash_combine(self, hasher) {\n  hasher.combine_uint(self)\n}\n\n///|\n/// Implements the `Hash` trait for `UInt64` by combining the hash value of an\n/// unsigned 64-bit integer into a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer value to be hashed.\n/// * `hasher` : The hasher object used to compute the combined hash value.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"UInt64::hash_combine\" {\n///   let hasher = Hasher::new()\n///   hasher.combine_uint64(42UL)\n///   inspect!(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub impl Hash for UInt64 with hash_combine(self, hasher) {\n  hasher.combine_uint64(self)\n}\n\n///|\n/// Implements the `Hash` trait for `Option` types, allowing them to be used as\n/// keys in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Option` value to be hashed.\n/// * `hasher` : The hasher object that accumulates the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Option::hash_combine\" {\n///   let hasher = Hasher::new()\n///   let some_value : Int? = Some(42)\n///   let none_value : Int? = None\n///   hasher.combine(some_value)\n///   inspect!(hasher.finalize(), content=\"2103260413\")\n///   let hasher2 = Hasher::new()\n///   hasher2.combine(none_value)\n///   inspect!(hasher2.finalize(), content=\"148298089\")\n/// }\n/// ```\npub impl[X : Hash] Hash for X? with hash_combine(self, hasher) {\n  match self {\n    None => hasher.combine_int(0)\n    Some(x) => hasher..combine_int(1).combine(x)\n  }\n}\n\n///|\n/// Implements the `Hash` trait for `Result` type, allowing `Result` values to be\n/// used in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Result` value to be hashed.\n/// * `hasher` : The hasher object to which the hash value will be combined.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Result::hash_combine\" {\n///   let hasher = Hasher::new()\n///   let ok_result : Result[Int, String] = Ok(42)\n///   let err_result : Result[Int, String] = Err(\"error\")\n///   hasher.combine(ok_result)\n///   inspect!(hasher.finalize(), content=\"-1948635851\")\n///   let hasher = Hasher::new()\n///   hasher.combine(err_result)\n///   inspect!(hasher.finalize(), content=\"1953766574\")\n/// }\n/// ```\npub impl[T : Hash, E : Hash] Hash for Result[T, E] with hash_combine(\n  self,\n  hasher\n) {\n  match self {\n    Ok(x) => hasher..combine_int(0).combine(x)\n    Err(x) => hasher..combine_int(1).combine(x)\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\ntype StringBuilder Ref[String]\n\n///|\npub fn StringBuilder::new(size_hint~ : Int = 0) -> StringBuilder {\n  ignore(size_hint)\n  { val: \"\" }\n}\n\n///|\n/// Return whether the given buffer is empty.\npub fn StringBuilder::is_empty(self : StringBuilder) -> Bool {\n  self.val == \"\"\n}\n\n///|\n/// Writes a string to the StringBuilder.\npub impl Logger for StringBuilder with write_string(self, str) {\n  self.val += str\n}\n\n///|\n/// Writes a character to the StringBuilder.\npub impl Logger for StringBuilder with write_char(self, ch) {\n  self.val += Char::to_string(ch)\n}\n\n///|\n/// Writes a part of the given string to the StringBuilder.\n/// \n/// Parameters:\n///\n/// * `self` : The StringBuilder to write to.\n/// * `str` : The given string.\n/// * `start` : The start index of the substring to write.\n/// * `len` : The length of the substring to write.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"write_substring\" {\n///   let sb = StringBuilder::new()\n///   sb.write_substring(\"Hello, world!\", 0, 5)\n///   assert_eq!(sb.to_string(), \"Hello\")\n/// }\n/// ```\npub impl Logger for StringBuilder with write_substring(\n  self : StringBuilder,\n  str : String,\n  start : Int,\n  len : Int\n) -> Unit {\n  self.val += str.substring(start~, end=start + len)\n}\n\n///|\npub impl Show for StringBuilder with output(self, logger) {\n  logger.write_string(self.val)\n}\n\n///| \n/// Returns the current content of the StringBuilder as a string.\npub fn StringBuilder::to_string(self : StringBuilder) -> String {\n  self.val\n}\n\n///| \n/// Resets the string builder to an empty state.\npub fn StringBuilder::reset(self : StringBuilder) -> Unit {\n  self.val = \"\"\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a generic test failure type used primarily in test assertions and\n/// validations.\n///\n/// Since this is a type definition using `type!` syntax, it creates an error\n/// type `Failure` that wraps a `String` value containing the failure message.\n///\n/// Parameters:\n///\n/// * `message` : A string describing the nature of the failure.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Failure\" {\n///   let err : Failure = Failure(\"Test assertion failed\")\n///   match err {\n///     Failure(msg) => inspect!(msg, content=\"Test assertion failed\")\n///   }\n/// }\n/// ```\npub(all) type! Failure String\n\n///|\n/// Raises a `Failure` error with a given message and source location.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be included in the\n/// failure.\n/// * `location` : The source code location where the failure occurred.\n/// Automatically provided by the compiler when not specified.\n///\n/// Returns a value of type `T` wrapped in a `Failure` error type.\n///\n/// Throws an error of type `Failure` with a message that includes both the\n/// source location and the provided error message.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"panic fail\" {\n///   fail!(\"Something went wrong\")\n/// }\n/// ```\npub fn fail[T](msg : String, loc~ : SourceLoc = _) -> T!Failure {\n  raise Failure(\"FAILED: \\{loc} \\{msg}\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n#coverage.skip\npub fn op_lt[T : Compare](self_ : T, other : T) -> Bool {\n  self_.compare(other).is_neg()\n}\n\n///|\n#coverage.skip\npub fn op_gt[T : Compare](self_ : T, other : T) -> Bool {\n  self_.compare(other).is_pos()\n}\n\n///|\n#coverage.skip\npub fn op_le[T : Compare](self_ : T, other : T) -> Bool {\n  self_.compare(other).is_non_pos()\n}\n\n///|\n#coverage.skip\npub fn op_ge[T : Compare](self_ : T, other : T) -> Bool {\n  self_.compare(other).is_non_neg()\n}\n\n///|\n#coverage.skip\npub fn op_notequal[T : Eq](x : T, y : T) -> Bool {\n  not(x == y)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n//region MyInt64\npriv struct MyInt64 {\n  hi : Int\n  lo : Int\n}\n\n///|\nfn MyInt64::to_int64(self : MyInt64) -> Int64 = \"%identity\"\n\n///|\nfn MyInt64::from_int64(value : Int64) -> MyInt64 = \"%identity\"\n\n///|\nimpl Neg for MyInt64 with op_neg(self : MyInt64) -> MyInt64 {\n  if self.lo == 0 {\n    { hi: self.hi.lnot() + 1, lo: 0 }\n  } else {\n    { hi: self.hi.lnot(), lo: self.lo.lnot() + 1 }\n  }\n}\n\n///|\nfn MyInt64::add_hi_lo(self : MyInt64, bhi : Int, blo : Int) -> MyInt64 {\n  let { hi: ahi, lo: alo } = self\n  let lo = alo + blo\n  let s = lo >> 31\n  let as_ = alo >> 31\n  let bs = blo >> 31\n  let c = ((as_ & bs) | (s.lnot() & (as_ ^ bs))) & 1\n  let hi = ahi + bhi + c\n  { hi, lo }\n}\n\n///|\nimpl Add for MyInt64 with op_add(self : MyInt64, other : MyInt64) -> MyInt64 {\n  self.add_hi_lo(other.hi, other.lo)\n}\n\n///|\nimpl Sub for MyInt64 with op_sub(self : MyInt64, other : MyInt64) -> MyInt64 {\n  if other.lo == 0 {\n    { hi: self.hi - other.hi, lo: self.lo }\n  } else {\n    self.add_hi_lo(other.hi.lnot(), other.lo.lnot() + 1)\n  }\n}\n\n///|\nimpl Mul for MyInt64 with op_mul(self : MyInt64, other : MyInt64) -> MyInt64 {\n  let { hi: ahi, lo: alo } = self\n  let { hi: bhi, lo: blo } = other\n  let ahi = ahi.reinterpret_as_uint()\n  let alo = alo.reinterpret_as_uint()\n  let bhi = bhi.reinterpret_as_uint()\n  let blo = blo.reinterpret_as_uint()\n  let a48 = ahi >> 16\n  let a32 = ahi & 0xffff\n  let a16 = alo >> 16\n  let a00 = alo & 0xffff\n  let b48 = bhi >> 16\n  let b32 = bhi & 0xffff\n  let b16 = blo >> 16\n  let b00 = blo & 0xffff\n  let c00 = a00 * b00\n  let c16 = c00 >> 16\n  let c00 = c00 & 0xffff\n  let c16 = c16 + a16 * b00\n  let c32 = c16 >> 16\n  let c16 = c16 & 0xffff\n  let c16 = c16 + a00 * b16\n  let c32 = c32 + (c16 >> 16)\n  let c16 = c16 & 0xffff\n  let c32 = c32 + a32 * b00\n  let c48 = c32 >> 16\n  let c32 = c32 & 0xffff\n  let c32 = c32 + a16 * b16\n  let c48 = c48 + (c32 >> 16)\n  let c32 = c32 & 0xffff\n  let c32 = c32 + a00 * b32\n  let c48 = c48 + (c32 >> 16)\n  let c32 = c32 & 0xffff\n  let c48 = c48 + a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48\n  let c48 = c48 & 0xffff\n  {\n    hi: ((c48 << 16) | c32).reinterpret_as_int(),\n    lo: ((c16 << 16) | c00).reinterpret_as_int(),\n  }\n}\n\n///|\npriv struct Int64WasmHelper {\n  div_s : (Int, Int, Int, Int) -> Int\n  div_u : (Int, Int, Int, Int) -> Int\n  rem_s : (Int, Int, Int, Int) -> Int\n  rem_u : (Int, Int, Int, Int) -> Int\n  get_high : () -> Int\n}\n\n///|\nextern \"js\" fn get_int64_wasm_helper() -> Int64WasmHelper =\n  #|function f() {\n  #|  if (f._exports) return f._exports;\n  #|  return f._exports = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n  #|}\n\n///|\nimpl Div for MyInt64 with op_div(self : MyInt64, other : MyInt64) -> MyInt64 {\n  let exports = get_int64_wasm_helper()\n  let { hi: ahi, lo: alo } = self\n  let { hi: bhi, lo: blo } = other\n  let lo = (exports.div_s)(alo, ahi, blo, bhi)\n  let hi = (exports.get_high)()\n  { hi, lo }\n}\n\n///|\nfn MyInt64::div_u(self : MyInt64, other : MyInt64) -> MyInt64 {\n  let exports = get_int64_wasm_helper()\n  let { hi: ahi, lo: alo } = self\n  let { hi: bhi, lo: blo } = other\n  let lo = (exports.div_u)(alo, ahi, blo, bhi)\n  let hi = (exports.get_high)()\n  { hi, lo }\n}\n\n///|\nimpl Mod for MyInt64 with op_mod(self : MyInt64, other : MyInt64) -> MyInt64 {\n  let exports = get_int64_wasm_helper()\n  let { hi: ahi, lo: alo } = self\n  let { hi: bhi, lo: blo } = other\n  let lo = (exports.rem_s)(alo, ahi, blo, bhi)\n  let hi = (exports.get_high)()\n  { hi, lo }\n}\n\n///|\nfn MyInt64::mod_u(self : MyInt64, other : MyInt64) -> MyInt64 {\n  let exports = get_int64_wasm_helper()\n  let { hi: ahi, lo: alo } = self\n  let { hi: bhi, lo: blo } = other\n  let lo = (exports.rem_u)(alo, ahi, blo, bhi)\n  let hi = (exports.get_high)()\n  { hi, lo }\n}\n\n///|\nfn MyInt64::lnot(self : MyInt64) -> MyInt64 {\n  { hi: self.hi.lnot(), lo: self.lo.lnot() }\n}\n\n///|\nfn MyInt64::land(self : MyInt64, other : MyInt64) -> MyInt64 {\n  { hi: self.hi & other.hi, lo: self.lo & other.lo }\n}\n\n///|\nfn MyInt64::lor(self : MyInt64, other : MyInt64) -> MyInt64 {\n  { hi: self.hi | other.hi, lo: self.lo | other.lo }\n}\n\n///|\nfn MyInt64::lxor(self : MyInt64, other : MyInt64) -> MyInt64 {\n  { hi: self.hi ^ other.hi, lo: self.lo ^ other.lo }\n}\n\n///|\nfn MyInt64::lsl(self : MyInt64, shift : Int) -> MyInt64 {\n  let shift = shift & 63\n  if shift == 0 {\n    self\n  } else if shift < 32 {\n    let { hi, lo } = self\n    let hi = hi.reinterpret_as_uint()\n    let lo = lo.reinterpret_as_uint()\n    let hi = (hi << shift) | (lo >> (32 - shift))\n    let lo = lo << shift\n    { hi: hi.reinterpret_as_int(), lo: lo.reinterpret_as_int() }\n  } else {\n    { hi: self.lo << (shift - 32), lo: 0 }\n  }\n}\n\n///|\nfn MyInt64::lsr(self : MyInt64, shift : Int) -> MyInt64 {\n  let shift = shift & 63\n  if shift == 0 {\n    self\n  } else if shift < 32 {\n    {\n      hi: (self.hi.reinterpret_as_uint() >> shift).reinterpret_as_int(),\n      lo: (self.lo.reinterpret_as_uint() >> shift).reinterpret_as_int() |\n      (self.hi << (32 - shift)),\n    }\n  } else {\n    {\n      hi: 0,\n      lo: (self.hi.reinterpret_as_uint() >> (shift - 32)).reinterpret_as_int(),\n    }\n  }\n}\n\n///|\nfn MyInt64::asr(self : MyInt64, shift : Int) -> MyInt64 {\n  let shift = shift & 63\n  if shift == 0 {\n    self\n  } else if shift < 32 {\n    {\n      hi: self.hi >> shift,\n      lo: (self.lo.reinterpret_as_uint() >> shift).reinterpret_as_int() |\n      (self.hi << (32 - shift)),\n    }\n  } else {\n    { hi: self.hi >> 31, lo: self.hi >> (shift - 32) }\n  }\n}\n\n///|\nfn MyInt64::clz(self : MyInt64) -> Int {\n  if self.hi != 0 {\n    self.hi.clz()\n  } else {\n    32 + self.lo.clz()\n  }\n}\n\n///|\nfn MyInt64::ctz(self : MyInt64) -> Int {\n  if self.lo != 0 {\n    self.lo.ctz()\n  } else {\n    32 + self.hi.ctz()\n  }\n}\n\n///|\nfn MyInt64::popcnt(self : MyInt64) -> Int {\n  self.hi.popcnt() + self.lo.popcnt()\n}\n\n///|\nimpl Eq for MyInt64 with op_equal(self : MyInt64, other : MyInt64) -> Bool {\n  self.hi == other.hi && self.lo == other.lo\n}\n\n// a.lsr(0) is compiled to `(a >>> 0 | 0)` in JavaScript\n// so we can't use moonbit to generate the code\n\n///|\nextern \"js\" fn MyInt64::compare(self : MyInt64, other : MyInt64) -> Int =\n  #|(a, b) => {\n  #|  const ahi = a.hi;\n  #|  const bhi = b.hi;\n  #|  if (ahi < bhi) {\n  #|    return -1;\n  #|  }\n  #|  if (ahi > bhi) {\n  #|    return 1;\n  #|  }\n  #|  const alo = a.lo >>> 0;\n  #|  const blo = b.lo >>> 0;\n  #|  if (alo < blo) {\n  #|    return -1;\n  #|  }\n  #|  if (alo > blo) {\n  #|    return 1;\n  #|  }\n  #|  return 0;\n  #|}\n\n///|\nextern \"js\" fn MyInt64::compare_u(self : MyInt64, other : MyInt64) -> Int =\n  #|(a, b) => {\n  #|  const ahi = a.hi >>> 0;\n  #|  const bhi = b.hi >>> 0;\n  #|  if (ahi < bhi) {\n  #|    return -1;\n  #|  }\n  #|  if (ahi > bhi) {\n  #|    return 1;\n  #|  }\n  #|  const alo = a.lo >>> 0;\n  #|  const blo = b.lo >>> 0;\n  #|  if (alo < blo) {\n  #|    return -1;\n  #|  }\n  #|  if (alo > blo) {\n  #|    return 1;\n  #|  }\n  #|  return 0;\n  #|}\n\n///|\nfn MyInt64::from_int(value : Int) -> MyInt64 {\n  { hi: (value >> 31) & -1, lo: value | 0 }\n}\n\n///|\nfn MyInt64::to_int(self : MyInt64) -> Int {\n  self.lo\n}\n\n///|\nfn MyInt64::to_uint(self : MyInt64) -> UInt {\n  self.lo.reinterpret_as_uint()\n}\n\n///|\nextern \"js\" fn MyInt64::to_double(self : MyInt64) -> Double =\n  #|(a) => a.hi * 4294967296.0 + (a.lo >>> 0)\n\n///|\nfn MyInt64::extend_i32_u(value : Int) -> MyInt64 {\n  { hi: 0, lo: value }\n}\n\n///|\nextern \"js\" fn MyInt64::reinterpret_as_double(self : MyInt64) -> Double =\n  #|function f(a) {\n  #|  let view = f._view;\n  #|  if (view === undefined) {\n  #|    view = f._view = new DataView(new ArrayBuffer(8));\n  #|  }\n  #|  view.setUint32(0, a.hi);\n  #|  view.setUint32(4, a.lo);\n  #|  return view.getFloat64(0);\n  #|}\n\n///|\nextern \"js\" fn MyInt64::reinterpret_double(value : Double) -> MyInt64 =\n  #|function f(a) {\n  #|  let view = f._view;\n  #|  if (view === undefined) {\n  #|    view = f._view = new DataView(new ArrayBuffer(8));\n  #|  }\n  #|  view.setFloat64(0, a);\n  #|  const hi = view.getInt32(0);\n  #|  const lo = view.getInt32(4);\n  #|  return { hi, lo };\n  #|}\n\n///|\nextern \"js\" fn MyInt64::trunc_double_u(value : Double) -> MyInt64 =\n  #|(a) => {\n  #|  let hi = (a * (1 / 0x100000000)) | 0;\n  #|  let lo = a >>> 0;\n  #|  return { hi, lo };\n  #|}\n\n///|\nextern \"js\" fn MyInt64::convert_to_double_u(self : MyInt64) -> Double =\n  #|(a) => (a.hi >>> 0) * 4294967296.0 + (a.lo >>> 0)\n\n///|\nextern \"js\" fn MyInt64::convert_to_double(self : MyInt64) -> Double =\n  #|(a) => a.hi * 4294967296.0 + (a.lo >>> 0)\n//endregion\n\n///|\npub impl Neg for Int64 with op_neg(self : Int64) -> Int64 {\n  (-MyInt64::from_int64(self)).to_int64()\n}\n\n///|\npub impl Add for Int64 with op_add(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).op_add(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub impl Sub for Int64 with op_sub(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).op_sub(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub impl Mul for Int64 with op_mul(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).op_mul(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub impl Div for Int64 with op_div(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).op_div(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub impl Mod for Int64 with op_mod(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).op_mod(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub fn Int64::lnot(self : Int64) -> Int64 {\n  MyInt64::from_int64(self).lnot().to_int64()\n}\n\n///|\npub impl BitAnd for Int64 with land(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).land(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub impl BitOr for Int64 with lor(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).lor(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub impl BitXOr for Int64 with lxor(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).lxor(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int64::lsl(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).lsl(other).to_int64()\n}\n\n///|\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int64::shl(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).lsl(other).to_int64()\n}\n\n///|\n#deprecated(\"Use UInt64 type and infix operator `>>` instead\")\n#coverage.skip\npub fn Int64::lsr(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).lsr(other).to_int64()\n}\n\n///|\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int64::shr(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).asr(other).to_int64()\n}\n\n///|\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int64::asr(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).asr(other).to_int64()\n}\n\n///|\npub impl Shr for Int64 with op_shr(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).asr(other).to_int64()\n}\n\n///|\npub impl Shl for Int64 with op_shl(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).lsl(other).to_int64()\n}\n\n///|\npub fn Int64::ctz(self : Int64) -> Int {\n  MyInt64::from_int64(self).ctz()\n}\n\n///|\npub fn Int64::clz(self : Int64) -> Int {\n  MyInt64::from_int64(self).clz()\n}\n\n///|\npub fn Int64::popcnt(self : Int64) -> Int {\n  MyInt64::from_int64(self).popcnt()\n}\n\n///|\npub impl Eq for Int64 with op_equal(self : Int64, other : Int64) -> Bool {\n  MyInt64::from_int64(self) == MyInt64::from_int64(other)\n}\n\n///|\npub impl Compare for Int64 with compare(self : Int64, other : Int64) -> Int {\n  MyInt64::compare(MyInt64::from_int64(self), MyInt64::from_int64(other))\n}\n\n///|\npub impl Default for Int64 with default() {\n  0L\n}\n\n///|\npub fn Int64::to_int(self : Int64) -> Int {\n  MyInt64::from_int64(self).to_int()\n}\n\n///|\nfn Int64::to_uint(self : Int64) -> UInt {\n  MyInt64::from_int64(self).to_uint()\n}\n\n///|\npub fn Int64::to_double(self : Int64) -> Double {\n  Double::convert_int64(self)\n}\n\n///|\npub fn Int64::to_byte(self : Int64) -> Byte {\n  MyInt64::from_int64(self).to_int().to_byte()\n}\n\n///|\npub fn Int64::to_int16(self : Int64) -> Int16 {\n  MyInt64::from_int64(self).to_int().to_int16()\n}\n\n///|\npub fn Int64::to_uint16(self : Int64) -> UInt16 {\n  MyInt64::from_int64(self).to_int().to_uint16()\n}\n\n///|\npub fn UInt64::extend_uint(value : UInt) -> UInt64 {\n  MyInt64::extend_i32_u(value.reinterpret_as_int()).to_uint64()\n}\n\n///|\npub fn Int64::reinterpret_as_double(self : Int64) -> Double {\n  MyInt64::reinterpret_as_double(MyInt64::from_int64(self))\n}\n\n///|\npub fn UInt64::reinterpret_as_double(self : UInt64) -> Double {\n  MyInt64::reinterpret_as_double(MyInt64::from_uint64(self))\n}\n\n///|\npub fn Int::to_int64(self : Int) -> Int64 {\n  MyInt64::from_int(self).to_int64()\n}\n\n///|\npub fn Int16::to_int64(self : Int16) -> Int64 {\n  MyInt64::from_int(self.to_int()).to_int64()\n}\n\n///|\npub fn UInt16::to_int64(self : UInt16) -> Int64 {\n  MyInt64::from_int(self.to_int()).to_int64()\n}\n\n///|\n#deprecated(\"Use `reinterpret_as_int64` instead\")\n#coverage.skip\npub fn Double::reinterpret_as_i64(self : Double) -> Int64 {\n  MyInt64::reinterpret_double(self).to_int64()\n}\n\n///|\npub fn Double::reinterpret_as_int64(self : Double) -> Int64 {\n  MyInt64::reinterpret_double(self).to_int64()\n}\n\n///|\n#deprecated(\"Use `reinterpret_as_uint64` instead\")\n#coverage.skip\npub fn Double::reinterpret_as_u64(self : Double) -> UInt64 {\n  MyInt64::reinterpret_double(self).to_uint64()\n}\n\n///|\npub fn Double::reinterpret_as_uint64(self : Double) -> UInt64 {\n  MyInt64::reinterpret_double(self).to_uint64()\n}\n\n///|\npub fn Double::convert_uint64(value : UInt64) -> Double {\n  MyInt64::convert_to_double_u(MyInt64::from_uint64(value))\n}\n\n///|\nfn Double::convert_int64(value : Int64) -> Double {\n  MyInt64::convert_to_double(MyInt64::from_int64(value))\n}\n\n///|\nfn MyInt64::to_uint64(self : MyInt64) -> UInt64 = \"%identity\"\n\n///|\nfn MyInt64::from_uint64(value : UInt64) -> MyInt64 = \"%identity\"\n\n///|\n#deprecated(\"Use `reinterpret_as_uint64` instead\")\n#coverage.skip\npub fn Int64::to_uint64(self : Int64) -> UInt64 = \"%identity\"\n\n///|\npub fn Int64::reinterpret_as_uint64(self : Int64) -> UInt64 = \"%identity\"\n\n///|\npub impl Add for UInt64 with op_add(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::from_uint64(self).op_add(MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub impl Sub for UInt64 with op_sub(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::from_uint64(self).op_sub(MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub impl Mul for UInt64 with op_mul(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::from_uint64(self).op_mul(MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub impl Div for UInt64 with op_div(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::from_uint64(self).div_u(MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub impl Mod for UInt64 with op_mod(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::from_uint64(self).mod_u(MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\n#deprecated(\"Use reinterpret_as_int64 instead\")\n#coverage.skip\npub fn UInt64::to_int64(self : UInt64) -> Int64 = \"%identity\"\n\n///|\npub fn UInt64::reinterpret_as_int64(self : UInt64) -> Int64 = \"%identity\"\n\n///|\npub fn UInt64::to_uint(self : UInt64) -> UInt {\n  MyInt64::from_uint64(self).to_uint()\n}\n\n///|\npub fn UInt64::to_int(self : UInt64) -> Int {\n  MyInt64::from_uint64(self).to_int()\n}\n\n///|\npub fn UInt64::to_double(self : UInt64) -> Double {\n  Double::convert_uint64(self)\n}\n\n///|\npub impl Compare for UInt64 with compare(self : UInt64, other : UInt64) -> Int {\n  MyInt64::from_uint64(self).compare_u(MyInt64::from_uint64(other))\n}\n\n///|\npub impl Eq for UInt64 with op_equal(self : UInt64, other : UInt64) -> Bool {\n  MyInt64::from_uint64(self).op_equal(MyInt64::from_uint64(other))\n}\n\n///|\npub fn UInt64::trunc_double(value : Double) -> UInt64 {\n  MyInt64::trunc_double_u(value).to_uint64()\n}\n\n///|\npub impl BitAnd for UInt64 with land(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::land(MyInt64::from_uint64(self), MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub impl BitOr for UInt64 with lor(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::lor(MyInt64::from_uint64(self), MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub impl BitXOr for UInt64 with lxor(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::lxor(MyInt64::from_uint64(self), MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub fn UInt64::lnot(self : UInt64) -> UInt64 {\n  MyInt64::lnot(MyInt64::from_uint64(self)).to_uint64()\n}\n\n///|\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt64::lsl(self : UInt64, shift : Int) -> UInt64 {\n  MyInt64::lsl(MyInt64::from_uint64(self), shift).to_uint64()\n}\n\n///|\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt64::lsr(self : UInt64, shift : Int) -> UInt64 {\n  MyInt64::lsr(MyInt64::from_uint64(self), shift).to_uint64()\n}\n\n///|\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt64::shl(self : UInt64, shift : Int) -> UInt64 {\n  MyInt64::lsl(MyInt64::from_uint64(self), shift).to_uint64()\n}\n\n///|\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt64::shr(self : UInt64, shift : Int) -> UInt64 {\n  MyInt64::lsr(MyInt64::from_uint64(self), shift).to_uint64()\n}\n\n///|\npub impl Shl for UInt64 with op_shl(self : UInt64, shift : Int) -> UInt64 {\n  MyInt64::lsl(MyInt64::from_uint64(self), shift).to_uint64()\n}\n\n///|\npub impl Shr for UInt64 with op_shr(self : UInt64, shift : Int) -> UInt64 {\n  MyInt64::lsr(MyInt64::from_uint64(self), shift).to_uint64()\n}\n\n///|\npub fn UInt64::clz(self : UInt64) -> Int {\n  MyInt64::from_uint64(self).clz()\n}\n\n///|\npub fn UInt64::ctz(self : UInt64) -> Int {\n  MyInt64::from_uint64(self).ctz()\n}\n\n///|\npub fn UInt64::popcnt(self : UInt64) -> Int {\n  MyInt64::from_uint64(self).popcnt()\n}\n\n///|\npub fn Int64::to_float(self : Int64) -> Float {\n  self.to_double().to_float()\n}\n\n///|\npub fn UInt64::to_float(self : UInt64) -> Float {\n  Double::convert_uint64(self).to_float()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn Int64::output(self : Int64, logger : &Logger, radix~ : Int = 10) -> Unit {\n  fn abs(n : Int64) -> Int64 {\n    if n < 0L {\n      0L - n\n    } else {\n      n\n    }\n  }\n\n  if self < 0L {\n    logger.write_char('-')\n  }\n  let radix : Int64 = radix.to_int64()\n  fn write_digits(num : Int64) {\n    let num2 = num / radix\n    if num2 != 0L {\n      write_digits(num2)\n    }\n    logger.write_char(\n      Char::from_int(ALPHABET.charcode_at(abs(num % radix).to_int())),\n    )\n  }\n\n  write_digits(abs(self))\n}\n\n///|\nfn Int::output(self : Int, logger : &Logger, radix~ : Int = 10) -> Unit {\n  fn abs(n : Int) -> Int {\n    if n < 0 {\n      0 - n\n    } else {\n      n\n    }\n  }\n\n  if self < 0 {\n    logger.write_char('-')\n  }\n  fn write_digits(num : Int) {\n    let num2 = num / radix\n    if num2 != 0 {\n      write_digits(num2)\n    }\n    logger.write_char(Char::from_int(ALPHABET.charcode_at(abs(num % radix))))\n  }\n\n  write_digits(abs(self))\n}\n\n///|\nfn UInt::output(self : UInt, logger : &Logger, radix~ : Int = 10) -> Unit {\n  let radix : UInt = radix.reinterpret_as_uint()\n  fn write_digits(num : UInt) {\n    let num2 = num / radix\n    if num2 != 0U {\n      write_digits(num2)\n    }\n    logger.write_char(\n      Char::from_int(ALPHABET.charcode_at((num % radix).reinterpret_as_int())),\n    )\n  }\n\n  write_digits(self)\n}\n\n///|\nfn UInt64::output(self : UInt64, logger : &Logger, radix~ : Int = 10) -> Unit {\n  let radix : UInt64 = radix.to_uint64()\n  fn write_digits(num : UInt64) {\n    let num2 = num / radix\n    if num2 != 0UL {\n      write_digits(num2)\n    }\n    logger.write_char(\n      Char::from_int(ALPHABET.charcode_at((num % radix).to_int())),\n    )\n  }\n\n  write_digits(self)\n}\n\n///|\nfn Int64::output_size_hint(radix~ : Int = 10) -> Int {\n  match radix {\n    2..<7 => 70 // max length is 64, 70 is enough\n    8..<15 => 30 // max length is 23, 30 is enough\n    16..=36 => 20 // max length is 17, 20 is enough\n    _ => abort(\"radix must be between 2 and 36\")\n  }\n}\n\n///|\nfn Int::output_size_hint(radix~ : Int = 10) -> Int {\n  match radix {\n    2..<7 => 36 // max length is 32, 36 is enough\n    8..<15 => 18 // max length is 12, 18 is enough\n    16..=36 => 10 // max length is 8, 10 is enough\n    _ => abort(\"radix must be between 2 and 36\")\n  }\n}\n\n///|\nfn UInt::output_size_hint(radix~ : Int = 10) -> Int {\n  Int::output_size_hint(radix~)\n}\n\n///|\nfn UInt64::output_size_hint(radix~ : Int = 10) -> Int {\n  Int64::output_size_hint(radix~)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a source code location in a MoonBit program, containing\n/// information about the file path, line number, and column number. Used\n/// internally by the compiler for error reporting and debugging purposes.\n///\n/// This type is public to all packages but its internal representation is\n/// opaque. Users cannot construct values of this type directly; they are\n/// automatically created by the compiler when needed.\npub(all) extern type SourceLoc\n\n///|\n/// Converts a source location to its string representation.\n///\n/// Parameters:\n///\n/// * `source_location` : A source code location containing information about the\n/// file path, line number, and column number.\n///\n/// Returns a string representation of the source location, typically in the\n/// format \"file:line:column\".\n///\n/// Note: This function is primarily used internally by the compiler for error\n/// reporting and debugging purposes. Source locations are automatically created\n/// by the compiler when needed.\npub fn SourceLoc::to_string(self : SourceLoc) -> String = \"%loc_to_string\"\n\n///|\npub impl Show for SourceLoc with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\n/// Represents a type for storing argument locations in source code. It is an\n/// array of optional source locations, where each element corresponds to an\n/// argument's location in the source code. Used internally by the compiler for\n/// error reporting and debugging purposes.\npub(all) type ArgsLoc Array[SourceLoc?] derive(Show)\n\n///|\n/// Converts an array of optional source locations to its JSON string\n/// representation. Each location in the array is either represented as a string\n/// if present, or \"null\" if absent.\n///\n/// Parameters:\n///\n/// * `self` : The array of optional source locations to be converted.\n///\n/// Returns a JSON array string where each element is either a string\n/// representation of a source location or \"null\".\npub fn ArgsLoc::to_json(self : ArgsLoc) -> String {\n  let buf = StringBuilder::new(size_hint=10)\n  buf.write_char('[')\n  for i in 0..<self._.length() {\n    if i != 0 {\n      buf.write_string(\", \")\n    }\n    let item = self._[i]\n    match item {\n      None => buf.write_string(\"null\")\n      Some(loc) => loc.to_string() |> Show::output(buf)\n    }\n  }\n  buf.write_char(']')\n  buf.to_string()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n// Types\npriv struct Entry[K, V] {\n  mut idx : Int\n  mut psl : Int\n  hash : Int\n  key : K\n  mut value : V\n} derive(Show)\n\n///|\nimpl[K : Eq, V] Eq for Entry[K, V] with op_equal(self, other) {\n  self.hash == other.hash && self.key == other.key\n}\n\n///|\npriv struct ListNode[K, V] {\n  mut prev : Entry[K, V]?\n  mut next : Entry[K, V]?\n}\n\n///|\n/// Mutable linked hash map that maintains the order of insertion, not thread safe.\n///\n/// # Example\n///\n/// ```\n/// let map = { 3: \"three\", 8 :  \"eight\", 1 :  \"one\"}\n/// assert_eq!(map.get(2), None)\n/// assert_eq!(map.get(3), Some(\"three\"))\n/// map.set(3, \"updated\")\n/// assert_eq!(map.get(3), Some(\"updated\"))\n/// ```\nstruct Map[K, V] {\n  mut entries : FixedArray[Entry[K, V]?]\n  mut list : FixedArray[ListNode[K, V]] // list of (prev, next)\n  mut size : Int // active key-value pairs count\n  mut capacity : Int // current capacity\n  mut capacity_mask : Int // capacity_mask = capacity - 1, used to find idx\n  mut growAt : Int // threshold that triggers grow\n  mut head : Entry[K, V]? // head of linked list\n  mut tail : Entry[K, V]? // tail of linked list\n}\n\n// Implementations\n\n///|\nfn power_2_above(x : Int, n : Int) -> Int {\n  for i = x {\n    if i >= n {\n      break i\n    }\n    let next = i << 1\n    if next < 0 {\n      // overflow happened\n      break i\n    }\n    continue next\n  }\n}\n\n///|\ntest \"power_2_above\" {\n  inspect!(power_2_above(1, 15), content=\"16\")\n  inspect!(power_2_above(1, 16), content=\"16\")\n  inspect!(power_2_above(1, 17), content=\"32\")\n  inspect!(power_2_above(1, 32), content=\"32\")\n  inspect!(power_2_above(128, 33), content=\"128\")\n  inspect!(power_2_above(1, 2147483647), content=\"1073741824\")\n}\n\n///|\n/// Create a hash map.\n/// The capacity of the map will be the smallest power of 2 that is\n/// greater than or equal to the provided [capacity].\npub fn Map::new[K, V](capacity~ : Int = 8) -> Map[K, V] {\n  let capacity = power_2_above(8, capacity)\n  {\n    size: 0,\n    capacity,\n    capacity_mask: capacity - 1,\n    growAt: calc_grow_threshold(capacity),\n    entries: FixedArray::make(capacity, None),\n    list: FixedArray::make(capacity, { prev: None, next: None }),\n    head: None,\n    tail: None,\n  }\n}\n\n///|\n/// Create a hash map from array.\npub fn Map::from_array[K : Hash + Eq, V](arr : Array[(K, V)]) -> Map[K, V] {\n  let m = Map::new(capacity=arr.length())\n  arr.each(fn(e) { m.set(e.0, e.1) })\n  m\n}\n\n///|\n/// Set a key-value pair into the hash map.\n/// @alert unsafe \"Panic if the hash map is full.\"\npub fn Map::set[K : Hash + Eq, V](self : Map[K, V], key : K, value : V) -> Unit {\n  if self.size >= self.growAt {\n    self.grow()\n  }\n  let hash = key.hash()\n  let insert_entry = { idx: -1, psl: 0, hash, key, value }\n  let list_node : ListNode[K, V] = { prev: None, next: None }\n  loop 0, hash & self.capacity_mask, insert_entry, list_node {\n    i, idx, entry, node =>\n      match self.entries[idx] {\n        None => {\n          self.entries[idx] = Some(entry)\n          self.list[idx] = node\n          entry.idx = idx\n          self.add_entry_to_tail(insert_entry)\n          self.size += 1\n          break\n        }\n        Some(curr_entry) => {\n          let curr_node = self.list[curr_entry.idx]\n          if curr_entry.hash == entry.hash && curr_entry.key == entry.key {\n            curr_entry.value = entry.value\n            break\n          }\n          if entry.psl > curr_entry.psl {\n            self.entries[idx] = Some(entry)\n            self.list[idx] = node\n            entry.idx = idx\n            curr_entry.psl += 1\n            continue i + 1,\n              (idx + 1) & self.capacity_mask,\n              curr_entry,\n              curr_node\n          } else {\n            entry.psl += 1\n            continue i + 1, (idx + 1) & self.capacity_mask, entry, node\n          }\n        }\n      }\n  }\n}\n\n///|\npub fn Map::op_set[K : Hash + Eq, V](\n  self : Map[K, V],\n  key : K,\n  value : V\n) -> Unit {\n  self.set(key, value)\n}\n\n///|\n/// Get the value associated with a key.\npub fn Map::get[K : Hash + Eq, V](self : Map[K, V], key : K) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          break Some(entry.value)\n        }\n        if i > entry.psl {\n          break None\n        }\n        continue i + 1, (idx + 1) & self.capacity_mask\n      }\n      None => break None\n    }\n  }\n}\n\n///|\npub fn Map::op_get[K : Hash + Eq, V](self : Map[K, V], key : K) -> V? {\n  self.get(key)\n}\n\n///|\n/// Returns the value associated with the key in the map, or computes and returns\n/// a default value if the key does not exist.\n///\n/// Parameters:\n///\n/// * `map` : The map to search in.\n/// * `key` : The key to look up in the map.\n/// * `default` : A function that returns a default value when the key is not\n/// found.\n///\n/// Returns either the value associated with the key if it exists, or the result\n/// of calling the default function.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"get_or_default\" {\n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect!(map.get_or_default(\"a\", 0), content=\"1\")\n///   inspect!(map.get_or_default(\"c\", 42), content=\"42\")\n/// }\n/// ```\npub fn Map::get_or_default[K : Hash + Eq, V](\n  self : Map[K, V],\n  key : K,\n  default : V\n) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          break entry.value\n        }\n        if i > entry.psl {\n          break default\n        }\n        continue i + 1, (idx + 1) & self.capacity_mask\n      }\n      None => break default\n    }\n  }\n}\n\n///|\n/// Returns the value for the given key, or sets and returns a default value if the key does not exist.\npub fn Map::get_or_init[K : Hash + Eq, V](\n  self : Map[K, V],\n  key : K,\n  default : () -> V\n) -> V {\n  match self.get(key) {\n    Some(v) => v\n    None => {\n      let v = default()\n      self.set(key, v)\n      v\n    }\n  }\n}\n\n///|\n/// Check if the hash map contains a key.\npub fn Map::contains[K : Hash + Eq, V](self : Map[K, V], key : K) -> Bool {\n  match self.get(key) {\n    Some(_) => true\n    None => false\n  }\n}\n\n///|\n/// Remove a key-value pair from hash map.\npub fn Map::remove[K : Hash + Eq, V](self : Map[K, V], key : K) -> Unit {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break }\n    if entry.hash == hash && entry.key == key {\n      self.entries[idx] = None\n      self.remove_entry(entry)\n      self.shift_back(idx)\n      self.size -= 1\n      break\n    }\n    if i > entry.psl {\n      break\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\nfn Map::add_entry_to_tail[K : Eq, V](\n  self : Map[K, V],\n  entry : Entry[K, V]\n) -> Unit {\n  match self.tail {\n    None => {\n      self.head = Some(entry)\n      self.tail = Some(entry)\n    }\n    Some(tail) => {\n      self.list[tail.idx].next = Some(entry)\n      self.list[entry.idx].prev = Some(tail)\n      self.tail = Some(entry)\n    }\n  }\n}\n\n///|\nfn Map::remove_entry[K : Eq, V](self : Map[K, V], entry : Entry[K, V]) -> Unit {\n  let node = self.list[entry.idx]\n  if self.is_empty() {\n    self.head = None\n    self.tail = None\n  } else {\n    if self.head.unwrap() == entry {\n      self.head = node.next\n    }\n    if self.tail.unwrap() == entry {\n      self.tail = node.prev\n    }\n    if node.prev is Some(prev) {\n      self.list[prev.idx].next = node.next\n    }\n    if node.next is Some(next) {\n      self.list[next.idx].prev = node.prev\n    }\n  }\n  node.prev = None\n  node.next = None\n}\n\n///|\nfn Map::shift_back[K : Hash, V](self : Map[K, V], start_index : Int) -> Unit {\n  for prev = start_index, curr = (start_index + 1) & self.capacity_mask {\n    match (self.entries[curr], self.list[curr]) {\n      (Some(entry), currNode) => {\n        if entry.psl == 0 {\n          break\n        }\n        entry.psl -= 1\n        entry.idx = prev\n        self.entries[prev] = Some(entry)\n        self.entries[curr] = None\n        self.list[prev].prev = currNode.prev\n        self.list[prev].next = currNode.next\n        currNode.prev = None\n        currNode.next = None\n        continue curr, (curr + 1) & self.capacity_mask\n      }\n      (None, _) => break\n    }\n  }\n}\n\n///|\nfn Map::grow[K : Hash + Eq, V](self : Map[K, V]) -> Unit {\n  let old_head = self.head\n  let old_list = self.list\n  let new_capacity = self.capacity << 1\n  self.entries = FixedArray::make(new_capacity, None)\n  self.list = FixedArray::make(new_capacity, { prev: None, next: None })\n  self.capacity = new_capacity\n  self.capacity_mask = new_capacity - 1\n  self.growAt = calc_grow_threshold(self.capacity)\n  self.size = 0\n  self.head = None\n  self.tail = None\n  loop old_head {\n    Some({ idx, key, value, .. }) => {\n      self.set(key, value)\n      continue old_list[idx].next\n    }\n    None => break\n  }\n}\n\n///|\nfn calc_grow_threshold(capacity : Int) -> Int {\n  capacity * 13 / 16\n}\n\n// Utils\n\n///|\nfn Map::debug_entries[K : Show, V : Show](self : Map[K, V]) -> String {\n  let buf = StringBuilder::new()\n  for i in 0..<self.entries.length() {\n    if i > 0 {\n      buf.write_char(',')\n    }\n    match self.entries[i] {\n      None => buf.write_char('_')\n      Some({ psl, key, value, .. }) =>\n        buf.write_string(\"(\\{psl},\\{key},\\{value})\")\n    }\n  }\n  buf.to_string()\n}\n\n///|\npub impl[K : Show, V : Show] Show for Map[K, V] with output(self, logger) {\n  logger.write_string(\"{\")\n  loop 0, self.head {\n    _, None => logger.write_string(\"}\")\n    i, Some({ key, value, idx, .. }) => {\n      if i > 0 {\n        logger.write_string(\", \")\n      }\n      logger..write_object(key)..write_string(\": \").write_object(value)\n      continue i + 1, self.list[idx].next\n    }\n  }\n}\n\n///|\n/// Get the number of key-value pairs in the map.\npub fn Map::size[K, V](self : Map[K, V]) -> Int {\n  self.size\n}\n\n///|\n/// Get the capacity of the map.\npub fn Map::capacity[K, V](self : Map[K, V]) -> Int {\n  self.capacity\n}\n\n///|\n/// Check if the hash map is empty.\npub fn Map::is_empty[K, V](self : Map[K, V]) -> Bool {\n  self.size == 0\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion.\npub fn Map::each[K, V](self : Map[K, V], f : (K, V) -> Unit) -> Unit {\n  loop self.head {\n    Some({ key, value, idx, .. }) => {\n      f(key, value)\n      continue self.list[idx].next\n    }\n    None => break\n  }\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion, with index.\npub fn Map::eachi[K, V](self : Map[K, V], f : (Int, K, V) -> Unit) -> Unit {\n  loop 0, self.head {\n    i, Some({ key, value, idx, .. }) => {\n      f(i, key, value)\n      continue i + 1, self.list[idx].next\n    }\n    _, None => break\n  }\n}\n\n///|\n/// Clears the map, removing all key-value pairs. Keeps the allocated space.\npub fn Map::clear[K, V](self : Map[K, V]) -> Unit {\n  self.entries.fill(None)\n  self.size = 0\n  self.head = None\n  self.tail = None\n}\n\n///|\n/// Returns the iterator of the hash map, provide elements in the order of insertion.\npub fn Map::iter[K, V](self : Map[K, V]) -> Iter[(K, V)] {\n  Iter::new(fn(yield_) {\n    loop self.head {\n      Some({ key, value, idx, .. }) => {\n        guard yield_((key, value)) is IterContinue else { break IterEnd }\n        continue self.list[idx].next\n      }\n      None => break IterContinue\n    }\n  })\n}\n\n///|\npub fn Map::iter2[K, V](self : Map[K, V]) -> Iter2[K, V] {\n  Iter2::new(fn(yield_) {\n    loop self.head {\n      Some({ key, value, idx, .. }) => {\n        guard yield_(key, value) is IterContinue else { break IterEnd }\n        continue self.list[idx].next\n      }\n      None => IterContinue\n    }\n  })\n}\n\n///|\npub fn Map::keys[K, V](self : Map[K, V]) -> Iter[K] {\n  Iter::new(fn(yield_) {\n    loop self.head {\n      Some({ key, idx, .. }) => {\n        guard yield_(key) is IterContinue else { break IterEnd }\n        continue self.list[idx].next\n      }\n      None => IterContinue\n    }\n  })\n}\n\n///|\npub fn Map::values[K, V](self : Map[K, V]) -> Iter[V] {\n  Iter::new(fn(yield_) {\n    loop self.head {\n      Some({ value, idx, .. }) => {\n        guard yield_(value) is IterContinue else { break IterEnd }\n        continue self.list[idx].next\n      }\n      None => IterContinue\n    }\n  })\n}\n\n///|\n/// Converts the hash map to an array.\npub fn Map::to_array[K, V](self : Map[K, V]) -> Array[(K, V)] {\n  let arr = Array::make_uninit(self.size)\n  let mut i = 0\n  loop self.head {\n    Some({ key, value, idx, .. }) => {\n      arr.unsafe_set(i, (key, value))\n      i += 1\n      continue self.list[idx].next\n    }\n    None => break\n  }\n  arr\n}\n\n///|\npub impl[K : Hash + Eq, V : Eq] Eq for Map[K, V] with op_equal(\n  self : Map[K, V],\n  that : Map[K, V]\n) -> Bool {\n  guard self.size == that.size else { return false }\n  for k, v in self {\n    match that.get(k) {\n      None => break false\n      Some(v_) => if v_ != v { break false }\n    }\n  } else {\n    true\n  }\n}\n\n///|\npub fn Map::of[K : Hash + Eq, V](arr : FixedArray[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let m = Map::new(capacity=length)\n  // arr.iter(fn(e) { m.set(e.0, e.1) })\n  for i in 0..<length {\n    let e = arr[i]\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\npub fn Map::from_iter[K : Hash + Eq, V](iter : Iter[(K, V)]) -> Map[K, V] {\n  let m = {}\n  for e in iter {\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\npub impl[K, V] Default for Map[K, V] with default() {\n  Map::new()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// An `ArrayView` represents a view into a section of an array without copying the data.\n///\n/// # Example\n///\n/// ```moonbit\n/// let arr = [1, 2, 3, 4, 5]\n/// let view = arr[1:4]  // Creates a view of elements at indices 1,2,3\n/// assert_eq!(view[0], 2)\n/// assert_eq!(view.length(), 3)\n/// ```\n/// @alert deprecated \"use @array.View instead\"\nstruct ArrayView[T] {\n  buf : UninitializedArray[T]\n  start : Int\n  len : Int\n}\n\n///|\n/// Returns the length (number of elements) of an array view.\n///\n/// Parameters:\n///\n/// * `array_view` : The array view whose length is to be determined.\n///\n/// Returns an integer representing the number of elements in the array view.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"ArrayView::length\" {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[2:4]\n///   inspect!(view.length(), content=\"2\")\n/// }\n/// ```\npub fn ArrayView::length[T](self : ArrayView[T]) -> Int {\n  self.len\n}\n\n///|\n/// Retrieves an element at the specified index from the array view.\n///\n/// Parameters:\n///\n/// * `self` : The array view to access.\n/// * `index` : The position in the array view from which to retrieve the\n/// element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the length of the array view).\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"ArrayView::op_get\" {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[2:4]\n///   inspect!(view[0], content=\"3\")\n///   inspect!(view[1], content=\"4\")\n/// }\n///\n/// test \"panic ArrayView::op_get/out_of_bounds\" {\n///   let arr = [1, 2, 3]\n///   let view = arr[1:]\n///   ignore(view[2]) // Index out of bounds\n/// }\n/// ```\npub fn ArrayView::op_get[T](self : ArrayView[T], index : Int) -> T {\n  guard index >= 0 && index < self.len else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.len} but the index is \\{index}\",\n    )\n  }\n  self.buf[self.start + index]\n}\n\n///|\n/// Retrieves an element from the array view at the specified index without\n/// performing bounds checking.\n///\n/// Parameters:\n///\n/// * `array_view` : The array view to retrieve the element from.\n/// * `index` : The position in the array view from which to retrieve the\n/// element.\n///\n/// Returns the element at the specified index in the array view.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"ArrayView::unsafe_get\" {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4]\n///   inspect!(view.unsafe_get(1), content=\"3\")\n/// }\n///\n/// test \"panic ArrayView::unsafe_get/out_of_bounds\" {\n///   let arr = [1, 2, 3]\n///   let view = arr[1:]\n///   ignore(view.unsafe_get(5)) // Index out of bounds\n/// }\n/// ```\n///\n#intrinsic(\"%arrayview.unsafe_get\")\n/// @alert unsafe \"Panic if index is out of bounds\"\npub fn ArrayView::unsafe_get[T](self : ArrayView[T], index : Int) -> T {\n  self.buf[self.start + index]\n}\n\n///|\n/// Sets the value at the specified index in the array view.\n///\n/// Parameters:\n///\n/// * `array_view` : The array view to modify.\n/// * `index` : The position in the array view where the value will be set.\n/// * `value` : The value to be assigned at the specified index.\n///\n/// Throws a panic if `index` is negative or greater than or equal to the length\n/// of the array view.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"ArrayView::op_set\" {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // view contains [2, 3, 4]\n///   view.op_set(1, 42)\n///   inspect!(arr, content=\"[1, 2, 42, 4, 5]\")\n/// }\n///\n/// test \"panic ArrayView::op_set/out_of_bounds\" {\n///   let arr = [1, 2, 3]\n///   let view = arr[1:]\n///   ignore(view.op_set(2, 42)) // Index out of bounds\n/// }\n/// ```\n///\n/// @alert unsafe \"Panic if index is out of bounds.\"\npub fn ArrayView::op_set[T](\n  self : ArrayView[T],\n  index : Int,\n  value : T\n) -> Unit {\n  guard index >= 0 && index < self.len else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.len} but the index is \\{index}\",\n    )\n  }\n  self.buf[self.start + index] = value\n}\n\n///|\n/// Swaps two elements in the array view at the specified indices.\n///\n/// Parameters:\n///\n/// * `self` : The array view in which to swap elements.\n/// * `i` : The index of the first element to be swapped.\n/// * `j` : The index of the second element to be swapped.\n///\n/// Throws a panic if either index is negative or greater than or equal to the\n/// length of the array view.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"ArrayView::swap\" {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // view = [2, 3, 4]\n///   view.swap(0, 2) // view = [4, 3, 2]\n///   inspect!(view, content=\"[4, 3, 2]\")\n/// }\n///\n/// test \"panic ArrayView::swap/out_of_bounds\" {\n///   let view = [1, 2, 3][:]\n///   ignore(view.swap(0, 3)) // Index out of bounds\n/// }\n/// ```\n///\n/// @alert unsafe \"Panic if index is out of bounds\"\npub fn ArrayView::swap[T](self : ArrayView[T], i : Int, j : Int) -> Unit {\n  guard i >= 0 && i < self.len && j >= 0 && j < self.len else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.len} but the index is (\\{i}, \\{j})\",\n    )\n  }\n  let temp = self.buf[self.start + i]\n  self.buf[self.start + i] = self.buf[self.start + j]\n  self.buf[self.start + j] = temp\n}\n\n///|\n/// Creates a view of a portion of the array. The view provides read-write access\n/// to the underlying array without copying the elements.\n///\n/// Parameters:\n///\n/// * `array` : The array to create a view from.\n/// * `start` : The starting index of the view (inclusive). Defaults to 0.\n/// * `end` : The ending index of the view (exclusive). If not provided, defaults\n/// to the length of the array.\n///\n/// Returns an `ArrayView` that provides a window into the specified portion of\n/// the array.\n///\n/// Throws a panic if the indices are invalid (i.e., `start` is negative, `end`\n/// is greater than the array length, or `start` is greater than `end`).\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"op_as_view\" {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // Create a view of elements at indices 1, 2, and 3\n///   inspect!(view[0], content=\"2\") // First element of view is arr[1]\n///   inspect!(view.length(), content=\"3\") // View contains 3 elements\n/// }\n///\n/// test \"panic op_as_view/invalid_range\" {\n///   let arr = [1, 2, 3]\n///   ignore(arr[2:1]) // Panic: start index greater than end index\n/// }\n/// ```\npub fn Array::op_as_view[T](\n  self : Array[T],\n  start~ : Int = 0,\n  end? : Int\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View index out of bounds\")\n  }\n  ArrayView::{ buf: self.buffer(), start, len: end - start }\n}\n\n///|\n/// Creates a new view into a portion of the array view.\n///\n/// Parameters:\n///\n/// * `self` : The array view to create a new view from.\n/// * `start` : The starting index in the current view (inclusive). Defaults to\n/// 0.\n/// * `end` : The ending index in the current view (exclusive). Defaults to the\n/// length of the current view.\n///\n/// Returns a new `ArrayView` that provides a window into the specified portion\n/// of the original array view. The indices are relative to the start of the\n/// current view.\n///\n/// Throws a panic if:\n///\n/// * `start` is negative\n/// * `end` is greater than the length of the current view\n/// * `start` is greater than `end`\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"ArrayView::op_as_view\" {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // view = [2, 3, 4]\n///   let subview = view[1:2] // subview = [3]\n///   inspect!(subview[0], content=\"3\")\n/// }\n/// ```\n///\n/// ```moonbit\n/// test \"panic ArrayView::op_as_view/invalid_range\" {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4]\n///   ignore(view[2:5]) // Panic: end index out of bounds\n/// }\n/// ```\npub fn ArrayView::op_as_view[T](\n  self : ArrayView[T],\n  start~ : Int = 0,\n  end? : Int\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View index out of bounds\")\n  }\n  ArrayView::{ buf: self.buf, start: self.start + start, len: end - start }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//#region\n// These types are of workaround for the restriction that MoonBit do not support\n// generic type parameters of extern ffi\n\n///|\npriv extern type JSValue\n\n///|\nfn JSValue::ofAny[T](array : T) -> JSValue = \"%identity\"\n\n///|\nfn JSValue::toAny[T](self : JSValue) -> T = \"%identity\"\n\n///|\npriv extern type JSArray\n\n///|\nfn JSArray::ofAnyArray[T](array : Array[T]) -> JSArray = \"%identity\"\n\n///|\nfn JSArray::toAnyArray[T](self : JSArray) -> Array[T] = \"%identity\"\n\n///|\nextern \"js\" fn JSArray::set_length(self : JSArray, new_len : Int) -> Unit =\n  #| (arr, len) => { arr.length = len; }\n\n///|\nextern \"js\" fn JSArray::push(self : JSArray, value : JSValue) -> Unit =\n  #| (arr, val) => { arr.push(val); }\n\n///|\nextern \"js\" fn JSArray::pop(self : JSArray) -> JSValue =\n  #| (arr) => arr.pop()\n\n///|\nextern \"js\" fn JSArray::splice(\n  self : JSArray,\n  index : Int,\n  count : Int\n) -> JSArray =\n  #| (arr, idx, cnt) => arr.splice(idx, cnt)\n\n///|\nextern \"js\" fn JSArray::splice1(\n  self : JSArray,\n  index : Int,\n  count : Int,\n  value : JSValue\n) -> JSArray =\n  #| (arr, idx, cnt, val) => arr.splice(idx, cnt, val)\n\n//#endregion\n\n///|\n/// An `Array` is a collection of values that supports random access and can\n/// grow in size.\nextern type Array[T]\n\n///|\nfn Array::make_uninit[T](len : Int) -> Array[T] = \"%fixedarray.make_uninit\"\n\n///|\n/// Creates a new array.\npub fn Array::new[T](capacity~ : Int = 0) -> Array[T] {\n  ignore(capacity)\n  []\n}\n\n///|\n/// Returns the number of elements in the array.\npub fn Array::length[T](self : Array[T]) -> Int = \"%fixedarray.length\"\n\n///|\nfn Array::unsafe_truncate_to_length[T](self : Array[T], new_len : Int) -> Unit {\n  JSArray::ofAnyArray(self).set_length(new_len)\n}\n\n///|\nfn Array::buffer[T](self : Array[T]) -> UninitializedArray[T] = \"%identity\"\n\n///|\ntest \"array_unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq!(dst[i], src[i])\n  }\n}\n\n///|\ntest \"UninitializedArray::unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq!(dst[i], src[i])\n  }\n}\n\n///|\ntest \"UninitializedArray::unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq!(dst[i], src[i])\n  }\n}\n\n///|\n/// Reserves capacity to ensure that it can hold at least the number of elements\n/// specified by the `capacity` argument.\n///\n/// **NOTE**: This method does nothing on js platform.\n/// # Example\n///\n/// ```\n/// let v = [1]\n/// v.reserve_capacity(10)\n/// assert_eq!(v.capacity(), 1)\n/// ```\npub fn Array::reserve_capacity[T](self : Array[T], capacity : Int) -> Unit {\n  ignore(self)\n  ignore(capacity)\n}\n\n///|\n/// Shrinks the capacity of the array as much as possible.\n///\n/// **NOTE**: This method does nothing on js platform.\n/// # Example\n///\n/// ```\n/// let v = Array::new(capacity=10)\n/// v.push(1)\n/// v.push(2)\n/// v.push(3)\n/// assert_eq!(v.capacity(), 3)\n/// v.shrink_to_fit()\n/// assert_eq!(v.capacity(), 3)\n/// ```\npub fn Array::shrink_to_fit[T](self : Array[T]) -> Unit {\n  ignore(self)\n}\n\n///|\n/// Adds an element to the end of the array.\n///\n/// If the array is at capacity, it will be reallocated.\n///\n/// # Example\n/// ```\n/// let v = []\n/// v.push(3)\n/// ```\npub fn Array::push[T](self : Array[T], value : T) -> Unit {\n  JSArray::ofAnyArray(self).push(JSValue::ofAny(value))\n}\n\n///|\n/// Removes the last element from a array and returns it, or `None` if it is empty.\n///\n/// # Example\n/// ```\n/// let v = [1, 2, 3]\n/// let vv = v.pop()\n/// assert_eq!(vv, Some(3))\n/// assert_eq!(v, [1, 2])\n/// ```\npub fn Array::pop[T](self : Array[T]) -> T? {\n  if self.length() == 0 {\n    None\n  } else {\n    let v = self.unsafe_pop()\n    Some(v)\n  }\n}\n\n///|\n#deprecated(\"Use `unsafe_pop` instead\")\n#coverage.skip\npub fn Array::pop_exn[T](self : Array[T]) -> T {\n  self.unsafe_pop()\n}\n\n///|\n/// Removes the last element from a array and returns it.\n///\n/// **NOTE** This method will not cause a panic, but it may result in undefined\n/// behavior on the JavaScript platform. Use with caution.\n///\n/// @alert unsafe \"Panic if the array is empty.\"\npub fn Array::unsafe_pop[T](self : Array[T]) -> T {\n  JSArray::ofAnyArray(self).pop().toAny()\n}\n\n///|\n/// Remove an element from the array at a given index.\n///\n/// Removes and returns the element at position index within the array, shifting all elements after it to the left.\n///\n/// # Example\n/// ```\n/// let v = [3, 4, 5]\n/// let vv = v.remove(1)\n/// assert_eq!(vv, 4)\n/// assert_eq!(v, [3, 5])\n/// ```\n/// @alert unsafe \"Panic if index is out of bounds.\"\npub fn Array::remove[T](self : Array[T], index : Int) -> T {\n  guard index >= 0 && index < self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  let value = self.buffer()[index]\n  let _ = JSArray::ofAnyArray(self).splice(index, 1)\n  value\n}\n\n///|\n/// Removes the specified range from the array and returns it.\n///\n/// This functions returns a array range from `begin` to `end` `[begin, end)`\n///\n/// # Example\n/// ```\n/// let v = [3, 4, 5]\n/// let vv = v.drain(1, 2) // vv = [4], v = [3, 5]\n/// ```\n/// @alert unsafe \"Panic if index is out of bounds.\"\npub fn Array::drain[T](self : Array[T], begin : Int, end : Int) -> Array[T] {\n  guard begin >= 0 && end <= self.length() && begin <= end else {\n    abort(\n      \"index out of bounds: the len is \\{self.length()} but the index is (\\{begin}, \\{end})\",\n    )\n  }\n  JSArray::ofAnyArray(self).splice(begin, end - begin).toAnyArray()\n}\n\n///|\n/// Inserts an element at a given index within the array.\n///\n/// # Example\n/// ```\n/// [3, 4, 5].insert(1, 6)\n/// ```\n/// @alert unsafe \"Panic if index is out of bounds.\"\npub fn Array::insert[T](self : Array[T], index : Int, value : T) -> Unit {\n  guard index >= 0 && index <= self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  let _ = JSArray::ofAnyArray(self).splice1(index, 0, JSValue::ofAny(value))\n\n}\n\n///|\n/// Resize the array in-place so that `len` is equal to `new_len`.\n///\n/// If `new_len` is greater than `len`, the array will be extended by the\n/// difference, and the values in the new slots are left uninitilized.\n///  If `new_len` is less than `len`, it will panic\n///\n/// @alert unsafe \"Panic if new length is negative.\"\nfn Array::unsafe_grow_to_length[T](self : Array[T], new_len : Int) -> Unit {\n  guard new_len >= self.length()\n  JSArray::ofAnyArray(self).set_length(new_len)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst ALPHABET : String = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\n///|\npub fn Int64::to_string(self : Int64, radix~ : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=Int64::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for Int64 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn Int::to_string(self : Int, radix~ : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=Int::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for Int with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn UInt::to_string(self : UInt, radix~ : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=UInt::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for UInt with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\ntest \"UInt::to_string\" {\n  inspect!(0U, content=\"0\")\n  inspect!(17U, content=\"17\")\n  inspect!(4294967295U, content=\"4294967295\")\n}\n\n///|\npub fn UInt64::to_string(self : UInt64, radix~ : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=UInt64::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for UInt64 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn Int16::to_string(self : Int16, radix~ : Int = 10) -> String {\n  self.to_int().to_string(radix~)\n}\n\n///|\npub impl Show for Int16 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn UInt16::to_string(self : UInt16, radix~ : Int = 10) -> String {\n  self.to_int().to_string(radix~)\n}\n\n///|\npub impl Show for UInt16 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\ntest \"to_string\" {\n  assert_eq!((0x100).to_string(), \"256\")\n  assert_eq!(\"\\{0x100}\", \"256\")\n  assert_eq!(0x200U.to_string(), \"512\")\n  assert_eq!(\"\\{0x200U}\", \"512\")\n  assert_eq!(0x300L.to_string(), \"768\")\n  assert_eq!(\"\\{0x300L}\", \"768\")\n  assert_eq!(0x400UL.to_string(), \"1024\")\n  assert_eq!(\"\\{0x400UL}\", \"1024\")\n}\n\n///|\ntest \"to_string with radix\" {\n  // Binary\n  inspect!((0).to_string(radix=2), content=\"0\")\n  inspect!((1).to_string(radix=2), content=\"1\")\n  inspect!((2).to_string(radix=2), content=\"10\")\n  inspect!((255).to_string(radix=2), content=\"11111111\")\n  inspect!((-255).to_string(radix=2), content=\"-11111111\")\n\n  // Octal\n  inspect!((0).to_string(radix=8), content=\"0\")\n  inspect!((8).to_string(radix=8), content=\"10\")\n  inspect!((64).to_string(radix=8), content=\"100\")\n  inspect!((-64).to_string(radix=8), content=\"-100\")\n\n  // Decimal\n  inspect!((0).to_string(radix=10), content=\"0\")\n  inspect!((123).to_string(radix=10), content=\"123\")\n  inspect!((-123).to_string(radix=10), content=\"-123\")\n  inspect!(\n    0x7fff_ffff_ffff_ffffL.to_string(radix=10),\n    content=\"9223372036854775807\",\n  )\n  inspect!(\n    0x8000_0000_0000_0000L.to_string(radix=10),\n    content=\"-9223372036854775808\",\n  )\n\n  // Hexadecimal\n  inspect!((0).to_string(radix=16), content=\"0\")\n  inspect!((0x11).to_string(radix=16), content=\"11\")\n  inspect!((0x15ef).to_string(radix=16), content=\"15ef\")\n  inspect!((-0xabcd).to_string(radix=16), content=\"-abcd\")\n  inspect!(\n    (1.0 : Float).reinterpret_as_int().to_string(radix=16),\n    content=\"3f800000\",\n  )\n\n  // UInt\n  inspect!(0U.to_string(radix=16), content=\"0\")\n  inspect!(0x1AU.to_string(radix=16), content=\"1a\")\n  inspect!(0xabcdU.to_string(radix=16), content=\"abcd\")\n  inspect!(\n    (-2.0 : Float).reinterpret_as_uint().to_string(radix=16),\n    content=\"c0000000\",\n  )\n  inspect!((-1).reinterpret_as_uint().to_string(radix=16), content=\"ffffffff\")\n\n  // Int64\n  inspect!(0L.to_string(radix=16), content=\"0\")\n  inspect!(0x2fL.to_string(radix=16), content=\"2f\")\n  inspect!(0xf0aeL.to_string(radix=16), content=\"f0ae\")\n  inspect!((-0x1234eacbL).to_string(radix=16), content=\"-1234eacb\")\n  inspect!(\n    1.0.reinterpret_as_uint64().to_string(radix=16),\n    content=\"3ff0000000000000\",\n  )\n\n  // UInt64\n  inspect!(0UL.to_string(radix=16), content=\"0\")\n  inspect!(0x11UL.to_string(radix=16), content=\"11\")\n  inspect!(0x12bdUL.to_string(radix=16), content=\"12bd\")\n  inspect!(\n    (-1L).reinterpret_as_uint64().to_string(radix=16),\n    content=\"ffffffffffffffff\",\n  )\n  inspect!(\n    2.0.reinterpret_as_uint64().to_string(radix=16),\n    content=\"4000000000000000\",\n  )\n}\n\n///|\ntest \"panic to_string_by_radix/illegal_radix\" {\n  ignore((1).to_string(radix=1))\n  ignore((1).to_string(radix=37))\n  ignore(1L.to_string(radix=0))\n  ignore(1L.to_string(radix=42))\n  ignore(1U.to_string(radix=-1))\n  ignore(1U.to_string(radix=73))\n  ignore(1UL.to_string(radix=-100))\n  ignore(1UL.to_string(radix=100))\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Trait for types whose elements can test for equality\npub(open) trait Eq {\n  op_equal(Self, Self) -> Bool\n}\n\n///|\n/// Trait for types whose elements are ordered\n///\n/// The return value of [compare] is:\n/// - zero, if the two arguments are equal\n/// - negative, if the first argument is smaller\n/// - positive, if the first argument is greater\npub(open) trait Compare: Eq {\n  compare(Self, Self) -> Int\n}\n\n///|\n/// Trait for types that can be hashed\npub(open) trait Hash {\n  hash_combine(Self, Hasher) -> Unit\n  hash(Self) -> Int = _\n}\n\n///|\nimpl Hash with hash(self) {\n  Hasher::new()..combine(self).finalize()\n}\n\n///|\n/// Trait for types with a default value\npub(open) trait Default {\n  default() -> Self\n}\n\n///|\n/// Trait for a logger, where debug logs can be written into\npub(open) trait Logger {\n  write_string(Self, String) -> Unit\n  write_substring(Self, String, Int, Int) -> Unit\n  write_char(Self, Char) -> Unit = _\n}\n\n///|\nimpl Logger with write_char(self, value) {\n  self.write_string([value])\n}\n\n///|\n/// Trait for types that can be converted to `String`\npub(open) trait Show {\n  // `output` is used for composition of aggregate structure.\n  // `output` writes a string representation of `self` to a logger.\n  // `output` should produce a valid MoonBit-syntax representation if possible.\n  // For example, `Show::output` for `String` should be quoted\n  output(Self, &Logger) -> Unit\n  // `to_string` should be used by end users of `Show`,\n  // for printing, interpolation, etc. only, and should not be used for composition.\n  // By default `to_string` is implemented using `output` and a buffer,\n  // but some types, such as `String`, may override `to_string`,\n  // for different (unescaped) behavior when interpolated/printed directly\n  to_string(Self) -> String = _\n}\n\n///|\n// Default implementation for `Show::to_string`, uses a `Buffer`\nimpl Show with to_string(self) {\n  let logger = StringBuilder::new()\n  self.output(logger)\n  logger.to_string()\n}\n\n///|\npub fn &Logger::write_object[Obj : Show](self : &Logger, obj : Obj) -> Unit {\n  obj.output(self)\n}\n\n///|\npub fn &Logger::write_iter[T : Show](\n  self : &Logger,\n  iter : Iter[T],\n  prefix~ : String = \"[\",\n  suffix~ : String = \"]\",\n  sep~ : String = \", \",\n  trailing~ : Bool = false\n) -> Unit {\n  self.write_string(prefix)\n  if trailing {\n    for x in iter {\n      self.write_object(x)\n      self.write_string(sep)\n    }\n  } else {\n    // trailing is false\n    let mut first = true\n    for x in iter {\n      if first {\n        first = false\n      } else {\n        self.write_string(sep)\n      }\n      self.write_object(x)\n    }\n  }\n  self.write_string(suffix)\n}\n// TODO: Logger::write_double(self:Logger, val:Double) -> Unit\n\n///|\npub fn repr[T : Show](t : T) -> String {\n  let logger = StringBuilder::new()\n  t.output(logger)\n  logger.to_string()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n// Types\ntype Iter[T] ((T) -> IterResult) -> IterResult\n\n///|\n//TODO: Add intrinsic for Iter::run\npub fn Iter::run[T](self : Iter[T], f : (T) -> IterResult) -> IterResult {\n  (self._)(f)\n}\n\n///|\npub fn Iter::just_run[T](self : Iter[T], f : (T) -> IterResult) -> Unit {\n  (self._)(f) |> ignore\n}\n\n///|\npub(all) enum IterResult {\n  IterEnd // false\n  IterContinue // true\n} derive(Eq)\n\n///|\npub impl[T : Show] Show for Iter[T] with output(self, logger) {\n  logger.write_iter(self)\n}\n\n// Consumers\n\n///|\n/// Iterates over each element in the iterator, applying the function `f` to each element.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n/// - `f`: A function that takes an element of type `T` and returns `Unit`. This function is applied to each element of the iterator.\n/// TODO: change the intrinsic to match the function name\n#intrinsic(\"%iter.iter\")\npub fn Iter::each[T](self : Iter[T], f : (T) -> Unit) -> Unit {\n  for a in self {\n    f(a)\n  }\n}\n\n///|\npub fn Iter::any[T](self : Iter[T], f : (T) -> Bool) -> Bool {\n  self.run(fn(k) { if f(k) { IterEnd } else { IterContinue } }) != IterContinue\n}\n\n///|\npub fn Iter::all[T](self : Iter[T], f : (T) -> Bool) -> Bool {\n  self.run(fn(k) { if not(f(k)) { IterEnd } else { IterContinue } }) ==\n  IterContinue\n}\n\n///|\n/// Iterates over each element in the iterator, applying the function `f` to each element with index.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n/// - `f`: A function that takes an index of type `Int` and an element of type `T` and returns `Unit`. This function is applied to each element of the iterator.\n/// TODO: Add intrinsic\npub fn Iter::eachi[T](self : Iter[T], f : (Int, T) -> Unit) -> Unit {\n  let mut i = 0\n  for a in self {\n    f(i, a)\n    i += 1\n  }\n}\n\n///|\n/// Folds the elements of the iterator using the given function, starting with the given initial value.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n/// - `B`: The type of the accumulator value.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n/// - `f`: A function that takes an accumulator of type `B` and an element of type `T`, and returns a new accumulator value.\n/// - `init`: The initial value for the fold operation.\n///\n/// # Returns\n///\n/// Returns the final accumulator value after folding all elements of the iterator.\n#intrinsic(\"%iter.reduce\")\npub fn Iter::fold[T, B](self : Iter[T], init~ : B, f : (B, T) -> B) -> B {\n  let mut acc = init\n  for a in self {\n    acc = f(acc, a)\n  }\n  acc\n}\n\n///|\n/// Counts the number of elements in the iterator.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n///\n/// # Returns\n///\n/// Returns the number of elements in the iterator.\npub fn Iter::count[T](self : Iter[T]) -> Int {\n  self.fold(fn { acc, _ => acc + 1 }, init=0)\n}\n\n// Producers\n\n///|\n/// Do not use this method, it is for internal use only.\npub fn Iter::new[T](f : ((T) -> IterResult) -> IterResult) -> Iter[T] {\n  Iter(f)\n}\n\n///|\n/// Creates an empty iterator.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Returns\n///\n/// Returns an empty iterator of type `Iter[T]`.\npub fn Iter::empty[T]() -> Iter[T] {\n  fn { _ => IterContinue }\n}\n\n///|\n/// Creates an iterator that contains a single element.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the element in the iterator.\n///\n/// # Arguments\n///\n/// - `a`: The single element to be contained in the iterator.\n///\n/// # Returns\n///\n/// Returns an iterator of type `Iter[T]` that contains the single element `a`.\npub fn Iter::singleton[T](a : T) -> Iter[T] {\n  fn { yield_ => yield_(a) }\n}\n\n///|\n/// Creates an iterator that repeats the given element indefinitely.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `a`: The element to be repeated.\n///\n/// # Returns\n///\n/// Returns an iterator of type `Iter[T]` that repeats the element `a` indefinitely.\n#intrinsic(\"%iter.repeat\")\npub fn Iter::repeat[T](a : T) -> Iter[T] {\n  fn(yield_) {\n    loop yield_(a) {\n      IterContinue => continue yield_(a)\n      IterEnd => IterEnd\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of Int with default step 1.\n/// To grow the range downward, set the `step` parameter to a negative value.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive by default).\n/// * `step` - The step size of the range (default 1).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Int from `start` to `end - 1`.\npub fn Int::until(\n  self : Int,\n  end : Int,\n  step~ : Int = 1,\n  inclusive~ : Bool = false\n) -> Iter[Int] {\n  if step == 0 {\n    return Iter::empty()\n  }\n  fn(yield_) {\n    let mut i = self\n    while (step > 0 && i < end) ||\n          (step < 0 && i > end) ||\n          (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      let next = i + step\n      if (step > 0 && next >= i) || (step < 0 && next <= i) {\n        i = next\n      } else {\n        break IterContinue\n      }\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of Int64 with default step 1L.\n/// To grow the range downward, set the `step` parameter to a negative value.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive by default).\n/// * `step` - The step size of the range (default 1L).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Int64 from `start` to `end - 1`.\npub fn Int64::until(\n  self : Int64,\n  end : Int64,\n  step~ : Int64 = 1L,\n  inclusive~ : Bool = false\n) -> Iter[Int64] {\n  if step == 0 {\n    return Iter::empty()\n  }\n  fn(yield_) {\n    let mut i = self\n    while (step > 0 && i < end) ||\n          (step < 0 && i > end) ||\n          (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      let next = i + step\n      if (step > 0 && next >= i) || (step < 0 && next <= i) {\n        i = next\n      } else {\n        break IterContinue\n      }\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of Float with default step 1.0 .\n/// To grow the range downward, set the `step` parameter to a negative value.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive by default).\n/// * `step` - The step size of the range (default 1.0).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Float from `start` to `end - 1`.\npub fn Float::until(\n  self : Float,\n  end : Float,\n  step~ : Float = 1.0,\n  inclusive~ : Bool = false\n) -> Iter[Float] {\n  if step == 0.0 {\n    return Iter::empty()\n  }\n  fn(yield_) {\n    let mut i = self\n    while (step > 0.0 && i < end) ||\n          (step < 0.0 && i > end) ||\n          (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      let next = i + step\n      if (step > 0.0 && next >= i) || (step < 0.0 && next <= i) {\n        i = next\n      } else {\n        break IterContinue\n      }\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of Double with default step 1.0 .\n/// To grow the range downward, set the `step` parameter to a negative value.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive by default).\n/// * `step` - The step size of the range (default 1.0).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Double from `start` to `end - 1`.\npub fn Double::until(\n  self : Double,\n  end : Double,\n  step~ : Double = 1.0,\n  inclusive~ : Bool = false\n) -> Iter[Double] {\n  if step == 0.0 {\n    return Iter::empty()\n  }\n  fn(yield_) {\n    let mut i = self\n    while (step > 0.0 && i < end) ||\n          (step < 0.0 && i > end) ||\n          (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      let next = i + step\n      if (step > 0.0 && next >= i) || (step < 0.0 && next <= i) {\n        i = next\n      } else {\n        break IterContinue\n      }\n    } else {\n      IterContinue\n    }\n  }\n}\n\n// operators\n\n///|\n/// Filters the elements of the iterator based on a predicate function.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element should be included in the filtered iterator.\n///\n/// # Returns\n///\n/// A new iterator that only contains the elements for which the predicate function returns `IterContinue`.\n#intrinsic(\"%iter.filter\")\npub fn Iter::filter[T](self : Iter[T], f : (T) -> Bool) -> Iter[T] {\n  fn(yield_) {\n    self.run(fn { a => if f(a) { yield_(a) } else { IterContinue } })\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n/// - `R`: The type of the transformed elements.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The mapping function that transforms each element of the iterator.\n///\n/// # Returns\n///\n/// A new iterator that contains the transformed elements.\n#intrinsic(\"%iter.map\")\npub fn Iter::map[T, R](self : Iter[T], f : (T) -> R) -> Iter[R] {\n  fn { yield_ => self.run(fn { a => yield_(f(a)) }) }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function that returns an `Option`.\n/// The elements for which the function returns `None` are filtered out.\npub fn Iter::filter_map[A, B](self : Iter[A], f : (A) -> B?) -> Iter[B] {\n  fn(yield_) {\n    self.run(fn(a) {\n      match f(a) {\n        Some(b) => yield_(b)\n        None => IterContinue\n      }\n    })\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function that returns an `Option`.\n/// The elements for which the function returns `None` are filtered out.\n///\n#deprecated(\"Use `Iter::filter_map` instead\")\npub fn Iter::map_option[A, B](self : Iter[A], f : (A) -> B?) -> Iter[B] {\n  self.filter_map(f)\n}\n\n///|\n/// Transforms each element of the iterator into an iterator and flattens the resulting iterators into a single iterator.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n/// - `R`: The type of the transformed elements.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The function that transforms each element of the iterator into an iterator.\n///\n/// # Returns\n///\n/// A new iterator that contains the flattened elements.\n#intrinsic(\"%iter.flat_map\")\npub fn Iter::flat_map[T, R](self : Iter[T], f : (T) -> Iter[R]) -> Iter[R] {\n  fn { yield_ => self.run(fn { x => f(x).run(yield_) }) }\n}\n\n///| \n/// iter.map(f).flatten() == iter..flat_map(f)\n/// ```moonbit \n/// test {\n///   fn f(n : Int) { Int::until(0,n) }\n///   let xs = f(10)\n///   assert_eq!(xs.map(f).flatten().to_array(),xs.flat_map(f).to_array())\n/// }\n/// ```\npub fn Iter::flatten[T](self : Iter[Iter[T]]) -> Iter[T] {\n  fn { yield_ => self.run(fn { x => x.run(yield_) }) }\n}\n\n///|\n/// Applies a function to each element of the iterator without modifying the iterator.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The function to apply to each element of the iterator.\n///\n/// # Returns\n///\n/// The same iterator.\npub fn Iter::tap[T](self : Iter[T], f : (T) -> Unit) -> Iter[T] {\n  self.map(fn {\n    a => {\n      f(a)\n      a\n    }\n  })\n}\n\n///|\n/// Takes the first `n` elements from the iterator.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `n` - The number of elements to take.\n///\n/// # Returns\n///\n/// A new iterator that contains the first `n` elements.\n#intrinsic(\"%iter.take\")\npub fn Iter::take[T](self : Iter[T], n : Int) -> Iter[T] {\n  // [..take(10,seq), next] would continue\n  // even if seq has less than 10 elements\n  // but `for x in [..take(10,seq), next ] { break }` would stop\n  //\n  fn(yield_) {\n    let mut i = 0\n    let mut r = IterContinue\n    self.just_run(fn {\n      a =>\n        if i < n {\n          if yield_(a) == IterContinue {\n            i = i + 1\n            IterContinue\n          } else {\n            r = IterEnd\n            IterEnd\n          }\n        } else {\n          IterEnd\n        }\n    })\n    r\n  }\n}\n\n///|\n/// Takes elements from the iterator as long as the predicate function returns `true`.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element should be taken.\n///\n/// # Returns\n///\n/// A new iterator that contains the elements as long as the predicate function returns `true`.\npub fn Iter::take_while[T](self : Iter[T], f : (T) -> Bool) -> Iter[T] {\n  fn(yield_) {\n    // `r` represents the overall return value.\n    // It is set to `IterEnd` only if `yield_(a)` returns `IterEnd`.\n    // so if `f(a)` returns `false`, it will return `IterEnd`\n    // immediately the iteration of current seq is terminated\n    // but [.. take_while(..), next] would continue\n    // See test \"take_while2\"\n    let mut r : IterResult = IterContinue\n    self.just_run(fn(a) {\n      if f(a) {\n        if yield_(a) == IterContinue {\n          IterContinue\n        } else {\n          r = IterEnd\n          IterEnd\n        }\n      } else {\n        IterEnd\n      }\n    })\n    r\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function upto the function returns `None`.\npub fn Iter::map_while[A, B](self : Iter[A], f : (A) -> B?) -> Iter[B] {\n  fn(yield_) {\n    let mut r : IterResult = IterContinue\n    self.just_run(fn(a) {\n      match f(a) {\n        Some(b) =>\n          if yield_(b) == IterContinue {\n            IterContinue\n          } else {\n            r = IterEnd\n            IterEnd\n          }\n        None => IterEnd\n      }\n    })\n    r\n  }\n}\n\n///|\n/// Skips the first `n` elements from the iterator.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `n` - The number of elements to skip.\n///\n/// # Returns\n///\n/// A new iterator that starts after skipping the first `n` elements.\npub fn Iter::drop[T](self : Iter[T], n : Int) -> Iter[T] {\n  fn(yield_) {\n    let mut i = 0\n    self.run(fn(a) {\n      if i < n {\n        i = i + 1\n        IterContinue\n      } else {\n        yield_(a)\n      }\n    })\n  }\n}\n\n///|\n/// Skips elements from the iterator as long as the predicate function returns `true`.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element should be skipped.\n///\n/// # Returns\n///\n/// A new iterator that starts after skipping the elements as long as the predicate function returns `true`.\npub fn Iter::drop_while[T](self : Iter[T], f : (T) -> Bool) -> Iter[T] {\n  fn(yield_) {\n    let mut dropping = true\n    self.run(fn(a) {\n      if dropping && f(a) {\n        IterContinue\n      } else {\n        dropping = false\n        yield_(a)\n      }\n    })\n  }\n}\n\n///|\n/// Finds the first element in the iterator that satisfies the predicate function.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element is the first element to be found.\n///\n/// # Returns\n///\n/// An `Option` that contains the first element that satisfies the predicate function, or `None` if no such element is found.\npub fn Iter::find_first[T](self : Iter[T], f : (T) -> Bool) -> T? {\n  for a in self {\n    if f(a) {\n      break Some(a)\n    }\n  } else {\n    None\n  }\n}\n\n///|\npub fn Iter::peek[T](self : Iter[T]) -> T? {\n  let mut first = None\n  self.just_run(fn(a) {\n    first = Some(a)\n    IterEnd\n  })\n  first\n}\n\n///|\n/// Prepends a single element to the beginning of the iterator.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `a` - The element to be prepended to the iterator.\n///\n/// # Returns\n///\n/// Returns a new iterator with the element `a` prepended to the original iterator.\npub fn Iter::prepend[T](self : Iter[T], a : T) -> Iter[T] {\n  fn(yield_) {\n    if yield_(a) == IterContinue {\n      self.run(yield_)\n    } else {\n      IterEnd\n    }\n  }\n}\n\n///|\n/// Appends a single element to the end of the iterator.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `a` - The element to be appended to the iterator.\n///\n/// # Returns\n///\n/// Returns a new iterator with the element `a` appended to the original iterator.\npub fn Iter::append[T](self : Iter[T], a : T) -> Iter[T] {\n  fn(yield_) {\n    if self.run(yield_) == IterContinue {\n      yield_(a)\n    } else {\n      IterEnd\n    }\n  }\n}\n\n///|\n/// Combines two iterators into one by appending the elements of the second iterator to the first.\n///\n/// # Type Parameters\n///\n/// - `T`: The type of the elements in the iterators.\n///\n/// # Arguments\n///\n/// * `self` - The first input iterator.\n/// * `other` - The second input iterator to be appended to the first.\n///\n/// # Returns\n///\n/// Returns a new iterator that contains the elements of `self` followed by the elements of `other`.\n#intrinsic(\"%iter.concat\")\npub fn Iter::concat[T](self : Iter[T], other : Iter[T]) -> Iter[T] {\n  fn(yield_) {\n    if self.run(yield_) == IterContinue {\n      other.run(yield_)\n    } else {\n      IterEnd\n    }\n  }\n}\n\n///|\npub impl[T] Add for Iter[T] with op_add(self, other) {\n  Iter::concat(self, other)\n}\n\n///|\n/// Collects the elements of the iterator into an array.\npub fn Iter::to_array[T](self : Iter[T]) -> Array[T] {\n  let result = []\n  for e in self {\n    result.push(e)\n  }\n  result\n}\n\n///|\n/// Collects the elements of the iterator into an array.\npub fn Iter::collect[T](self : Iter[T]) -> Array[T] {\n  let result = []\n  self.each(fn(e) { result.push(e) })\n  result\n}\n\n///|\n/// Collects the elements of the iterator into a string.\npub fn Iter::join(self : Iter[String], sep : String) -> String {\n  let buf = StringBuilder::new()\n  let mut first = true\n  for str in self {\n    if first {\n      first = false\n    } else {\n      buf.write_string(sep)\n    }\n    buf.write_string(str)\n  }\n  buf.to_string()\n}\n\n///|\n/// Iter itself is an iterator.\n/// so that it works with array spread operator. e.g, `[..iter]`\npub fn Iter::iter[T](self : Iter[T]) -> Iter[T] {\n  self\n}\n\n///|\n/// Returns the last element of the iterator, or `None` if the iterator is empty.\npub fn Iter::last[A](self : Iter[A]) -> A? {\n  fn f(_a : A?, b : A) {\n    Some(b)\n  }\n\n  self.fold(init=None, f)\n}\n\n///|\n/// Returns the first element of the iterator, or `None` if the iterator is empty.\n///\n/// # Type Parameters\n///\n/// - `A` : The type of the elements in the iterator.\n///\n/// # Parameters\n///\n/// - `self` : The iterator to retrieve the first element from.\n///\n/// # Returns\n///\n/// - An `Option` containing the first element of the iterator if it exists, otherwise `None`.\n///\n/// # Examples\n///\n/// ```\n/// let iter = Iter::singleton(42)\n/// assert_eq!(iter.head(), Some(42))\n/// ```\npub fn Iter::head[A](self : Iter[A]) -> A? {\n  for i in self {\n    break Some(i)\n  } else {\n    None\n  }\n}\n\n///|\n/// Inserts a separator element `sep` between each element of the iterator.\n///\n/// # Parameters\n///\n/// - `self` : The iterator to intersperse the separator into.\n/// - `sep` : The separator element to insert between each element of the iterator.\n///\n/// # Examples\n///\n/// ```\n/// let arr = []\n/// [1, 2, 3].iter().intersperse(0).each(fn(i) {arr.push(i)})\n/// assert_eq!(arr, [1, 0, 2, 0, 3])\n/// ```\npub fn Iter::intersperse[A](self : Iter[A], sep : A) -> Iter[A] {\n  fn(yield_) {\n    let mut first = true\n    self.run(fn(x) {\n      if first {\n        first = false\n        yield_(x)\n      } else if yield_(sep) == IterEnd {\n        IterEnd\n      } else {\n        yield_(x)\n      }\n    })\n  }\n}\n\n///|\npub fn Iter::op_as_view[A](\n  self : Iter[A],\n  start~ : Int = 0,\n  end? : Int\n) -> Iter[A] {\n  // Note here we mark `end` as an optional parameter\n  // since the meaningful default value of `end` is the length of the iterator\n  // this is time consuming to calculate\n  // while `None` is more appropriate.\n  // In general, when to use `end = expr` and when to use `end?` is a design decision.\n  // when `expr` is always needed when user does not specify, the former is\n  // slightly more efficient. When `expr` is not always needed, the latter is more appropriate.\n  match end {\n    Some(end) => self.drop(start).take(end - start)\n    None => self.drop(start)\n  }\n}\n\n///|\n/// Checks if the iterator contains an element equal to the given value.\n///\n/// Parameters:\n///\n/// * `self` : The iterator to search in.\n/// * `value` : The value to search for.\n///\n/// Returns `true` if the iterator contains an element equal to the given value,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// test \"Iter::contains\" {\n///   let iter = [1, 2, 3, 4, 5].iter()\n///   inspect!(iter.contains(3), content=\"true\")\n///   inspect!(iter.contains(6), content=\"false\")\n/// }\n///\n/// test \"Iter::contains/empty\" {\n///   let iter = Iter::empty()\n///   inspect!(iter.contains(1), content=\"false\")\n/// }\n/// ```\npub fn Iter::contains[A : Eq](self : Iter[A], value : A) -> Bool {\n  for v in self {\n    if v == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Returns the nth element of the iterator, or `None` if the iterator is\n/// shorter than `n` elements.\npub fn Iter::nth[T](self : Iter[T], n : Int) -> T? {\n  self.drop(n).head()\n}\n\n///|\npub fn Iter::maximum[T : Compare](self : Iter[T]) -> T? {\n  let mut res = None\n  for x in self {\n    match res {\n      None => res = Some(x)\n      Some(max) => if x > max { res = Some(x) }\n    }\n  }\n  res\n}\n\n///|\npub fn Iter::minimum[T : Compare](self : Iter[T]) -> T? {\n  let mut res = None\n  for x in self {\n    match res {\n      None => res = Some(x)\n      Some(min) => if x < min { res = Some(x) }\n    }\n  }\n  res\n}\n","///| Url\n/// \n/// ```text\n///  https://example.com:8042/over/there?name=ferret#nose\n///  \\___/   \\______________/\\_________/ \\_________/ \\__/\n///    |            |            |            |        |\n///  scheme     authority       path        query   fragment\n/// ```\n/// \n/// This diagram is from https://package.elm-lang.org/packages/elm/url/latest/Url\npub(all) struct Url {\n  protocol : Protocol\n  host : String\n  port : Int?\n  path : String\n  query : String?\n  fragment : String?\n} derive(Show, Eq, Compare)\n\n///|\npub(all) enum Protocol {\n  Http\n  Https\n  Other(String)\n} derive(Show, Eq, Compare)\n\n///|\npub fn to_string(self : Url) -> String {\n  let protocol = match self.protocol {\n    Http => \"http\"\n    Https => \"https\"\n    _ => panic() // TODO: fix this\n  }\n  let port = match self.port {\n    Some(p) => \":\\{p}\"\n    None => \"\"\n  }\n  let query = match self.query {\n    Some(q) => \"?\\{q}\"\n    None => \"\"\n  }\n  let fragment = match self.fragment {\n    Some(f) => \"#\\{f}\"\n    None => \"\"\n  }\n  \"\\{protocol}://\\{self.host}\\{port}/\\{self.path}\\{query}\\{fragment}\"\n}\n\n///|\npub fn parse(url : String) -> Url!Error {\n  let (protocol, remain) = match url.split(\"://\").collect() {\n    [\"http\", remain] => (Http, remain)\n    [\"https\", remain] => (Https, remain)\n    [x, remain] => (Other(x), remain)\n    [remain] => (Other(\"\"), remain)\n    _ => fail!(\"Invalid protocol\")\n  }\n  let (mid, query_and_fragment) = match remain.split(\"?\").collect() {\n    [mid, remain] => (mid, remain)\n    [mid] => (mid, \"\")\n    _ => fail!(\"Invalid host\")\n  }\n  let (mid_part, fragment1) = match mid.split(\"#\").collect() {\n    [mid, fragment] => (mid, Some(fragment))\n    [mid] => (mid, None)\n    _ => fail!(\"Invalid fragment\")\n  }\n  let (mid, path) = match mid_part.split(\"/\").collect() {\n    [mid] => (mid, \"\")\n    [mid, .. paths] =>\n      (mid, String::concat(paths.iter().collect(), separator=\"/\"))\n    _ => fail!(\"Invalid host\")\n  }\n  let (host, port) = match mid.split(\":\").collect() {\n    [host, port] => {\n      let port = try {\n        @strconv.parse_int!(port)\n      } catch {\n        _ => Option::None\n      } else {\n        number => Some(number)\n      }\n      (host, port)\n    }\n    [host] => (host, None)\n    _ => fail!(\"Invalid host\")\n  }\n  let (query, fragment2) = match query_and_fragment.split(\"#\").collect() {\n    [query, fragment] => (Some(query), Some(fragment))\n    [query] => if query.is_empty() { (None, None) } else { (Some(query), None) }\n    [] => (None, None)\n    _ => fail!(\"Invalid query\")\n  }\n  let fragment = match (fragment1, fragment2) {\n    (Some(f1), Some(f2)) => Some(f1 + \"#\" + f2)\n    (Some(f), None) => Some(f)\n    (None, Some(f)) => Some(f)\n    (None, None) => None\n  }\n  { protocol, host, port, path, query, fragment }\n}\n","///|\nextern type Nullable[_]\n\n///|\npub fn Nullable::is_null[T](self : Nullable[T]) -> Bool {\n  Value::is_null(Value::cast_from(self))\n}\n\n///|\npub fn Nullable::get_exn[T](self : Nullable[T]) -> T = \"%identity\"\n\n///|\npub fn Nullable::to_option[T](self : Nullable[T]) -> T? {\n  guard not(Value::cast_from(self).is_null()) else { None }\n  Some(self.get_exn())\n}\n\n///|\npub fn Nullable::null[T]() -> Nullable[T] {\n  Value::null().cast()\n}\n\n///|\npub fn Nullable::from_option[T](value : T?) -> Nullable[T] {\n  value.map(Value::cast_from).or_else(Value::null).cast()\n}\n","///|\nstruct Sandbox[Msg, Model, View] {\n  mut model : Model\n  update : (Msg, Model) -> (Command[Msg], Model)\n  view : (Model) -> View\n  after_update : (View) -> Unit\n  on_url_changed : ((@url.Url) -> Msg)?\n  on_url_request : ((UrlRequest) -> Msg)?\n  mut predefined : PredefinedEvent?\n}\n\n///| \n// used by vdom\npub(all) struct PredefinedEvent {\n  on_url_changed : (@url.Url) -> Unit\n  on_url_request : (UrlRequest) -> Unit\n}\n\n///|\n// used by vdom\npub fn get_predefined_event[Msg, Model, View](\n  self : Sandbox[Msg, Model, View]\n) -> PredefinedEvent {\n  self.predefined.unwrap()\n}\n\n///|\n// used by vdom\npub fn get_on_url_changed[Msg, Model, View](\n  self : Sandbox[Msg, Model, View]\n) -> ((@url.Url) -> Msg)? {\n  self.on_url_changed\n}\n\n///|\npub fn get_on_url_request[Msg, Model, View](\n  self : Sandbox[Msg, Model, View]\n) -> ((UrlRequest) -> Msg)? {\n  self.on_url_request\n}\n\n///| Update the model and launch commands.\npub fn update[Msg, Model, View](\n  self : Sandbox[Msg, Model, View],\n  message : Msg\n) -> Unit {\n  let (cmd, model) = (self.update)(message, self.model)\n  self.model = model\n  let view = (self.view)(self.model)\n  (self.after_update)(view)\n  // TODO: \n  // The command may trigger another message immediately, causing the VDOM to be generated twice.\n  // We need to optimize this.\n  self.launch(cmd)\n}\n\n///| Refresh the view.\n/// This function will call the view function and patch the result to the DOM.\npub fn refersh[Msg, Model, View](self : Sandbox[Msg, Model, View]) -> Unit {\n  let view = (self.view)(self.model)\n  (self.after_update)(view)\n}\n\n///|\npub fn Sandbox::new[Model, Msg, View](\n  model : Model,\n  update : (Msg, Model) -> (Command[Msg], Model),\n  view : (Model) -> View,\n  after_update~ : (View) -> Unit,\n  url_changed? : (@url.Url) -> Msg,\n  url_request? : (UrlRequest) -> Msg\n) -> Sandbox[Msg, Model, View] {\n  let sandbox = {\n    model,\n    update,\n    view,\n    after_update,\n    on_url_changed: url_changed,\n    on_url_request: url_request,\n    predefined: None,\n  }\n  let on_url_changed = match url_changed {\n    Some(f) => fn(url) { sandbox.update(f(url)) }\n    None => ignore\n  }\n  let on_url_request = match url_request {\n    Some(f) => fn(url) { sandbox.update(f(url)) }\n    None => ignore\n  }\n  @dom.window()\n  .to_event_target()\n  .add_event_listener(\"popstate\", fn(_event) {\n    guard @url.parse?(@dom.window().current_url()) is Ok(url)\n    on_url_changed(url)\n  })\n  sandbox.predefined = Some({ on_url_changed, on_url_request })\n  sandbox\n}\n","///|\npub(all) type Command[M] (PredefinedEvent, (M) -> Unit) -> Unit\n\n///| Map the messages in the command to another type.\npub fn map[A, B](self : Command[A], f : (A) -> B) -> Command[B] {\n  Command(fn(predef, update) {\n    let update = fn(msg) { update(f(msg)) }\n    let Command(f) = self\n    f(predef, update)\n  })\n}\n\n///| Launch commands. It may trigger the update function.\npub fn launch[M, Model, View](\n  self : Sandbox[M, Model, View],\n  cmd : Command[M]\n) -> Unit {\n  let f = cmd._\n  let update = fn(m) { self.update(m) }\n  f(self.predefined.unwrap(), update)\n}\n\n///|\npub fn none[M]() -> Command[M] {\n  Command(fn { _, _ => () })\n}\n\n///|\npub fn batch[M](xs : Array[Command[M]]) -> Command[M] {\n  Command(fn(predef, update) { xs.each(fn { Command(f) => f(predef, update) }) })\n}\n\n///|\npub fn task[M](message : M) -> Command[M] {\n  Command(fn(_, update) { update(message) })\n}\n\n///|\npub fn perform[A, M](msg : (A) -> M, f : async () -> A) -> Command[M] {\n  Command(fn(_, update) { @js.async_run(fn() { update(msg(f!!())) }) })\n}\n\n///|\npub fn attempt[A, E : Error, M](\n  msg : (Result[A, E]) -> M,\n  f : async () -> A!E\n) -> Command[M] {\n  Command(fn(_, update) {\n    @js.async_run(fn() {\n      let msg = try {\n        f!!()\n      } catch {\n        e => msg(Err(e))\n      } else {\n        r => msg(Ok(r))\n      }\n      update(msg)\n    })\n  })\n}\n","///|\nenum Node[Msg] {\n  Node(\n    String,\n    attrs~ : Array[Attribute[Msg]],\n    childrens~ : Array[Node[Msg]],\n    // Store the event listener used in real DOM\n    listeners~ : Array[(String, @dom.Listener)]\n  )\n  ExternalNode(\n    @dom.Node,\n    Ref[Array[Attribute[Msg]]?],\n    width~ : Int,\n    height~ : Int\n  )\n  Text(String)\n  Nothing\n}\n\n///| Convert msg type of Node.\n/// \n/// This is a expensive operation and should be used rarely.\npub fn map[A, B](self : Node[A], f : (A) -> B) -> Node[B] {\n  match self {\n    Node(tag, attrs~, childrens~, listeners~) => {\n      let attrs = attrs.map(fn(x) { x.map(f) })\n      let childrens = childrens.map(fn(x) { x.map(f) })\n      Node(tag, attrs~, childrens~, listeners~)\n    }\n    ExternalNode(node, attrs, width~, height~) => {\n      let attrs = attrs.map(fn(opt) {\n        opt.map(fn(attrs) { attrs.map(fn(x) { x.map(f) }) })\n      })\n      ExternalNode(node, attrs, width~, height~)\n    }\n    Text(value) => Text(value)\n    Nothing => Nothing\n  }\n}\n\n///| Create a DOM node \npub fn node[Msg](\n  tag : String,\n  attrs : Array[Attribute[Msg]],\n  childrens : Array[Node[Msg]]\n) -> Node[Msg] {\n  Node(tag, attrs~, childrens~, listeners=[])\n}\n\n///|\npub fn external[Msg](\n  node : @dom.Node,\n  attrs : Ref[Array[Attribute[Msg]]?],\n  width~ : Int,\n  height~ : Int\n) -> Node[Msg] {\n  ExternalNode(node, attrs, width~, height~)\n}\n\n///| Create a plain text\npub fn text[Msg](value : String) -> Node[Msg] {\n  Text(value)\n}\n\n///| Create a dummy node\npub fn nothing[Msg]() -> Node[Msg] {\n  Nothing\n}\n\n///|\ntype Attribute[Msg] (String, AttrValue[Msg])\n\n///|\npriv enum AttrValue[Msg] {\n  AttrEvent(Handler[Msg])\n  AttrStyle(String)\n  AttrString(String)\n  // NOTE: Property is used to set the property of the element, this is different \n  // from the AttrString, which set the attribute of the element.\n  // See https://github.com/elm/html/blob/master/properties-vs-attributes.md\n  //\n  // Further more, the behavior of property may be different with attribute, even \n  // they have the same name. For example, if you set the `href` by `setAttribute`, the\n  // `href` will be the value you specified, but by property, the value will be \n  // resolved to an absolute URL. \n  AttrProperty(String)\n}\n\n///|\npub(all) enum Handler[Msg] {\n  Normal(Msg)\n  HandleEvent((@dom.Event) -> Msg)\n  Custom(Msg, stop_propagation~ : Bool, prevent_default~ : Bool)\n}\n\n///|\nfn is_same_type[Msg](x : Node[Msg], y : Node[Msg]) -> Bool {\n  match (x, y) {\n    (Node(_), Node(_)) => true\n    (Text(_), Text(_)) => true\n    (Nothing, Nothing) => true\n    (ExternalNode(_), ExternalNode(_)) => true\n    _ => false\n  }\n}\n\n///|\nimpl[Msg] Eq for Handler[Msg] with op_equal(_a, _b) {\n  false // TODO: implement this\n}\n\n///|\nimpl[Msg] Eq for AttrValue[Msg] with op_equal(_a, _b) {\n  false // TODO: implement this\n}\n\n///|\nimpl[Msg] Eq for Attribute[Msg] with op_equal(_a, _b) {\n  false // TODO: implement this\n}\n\n///|\npub fn Handler::map[A, B](self : Handler[A], f : (A) -> B) -> Handler[B] {\n  match self {\n    Normal(msg) => Normal(f(msg))\n    HandleEvent(g) => HandleEvent(fn(event) { g(event) |> f })\n    Custom(msg, stop_propagation~, prevent_default~) =>\n      Custom(f(msg), stop_propagation~, prevent_default~)\n  }\n}\n\n///|\npub fn Attribute::map[A, B](self : Attribute[A], f : (A) -> B) -> Attribute[B] {\n  let Attribute((key, value)) = self\n  let value = match value {\n    AttrEvent(handler) => AttrEvent(handler.map(f))\n    AttrStyle(value) => AttrStyle(value)\n    AttrString(value) => AttrString(value)\n    AttrProperty(value) => AttrProperty(value)\n  }\n  Attribute((key, value))\n}\n\n///| Create an custom event handler\npub fn on[Msg](event : String, handler : Handler[Msg]) -> Attribute[Msg] {\n  (event, AttrEvent(handler))\n}\n\n///| Create an attribute\npub fn attribute[Msg](key : String, value : String) -> Attribute[Msg] {\n  (key, AttrString(value))\n}\n\n///| Create an property\npub fn property[Msg](key : String, value : String) -> Attribute[Msg] {\n  (key, AttrProperty(value))\n}\n\n///| Create an style attribute\npub fn style[Msg](key : String, value : String) -> Attribute[Msg] {\n  (key, AttrStyle(value))\n}\n\n///| Convert virtual DOM to real DOM\nfn to_node[Msg, Model, View](\n  self : Node[Msg],\n  sandbox : @adapter.Sandbox[Msg, Model, View]\n) -> @dom.Node {\n  // NOTE:\n  // In Elm, the sandbox is a spacial type and handled in the runtime. But in Moonbit,\n  // the sandbox is just a normal type and handled in the user code. Because any operation\n  // in TEA require the state of sandbox, it cause the type parameter like Msg, Model, View \n  // to be passed around in API, very painful.\n  // \n  // This function require a sandbox value, and use closure to eliminate the type parameter.\n  fn attach_attrs(\n    attrs : Array[Attribute[Msg]],\n    element : @dom.Element,\n    generated_listeners : Array[(String, @dom.Listener)]\n  ) {\n    attrs.each(fn {\n      Attribute((event, AttrEvent(handler))) => {\n        let listener = match handler {\n          Normal(msg) => fn(_event) { sandbox.update(msg) }\n          HandleEvent(f) => fn(event) { sandbox.update(f(event)) }\n          Custom(msg, stop_propagation~, prevent_default~) =>\n            fn(event : @dom.Event) { // TODO: remove this annotation will cause type error, why?\n              if stop_propagation {\n                event.stop_propagation()\n              }\n              if prevent_default {\n                event.prevent_default()\n              }\n              sandbox.update(msg)\n            }\n        }\n        element.to_node().to_event_target().add_event_listener(event, listener)\n        generated_listeners.push((event, listener))\n      }\n      Attribute((key, AttrString(value))) => element.set_attribute(key, value)\n      Attribute((key, AttrStyle(value))) =>\n        element.to_html_element().get_exn().set_style(key, value)\n      Attribute((key, AttrProperty(value))) => element.set_property(key, value)\n    })\n  }\n\n  match self {\n    Node(tag, attrs~, childrens~, listeners~) => {\n      let element = @dom.document().create_element(tag)\n      attach_attrs(attrs, element, listeners)\n      // NOTE:\n      // This is important for those who want to write a router in the app. \n      // When the `a` tag is clicked, the href is parsed and wrapped in \n      // the `url_request` message, then resent to the update function. \n      //\n      // If the `url_request` message was not provided, let the browser \n      // handle the click event.\n      match (sandbox.get_on_url_request(), tag) {\n        (Some(url_request), \"a\") =>\n          element\n          .to_node()\n          .to_event_target()\n          .add_event_listener(\"click\", fn(event) {\n            event.prevent_default()\n            let href = element.get_property(\"href\")\n            guard @url.parse?(@dom.window().current_url()) is Ok(curr)\n            guard @url.parse?(href) is Ok(next)\n            let request = if curr.protocol == next.protocol &&\n              curr.host == next.host &&\n              curr.port == next.port {\n              @adapter.Internal(next)\n            } else {\n              External(href)\n            }\n            sandbox.update(url_request(request))\n          })\n        _ => ()\n      }\n      for child in childrens {\n        element.to_node().append_child(to_node(child, sandbox))\n      }\n      element.to_node()\n    }\n    ExternalNode(node, attrs, width~, height~) => {\n      match attrs.val {\n        Some(xs) => {\n          attach_attrs(xs, node.to_element().to_option().unwrap(), [])\n          attrs.val = None\n        }\n        None => ()\n      }\n      let element = @dom.document().create_element(\"div\")\n      element.to_html_element().get_exn().set_style(\"width\", width.to_string())\n      element\n      .to_html_element()\n      .get_exn()\n      .set_style(\"height\", height.to_string())\n      element..append_children(node.to_element().to_option().unwrap()).to_node()\n    }\n    Text(value) => @dom.document().create_text_node(value).to_node()\n    Nothing => @dom.document().create_text_node(\"\").to_node()\n  }\n}\n\n///|\npub fn patch[Msg, Model, View](\n  self : Node[Msg],\n  old : Node[Msg],\n  sandbox : @adapter.Sandbox[Msg, Model, View],\n  mount~ : String\n) -> Unit {\n  let patches = diff(old, self)\n  fn aux(patches : Patch[Msg], current : @dom.Node) -> Unit {\n    match patches {\n      Drop(index, length) =>\n        for i in 0..<length {\n          current.remove_child(current.nth_child(index))\n        }\n      Remove(index) => current.remove_child(current.nth_child(index))\n      Replace(index, node) =>\n        current.replace_child(node.to_node(sandbox), current.nth_child(index))\n      InsertBefore(index, node) =>\n        if current.count_child() == 0 {\n          current.append_child(node.to_node(sandbox))\n        } else {\n          current.insert_before(node.to_node(sandbox), current.nth_child(index))\n        }\n      Append(nodes) =>\n        for node in nodes {\n          current.append_child(node.to_node(sandbox))\n        }\n      Update(update) =>\n        match update {\n          UpdateNode(index, attrs_patches, childs_patches, new_listeners) => {\n            let node = current.nth_child(index)\n            let element = node.to_element().get_exn()\n            for patch in attrs_patches {\n              match patch {\n                AttrRemove(key) => element.remove_attribute(key)\n                AttrAdd(key, value) => element.set_attribute(key, value)\n                StyleAdd(key, value) =>\n                  element.to_html_element().get_exn().set_style(key, value)\n                StyleRemove(key) =>\n                  element.to_html_element().get_exn().remove_style(key)\n                PropertyAdd(key, value) => element.set_property(key, value)\n                PropertyRemove(key) => element.remove_property(key)\n                EventRemove(key, listener) =>\n                  element\n                  .to_node()\n                  .to_event_target()\n                  .remove_event_listener(key, listener)\n                EventAdd(key, handler) => {\n                  let listener = match handler {\n                    Normal(msg) => fn(_event) { sandbox.update(msg) }\n                    HandleEvent(f) => fn(event) { sandbox.update(f(event)) }\n                    Custom(msg, stop_propagation~, prevent_default~) =>\n                      fn(event : @dom.Event) {\n                        if stop_propagation {\n                          event.stop_propagation()\n                        }\n                        if prevent_default {\n                          event.prevent_default()\n                        }\n                        sandbox.update(msg)\n                      }\n                  }\n                  element\n                  .to_node()\n                  .to_event_target()\n                  .add_event_listener(key, listener)\n                  new_listeners.push((key, listener))\n                }\n              }\n            }\n            for patch in childs_patches {\n              aux(patch, node)\n            }\n          }\n          UpdateText(index, value) => {\n            let text_node = @dom.document().create_text_node(value)\n            current.replace_child(text_node.to_node(), current.nth_child(index))\n          }\n        }\n    }\n  }\n\n  let root = @dom.document().get_element_by_id(mount).get_exn().to_node()\n  aux(patches, root)\n}\n\n///|\npriv enum AttrsUpdate[Msg] {\n  AttrRemove(String)\n  AttrAdd(String, String)\n  StyleAdd(String, String)\n  StyleRemove(String)\n  PropertyAdd(String, String)\n  PropertyRemove(String)\n  EventRemove(String, @dom.Listener)\n  EventAdd(String, Handler[Msg])\n}\n\n///|\nenum Patch[Msg] {\n  Drop(Int, Int)\n  Remove(Int)\n  Replace(Int, Node[Msg])\n  InsertBefore(Int, Node[Msg])\n  Append(Array[Node[Msg]])\n  Update(Update[Msg])\n}\n\n///|\ntest {\n  // TODO: this is used to suppress unused warnings. Remove this later.\n  ignore((Patch::Remove : (Int) -> Patch[Unit]))\n  ignore((Patch::InsertBefore : (Int, Node[Unit]) -> Patch[Unit]))\n}\n\n///|\npriv enum Update[Msg] {\n  UpdateNode(\n    Int,\n    Array[AttrsUpdate[Msg]],\n    Array[Patch[Msg]],\n    Array[(String, @dom.Listener)]\n  )\n  UpdateText(Int, String)\n}\n\n///|\n/// Now the root node must be a Node\npub fn diff[Msg](root_old : Node[Msg], root_new : Node[Msg]) -> Patch[Msg] {\n  guard root_old is Node(_, attrs=attrs_old, listeners~, ..)\n  guard root_new is Node(_, attrs=attrs_new, ..)\n  Update(\n    UpdateNode(\n      0,\n      attrs_diff(attrs_old, attrs_new, listeners),\n      do_diff(root_old, root_new),\n      [],\n    ),\n  )\n}\n\n///|\npub fn do_diff[Msg](old : Node[Msg], new : Node[Msg]) -> Array[Patch[Msg]] {\n  let childrens_old = match old {\n    Node(_, childrens~, ..) => childrens\n    _ => abort(\"old is not a node or fragment\")\n  }\n  let childrens_new = match new {\n    Node(_, childrens~, ..) => childrens\n    _ => abort(\"new is not a node or fragment\")\n  }\n  if childrens_old.length() == 0 && childrens_new.length() == 0 {\n    []\n  } else {\n    diff_without_key(childrens_old, childrens_new)\n  }\n}\n\n// To be improved!!! Now this implementation will affect the performance of the diff algorithm.\n// And If a AttributeString's name is same as a AttrEvent's name, the diff algorithm will not work.\n// Now we think the events is different although they never changed.\n///|\nfn attrs_diff[Msg](\n  old : Array[Attribute[Msg]],\n  new : Array[Attribute[Msg]],\n  // We think the event is different although they never changed.\n  // The listeners is used to remove the event listener when the attribute is removed.\n  listeners : Array[(String, @dom.Listener)]\n) -> Array[AttrsUpdate[Msg]] {\n  let old_map = Map::from_iter(old.iter().map(fn(attr) { attr._ }))\n  let new_map = Map::from_iter(new.iter().map(fn(attr) { attr._ }))\n  let result = []\n  for x in listeners {\n    result.push(EventRemove(x.0, x.1))\n  }\n  for key, value in old_map {\n    match value {\n      // We think the event is different although they never changed.\n      AttrEvent(_) => ()\n      AttrStyle(value) =>\n        if new_map.contains(key) {\n          // FIXME: avoid unwrap and guard let\n          guard new_map.get(key).unwrap() is AttrStyle(value_new)\n          if value != value_new {\n            result.push(StyleAdd(key, value_new))\n          }\n        } else {\n          result.push(StyleRemove(key))\n        }\n      AttrString(value) =>\n        if new_map.contains(key) {\n          // FIXME: avoid unwrap and guard let\n          guard new_map.get(key).unwrap() is AttrString(value_new)\n          if value != value_new {\n            result.push(AttrAdd(key, value_new))\n          }\n        } else {\n          result.push(AttrRemove(key))\n        }\n      AttrProperty(value) =>\n        if new_map.contains(key) {\n          // FIXME: avoid unwrap and guard let\n          guard new_map.get(key).unwrap() is AttrProperty(value_new)\n          if value != value_new {\n            result.push(PropertyAdd(key, value_new))\n          }\n        } else {\n          result.push(PropertyRemove(key))\n        }\n    }\n  }\n  for key, value in new_map {\n    match value {\n      // We think the event is different although they never changed.\n      AttrEvent(handler) => result.push(EventAdd(key, handler))\n      AttrStyle(value) =>\n        if not(old_map.contains(key)) {\n          result.push(StyleAdd(key, value))\n        }\n      AttrString(value) =>\n        if not(old_map.contains(key)) {\n          result.push(AttrAdd(key, value))\n        }\n      AttrProperty(value) =>\n        if not(old_map.contains(key)) {\n          result.push(PropertyAdd(key, value))\n        }\n    }\n  }\n  result\n}\n\n///|\npub fn diff_without_key[Msg](\n  old : Array[Node[Msg]],\n  new : Array[Node[Msg]]\n) -> Array[Patch[Msg]] {\n  fn aux(\n    xs : ArrayView[Node[Msg]],\n    ys : ArrayView[Node[Msg]],\n    patches : Array[Patch[Msg]],\n    index : Int\n  ) -> Unit {\n    match (xs, ys) {\n      ([], []) => ()\n      ([], tl) => patches.push(Append(tl.map(fn(x) { x })))\n      (l, []) => patches.push(Drop(index, l.length()))\n      ([x, .. tl1], [y, .. tl2]) => {\n        if is_same_type(x, y) {\n          match (x, y) {\n            (\n              Node(taga, attrs=xattrs, listeners~, ..),\n              Node(tagb, attrs=yattrs, listeners=new_listeners, ..),\n            ) =>\n              if taga == tagb {\n                let attrs_patches = attrs_diff(xattrs, yattrs, listeners)\n                let childs_patches = do_diff(x, y)\n                if attrs_patches.length() > 0 || childs_patches.length() > 0 {\n                  patches.push(\n                    Update(\n                      UpdateNode(\n                        index, attrs_patches, childs_patches, new_listeners,\n                      ),\n                    ),\n                  )\n                }\n              } else {\n                patches.push(Replace(index, y))\n              }\n            (ExternalNode(_), ExternalNode(_)) =>\n              patches.push(Replace(index, y))\n            (Text(value_a), Text(value_b)) =>\n              if value_a != value_b {\n                patches.push(Update(UpdateText(index, value_b)))\n              }\n            _ => ()\n          }\n        } else {\n          patches.push(Replace(index, y))\n        }\n        aux(tl1, tl2, patches, index + 1)\n      }\n    }\n  }\n\n  let patches = []\n  aux(old[:], new[:], patches, 0)\n  patches\n}\n","///|\ntype T[Msg] @vdom.Node[Msg]\n\n///|\npub typealias Html[Msg] = T[Msg]\n\n///| Convert msg type of Html.\n/// \n/// This is a expensive operation and should be used rarely.\npub fn map[A, B](self : Html[A], f : (A) -> B) -> Html[B] {\n  self._.map(f)\n}\n\n///|\npub fn to_virtual_dom[Msg](self : Html[Msg]) -> @vdom.Node[Msg] {\n  // Wrap the node with a root node. This node represents the root of the real DOM managed by TEA.\n  node(\"root\", [], [self])._\n}\n\n///|\nfn new[Msg](\n  tag : String,\n  attrs : Map[String, String],\n  style? : Array[String],\n  class? : String,\n  id? : String,\n  optional_attrs~ : Map[String, String?] = {},\n  attributes~ : Array[Attribute[Msg]] = [],\n  optional_attributes~ : Array[Attribute[Msg]?] = [],\n  events~ : Map[String, Msg?] = {},\n  childrens : Array[Html[Msg]]\n) -> Html[Msg] {\n  let attrs = attrs.to_array().map(fn(p) { attribute(p.0, p.1) })\n  attrs.push_iter(attributes.iter())\n  optional_attributes.each(fn {\n    Some(attr) => attrs.push(attr)\n    None => ()\n  })\n  optional_attrs.each(fn {\n    k, Some(v) => attrs.push(attribute(k, v))\n    _, None => ()\n  })\n  match style {\n    Some(style) =>\n      attrs.push(attribute(\"style\", String::concat(style, separator=\";\")))\n    None => ()\n  }\n  match class {\n    Some(class) => attrs.push(attribute(\"class\", class))\n    None => ()\n  }\n  match id {\n    Some(id) => attrs.push(attribute(\"id\", id))\n    None => ()\n  }\n  events.each(fn {\n    k, Some(v) => attrs.push(@vdom.on(k, Normal(v)))\n    _, None => ()\n  })\n  node(tag, attrs, childrens)\n}\n\n///| \npub fn node[Msg](\n  tag : String,\n  attributes : Array[Attribute[Msg]],\n  childrens : Array[Html[Msg]]\n) -> Html[Msg] {\n  @vdom.node(tag, attributes.map(fn(x) { x._ }), childrens.map(fn(x) { x._ }))\n}\n\n///| Represents an empty element\npub fn nothing[M]() -> Html[M] {\n  @vdom.nothing()\n}\n\n///|\npub fn button[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  click? : M,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\n    \"button\",\n    {},\n    style~,\n    class?,\n    id?,\n    events={ \"click\": click.map(fn(m) { m }) },\n    childrens,\n  )\n}\n\n///|\npub fn h1[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"h1\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn h2[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"h2\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn h3[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"h3\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn h4[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"h4\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn h5[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"h5\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn h6[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"h6\", {}, style~, class?, id?, childrens)\n}\n\n// ------ grouping content ------\n\n///|\npub fn div[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  click? : M,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\n    \"div\",\n    {},\n    style~,\n    class?,\n    id?,\n    events={ \"click\": click.map(fn(m) { m }) },\n    childrens,\n  )\n}\n\n///|\npub fn p[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"p\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn hr[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens~ : Array[Html[M]] = []\n) -> Html[M] {\n  new(\"hr\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn pre[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"pre\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn blockquote[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"blockquote\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn section[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"section\", {}, style~, class?, id?, childrens)\n}\n\n// ---- text ----\n\n///|\npub fn span[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"span\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn a[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  href~ : String,\n  target~ : Target = Self,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"a\", { \"href\": href }, style~, class?, id?, childrens, attributes=[\n    attribute(\"target\", target.to_string()),\n  ])\n}\n\n///|\npub fn code[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"code\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn em[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"em\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn strong[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"strong\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn i[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"i\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn b[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"b\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn u[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"u\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn sub[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"sub\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn sup[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"sup\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn text[Msg](str : String) -> Html[Msg] {\n  @vdom.text(str)\n}\n\n// ---- lists ----\n\n///|\npub fn ul[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  click? : M,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"ul\", {}, style~, class?, id?, childrens, events={\n    \"click\": click.map(fn(m) { m }),\n  })\n}\n\n///|\n/// Notice that the `type` attribute for `ol` is not important for the browser now.\n/// If you want to change the type of the list, you should use the `list-style-type` property in CSS.\npub fn ol[M](\n  style~ : Array[String] = [],\n  reversed? : Bool,\n  start? : Int,\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\n    \"ol\",\n    {},\n    style~,\n    class?,\n    id?,\n    optional_attrs={\n      \"reversed\": reversed.map(Bool::to_string),\n      \"start\": start.map(fn(n) { n.to_string() }),\n    },\n    childrens,\n  )\n}\n\n///|\npub fn li[M](\n  style~ : Array[String] = [],\n  value? : Int,\n  id? : String,\n  class? : String,\n  click? : M,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\n    \"li\",\n    {},\n    style~,\n    class?,\n    id?,\n    optional_attrs={ \"value\": value.map(fn(n) { n.to_string() }) },\n    childrens,\n    events={ \"click\": click.map(fn(m) { m }) },\n  )\n}\n\n///|\npub fn dl[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"dl\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn dt[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"dt\", {}, style~, class?, id?, childrens)\n}\n\n///|\npub fn dd[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"dd\", {}, style~, class?, id?, childrens)\n}\n\n// ---- embbded content ----\n\n///|\npub fn img[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  src? : String,\n  alt? : String,\n  title? : String,\n  width? : Int,\n  height? : Int,\n  border? : Int,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\n    \"img\",\n    {},\n    style~,\n    class?,\n    id?,\n    optional_attrs={\n      \"src\": src,\n      \"alt\": alt,\n      \"title\": title,\n      \"width\": width.map(fn(x) { x.to_string() }),\n      \"height\": height.map(fn(x) { x.to_string() }),\n      \"border\": border.map(fn(x) { x.to_string() }),\n    },\n    childrens,\n  )\n}\n\n///|\npub fn iframe[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  src? : String,\n  title? : String,\n  width? : Int,\n  height? : Int\n) -> Html[M] {\n  new(\n    \"iframe\",\n    {},\n    style~,\n    class?,\n    id?,\n    optional_attrs={\n      \"src\": src,\n      \"title\": title,\n      \"width\": width.map(fn(x) { x.to_string() }),\n      \"height\": height.map(fn(x) { x.to_string() }),\n    },\n    [],\n  )\n}\n\n// ---- inputs ----\n\n///|\npub fn br[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String\n) -> Html[M] {\n  new(\"br\", {}, style~, class?, id?, [])\n}\n\n///|\npub(all) enum InputType {\n  Button\n  Checkbox\n  Color\n  Date\n  DateTimeLocal\n  Email\n  File\n  Hidden\n  Image\n  Month\n  Number\n  Password\n  Radio\n  Range\n  Reset\n  Search\n  Submit\n  Tel\n  Text\n  Time\n  Url\n  Week\n}\n\n///|\npub(all) enum AutoComplete {\n  On\n  Off\n}\n\n///|\npub fn form[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  action? : String,\n  name? : String,\n  children : Array[Html[M]]\n) -> Html[M] {\n  new(\n    \"form\",\n    {},\n    style~,\n    id?,\n    class?,\n    optional_attrs={ \"action\": action, \"name\": name },\n    children,\n  )\n}\n\n///|\npub fn label[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  for_? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\n    \"label\",\n    {},\n    optional_attrs={ \"for\": for_ },\n    style~,\n    class?,\n    id?,\n    childrens,\n  )\n}\n\n///|\npub fn input[M](\n  input_type~ : InputType = Text,\n  name? : String,\n  value? : String,\n  checked? : Bool,\n  read_only? : Bool,\n  multiple? : Bool,\n  accept? : String,\n  placeholder? : String,\n  auto_complete? : AutoComplete,\n  style~ : Array[String] = [],\n  max? : Int,\n  min? : Int,\n  step? : Int,\n  maxlength? : Int,\n  minlength? : Int,\n  pattern? : String,\n  size? : Int,\n  width? : Int,\n  height? : Int,\n  id? : String,\n  class? : String,\n  childrens~ : Array[Html[M]] = [],\n  change? : (String) -> M,\n  input? : (String) -> M\n) -> Html[M] {\n  let input_type = match input_type {\n    Button => \"button\"\n    Checkbox => \"checkbox\"\n    Color => \"color\"\n    Date => \"date\"\n    DateTimeLocal => \"datetime-local\"\n    Email => \"email\"\n    File => \"file\"\n    Hidden => \"hidden\"\n    Image => \"image\"\n    Month => \"month\"\n    Number => \"number\"\n    Password => \"password\"\n    Radio => \"radio\"\n    Range => \"range\"\n    Reset => \"reset\"\n    Search => \"search\"\n    Submit => \"submit\"\n    Tel => \"tel\"\n    Text => \"text\"\n    Time => \"time\"\n    Url => \"url\"\n    Week => \"week\"\n  }\n  let auto_complete = match auto_complete {\n    Some(On) => \"on\"\n    _ => \"off\"\n  }\n  new(\n    \"input\",\n    { \"type\": input_type, \"autocomplete\": auto_complete },\n    optional_attrs={\n      \"name\": name,\n      \"value\": value,\n      \"checked\": checked.map(Bool::to_string),\n      \"readonly\": read_only.map(Bool::to_string),\n      \"multiple\": multiple.map(Bool::to_string),\n      \"accept\": accept,\n      \"max\": max.map(fn(n) { n.to_string() }),\n      \"min\": min.map(fn(n) { n.to_string() }),\n      \"step\": step.map(fn(n) { n.to_string() }),\n      \"maxlength\": maxlength.map(fn(n) { n.to_string() }),\n      \"minlength\": minlength.map(fn(n) { n.to_string() }),\n      \"pattern\": pattern,\n      \"size\": size.map(fn(n) { n.to_string() }),\n      \"width\": width.map(fn(n) { n.to_string() }),\n      \"height\": height.map(fn(n) { n.to_string() }),\n      \"placeholder\": placeholder,\n    },\n    optional_attributes=[change.map(on_change), input.map(on_input)],\n    style~,\n    id?,\n    class?,\n    childrens,\n  )\n}\n\n///|\npub fn external[Msg](\n  node : @dom.Node,\n  attrs : Ref[Array[Attribute[Msg]]?],\n  width~ : Int,\n  height~ : Int\n) -> Html[Msg] {\n  let attrs = attrs.map(fn(opt) { opt.map(fn(arr) { arr.map(fn(a) { a._ }) }) })\n  @vdom.external(node, attrs, width~, height~)\n}\n\n// table\n\n///|\npub fn table[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"table\", {}, style~, id?, class?, childrens)\n}\n\n///|\npub fn caption[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"caption\", {}, style~, id?, class?, childrens)\n}\n\n///|\npub fn thead[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"thead\", {}, style~, id?, class?, childrens)\n}\n\n///|\npub fn tbody[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"tbody\", {}, style~, id?, class?, childrens)\n}\n\n///|\npub fn col[M](\n  style~ : Array[String] = [],\n  id? : String,\n  span? : Int,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\n    \"col\",\n    {},\n    style~,\n    id?,\n    class?,\n    optional_attrs={ \"span\": span.map(fn(n) { n.to_string() }) },\n    childrens,\n  )\n}\n\n///|\npub fn colgroup[M](\n  style~ : Array[String] = [],\n  id? : String,\n  span? : Int,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\n    \"colgroup\",\n    {},\n    style~,\n    id?,\n    class?,\n    optional_attrs={ \"span\": span.map(fn(n) { n.to_string() }) },\n    childrens,\n  )\n}\n\n///|\npub fn tr[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"tr\", {}, style~, id?, class?, childrens)\n}\n\n///|\npub fn td[M](\n  style~ : Array[String] = [],\n  id? : String,\n  colspan? : Int,\n  rowspan? : Int,\n  headers? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\n    \"td\",\n    {},\n    style~,\n    id?,\n    class?,\n    optional_attrs={\n      \"colspan\": colspan.map(fn(n) { n.to_string() }),\n      \"rowspan\": rowspan.map(fn(n) { n.to_string() }),\n      \"headers\": headers,\n    },\n    childrens,\n  )\n}\n\n///|\npub(all) enum Scope {\n  Row\n  Col\n  RowGroup\n  ColGroup\n}\n\n///|\npub fn th[M](\n  style~ : Array[String] = [],\n  id? : String,\n  abbr? : String,\n  colspan? : Int,\n  rowspan? : Int,\n  headers? : String,\n  scope? : Scope,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\n    \"th\",\n    {},\n    style~,\n    id?,\n    class?,\n    optional_attrs={\n      \"abbr\": abbr,\n      \"colspan\": colspan.map(fn(n) { n.to_string() }),\n      \"rowspan\": rowspan.map(fn(n) { n.to_string() }),\n      \"headers\": headers,\n      \"scope\": scope.map(fn(s) {\n        match s {\n          Row => \"row\"\n          Col => \"col\"\n          RowGroup => \"rowgroup\"\n          ColGroup => \"colgroup\"\n        }\n      }),\n    },\n    childrens,\n  )\n}\n\n///|\npub fn tfoot[M](\n  style~ : Array[String] = [],\n  id? : String,\n  class? : String,\n  childrens : Array[Html[M]]\n) -> Html[M] {\n  new(\"tfoot\", {}, style~, id?, class?, childrens)\n}\n","///|\ntype Attribute[Msg] @vdom.Attribute[Msg]\n\n///| Specify an style\npub fn style[Msg](key : String, value : String) -> Attribute[Msg] {\n  @vdom.style(key, value)\n}\n\n///|\npub fn attribute[Msg](key : String, value : String) -> Attribute[Msg] {\n  @vdom.attribute(key, value)\n}\n\n///|\npub fn href[Msg](value : String) -> Attribute[Msg] {\n  // Note: `href` will be the value you specified, but by property, the value \n  // will be resolved to an absolute URL.\n  @vdom.property(\"href\", value)\n}\n\n///|\npub(all) enum Target {\n  Self\n  Blank\n}\n\n///|\nfn to_string(self : Target) -> String {\n  match self {\n    Self => \"_self\"\n    Blank => \"_blank\"\n  }\n}\n\n///|\npub fn target[Msg](value : Target) -> Attribute[Msg] {\n  @vdom.attribute(\"target\", value.to_string())\n}\n","///|\npub typealias Command[M] = @browser.Command[M]\n\n///|\npub fn none[M]() -> Command[M] {\n  @browser.none()\n}\n\n///|\npub fn batch[M](xs : Array[Command[M]]) -> Command[M] {\n  @browser.batch(xs)\n}\n\n///|\npub fn task[M](message : M) -> Command[M] {\n  @browser.task(message)\n}\n\n///|\npub fn perform[A, M](msg : (A) -> M, f : async () -> A) -> Command[M] {\n  @browser.perform(msg, f)\n}\n\n///|\npub fn attempt[A, E : Error, M](\n  msg : (Result[A, E]) -> M,\n  f : async () -> A!E\n) -> Command[M] {\n  @browser.attempt(msg, f)\n}\n\n///| Start the application.\n/// \n/// - `model` is the state of your application.\n/// - `view` is a way to turn your model into HTML.\n/// - `update` a way to update your state based on messages.\n/// \n/// These three are the core of the TEA. Rabbit-TEA is highly unstable at this time, \n/// but it follows the same pattern as Elm. You can visit https://guide.elm-lang.org/ \n/// to get more intuition!\n/// \n/// To start the application with router, you can use the `application` function.\npub fn startup[Model, Message](\n  model~ : Model,\n  update~ : (Message, Model) -> (Command[Message], Model),\n  view~ : (Model) -> @html.Html[Message],\n  mount~ : String = \"app\"\n) -> Unit {\n  @dom.document()\n  .get_element_by_id(mount)\n  .get_exn()\n  .set_inner_html(\"<div></div>\")\n  let mut sandbox = None\n  let mut curr_dom = @vdom.node(\"div\", [], [])\n  fn after_update(html : @html.Html[Message]) {\n    guard sandbox is Some(sandbox)\n    let new_dom = html.to_virtual_dom()\n    new_dom.patch(curr_dom, sandbox, mount~)\n    curr_dom = new_dom\n  }\n\n  sandbox = Some(@browser.Sandbox::new(model, update, view, after_update~))\n  sandbox.unwrap().refersh()\n}\n\n///| Start the application with initial URL. \n/// \n/// - `url_changed` is a message that will be passed when the URL is changed by the navigation API in the `@browser` package.\n/// - `url_request` is a message that will be passed when an `<a>` tag is clicked.\n/// - `initialize` will be called when the application is started. \n/// \npub fn application[Model, Msg](\n  initialize~ : (@url.Url) -> (Command[Msg], Model),\n  update~ : (Msg, Model) -> (Command[Msg], Model),\n  view~ : (Model) -> @html.Html[Msg],\n  url_changed? : (@url.Url) -> Msg,\n  url_request? : (@browser.UrlRequest) -> Msg,\n  mount~ : String = \"app\"\n) -> Unit {\n  @dom.document()\n  .get_element_by_id(mount)\n  .get_exn()\n  .set_inner_html(\"<div></div>\")\n  let mut sandbox = None\n  let mut curr_dom = @vdom.node(\"div\", [], [])\n  fn after_update(html : @html.Html[Msg]) {\n    guard sandbox is Some(sandbox)\n    let new_dom = html.to_virtual_dom()\n    new_dom.patch(curr_dom, sandbox, mount~)\n    curr_dom = new_dom\n  }\n\n  guard @url.parse?(@dom.window().current_url()) is Ok(url)\n  let (cmd, model) = initialize(url)\n  sandbox = Some(\n    @browser.Sandbox::new(\n      model,\n      update,\n      view,\n      after_update~,\n      url_request?,\n      url_changed?,\n    ),\n  )\n  sandbox.unwrap().launch(cmd)\n}\n","///|\npub fn button[M](value : String, msg : M) -> Html[M] {\n  let class =\n    #| p-4 bg-pink-200 w-24 rounded-lg select-none text-center \n    #| hover:-translate-y-1 hover:shadow-lg active:bg-pink-300 \n    #| active:shadow-sm transition-all\n  div(click=msg, class~, [text(value)])\n}\n","///|\npub(all) enum Message {\n  /// adsfadsf\n  /// adsadsfasdf\n  /// adsfasdf\n  Increment\n  /// asdfasdf\n  /// asdfasdfasdf\n  /// adfadsfasd\n  Decrement\n  // Ubc(Int, Bool)\n}\n\n///|\npriv struct Model {\n  count : Int\n}\n\n///|\nfn update(msg : Message, model : Model) -> (Command[Message], Model) {\n  match msg {\n    Increment => (none(), { count: model.count + 1 })\n    Decrement => (none(), { count: @math.maximum(0, model.count - 1) })\n    // _ => ...\n  }\n}\n\n///|\nfn view(model : Model) -> Html[Message] {\n  div(class=\"w-[600px] h-[100px] m-10\", [\n    h1(class=\"text-2xl font-bold text-center select-none\", [\n      text(\"\\{model.count}\"),\n    ]),\n    div(class=\"flex justify-center gap-8 m-8\", [\n      @views.button(\"+\", Increment),\n      @views.button(\"-\", Decrement),\n    ]),\n  ])\n}\n\n///| NOTE: This program is only available in the js backend, \n/// see README.md to getting started.\nfn main {\n  let model = { count: 0 }\n  @tea.startup(model~, update~, view~)\n}\n"],"names":["Result$Err$0$","param0","Result$Ok$0$","Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure","Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError","$9223372036854775807L","$10L","$1L","$16L","$_9223372036854775808L","Result$Err$1$","Result$Ok$1$","Result$Err$2$","Result$Ok$2$","Result$Err$3$","Result$Ok$3$","$0L","Result$Err$4$","Result$Ok$4$","Result$Err$5$","Result$Ok$5$","Result$Err$6$","Result$Ok$6$","Result$Err$7$","Result$Ok$7$","Result$Err$8$","Result$Ok$8$","moonbitlang$core$builtin$$JSArray$push","moonbitlang$core$builtin$$get_int64_wasm_helper","moonbitlang$core$builtin$$MyInt64$compare","$64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Http","$64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Https","$64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Other","Result$Err$9$","Result$Ok$9$","rami3l$js$45$ffi$js$$Value$is_null","Option$None$10$","Option$Some$10$","Yoorkin$rabbit$45$tea$dom$$EventTarget$add_event_listener","Yoorkin$rabbit$45$tea$dom$$EventTarget$remove_event_listener","Yoorkin$rabbit$45$tea$dom$$Element$to_html_element","Yoorkin$rabbit$45$tea$dom$$Element$append_children","Yoorkin$rabbit$45$tea$dom$$Element$set_attribute","Yoorkin$rabbit$45$tea$dom$$Element$remove_attribute","Yoorkin$rabbit$45$tea$dom$$Element$set_property","Yoorkin$rabbit$45$tea$dom$$Element$remove_property","Yoorkin$rabbit$45$tea$dom$$Element$get_property","Yoorkin$rabbit$45$tea$dom$$Element$set_inner_html","Yoorkin$rabbit$45$tea$dom$$HTMLElement$set_style","Yoorkin$rabbit$45$tea$dom$$HTMLElement$remove_style","Yoorkin$rabbit$45$tea$dom$$Event$prevent_default","Yoorkin$rabbit$45$tea$dom$$Event$stop_propagation","Yoorkin$rabbit$45$tea$dom$$Window$current_url","Yoorkin$rabbit$45$tea$dom$$window","Yoorkin$rabbit$45$tea$dom$$Window$to_event_target","Yoorkin$rabbit$45$tea$dom$$document","Yoorkin$rabbit$45$tea$dom$$Document$get_element_by_id","Yoorkin$rabbit$45$tea$dom$$Document$create_element","Yoorkin$rabbit$45$tea$dom$$Document$create_text_node","Yoorkin$rabbit$45$tea$dom$$Node$to_element","Yoorkin$rabbit$45$tea$dom$$Node$to_event_target","Yoorkin$rabbit$45$tea$dom$$Element$to_node","Yoorkin$rabbit$45$tea$dom$$Node$append_child","Yoorkin$rabbit$45$tea$dom$$Node$remove_child","Yoorkin$rabbit$45$tea$dom$$Node$replace_child","Yoorkin$rabbit$45$tea$dom$$Node$insert_before","Yoorkin$rabbit$45$tea$dom$$Node$nth_child","Yoorkin$rabbit$45$tea$dom$$Node$count_child","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Node$11$","param1","param2","param3","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$ExternalNode$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Text$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrEvent$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrStyle$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrString$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrProperty$11$","$64$Yoorkin$47$rabbit$45$tea$47$browser$46$UrlRequest$Internal","$64$Yoorkin$47$rabbit$45$tea$47$browser$46$UrlRequest$External","Option$None$12$","Option$Some$12$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$AttrRemove$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$AttrAdd$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$StyleAdd$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$StyleRemove$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$PropertyAdd$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$PropertyRemove$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$EventRemove$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$EventAdd$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Drop$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Remove$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Replace$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$InsertBefore$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Append$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Update$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Update$UpdateNode$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Update$UpdateText$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Normal$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$11$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Custom$11$","Option$Some$13$","moonbitlang$core$strconv$$base_err_str","moonbitlang$core$strconv$$range_err_str","moonbitlang$core$strconv$$syntax_err_str","moonbitlang$core$strconv$$base_err$0$","moonbitlang$core$strconv$$check_and_consume_base","view","base","rest","*x","_tmp","*bind","*Some","moonbitlang$core$strconv$$overflow_threshold","neg","moonbitlang$core$strconv$$range_err$2$","moonbitlang$core$strconv$$range_err$1$","moonbitlang$core$strconv$$syntax_err$3$","moonbitlang$core$strconv$$syntax_err$1$","moonbitlang$core$strconv$$parse_int64","str","*arg","*neg","*rest","*ok","*num_base","*allow_underscore","overflow_threshold","has_digit","*param","acc","c","d","next_acc","moonbitlang$core$strconv$$parse_int","n","moonbitlang$core$strconv$$parse_int$46$base$46$default","moonbitlang$core$string$$StringView$len","self","moonbitlang$core$string$$String$view","start_offset","end_offset","moonbitlang$core$string$$String$view$46$start_offset$46$default","moonbitlang$core$string$$String$view$46$end_offset$46$default","moonbitlang$core$string$$is_trailing_surrogate","moonbitlang$core$string$$String$offset_of_nth_char_backward","char_count","utf16_offset","moonbitlang$core$string$$is_leading_surrogate","moonbitlang$core$string$$String$offset_of_nth_char_forward","moonbitlang$core$string$$String$offset_of_nth_char","i","moonbitlang$core$string$$StringView$unsafe_charcode_at","index","moonbitlang$core$string$$String$char_length_eq","len","count","c1","c2","moonbitlang$core$string$$String$char_length_ge","moonbitlang$core$string$$code_point_of_surrogate_pair","leading","trailing","moonbitlang$core$string$$concat","strings","separator","*hd","size_hint","*len","*i","s","buf","moonbitlang$core$string$$String$iter","yield_","moonbitlang$core$string$$String$is_empty","moonbitlang$core$string$$StringView$find","sub_len","max_idx","first","j","moonbitlang$core$string$$String$split","sep_len","*p","start","*end","end","moonbitlang$core$string$$String$concat","moonbitlang$core$array$$ArrayView$iter$4$","v","moonbitlang$core$array$$Array$makei$10$","length","value","array","moonbitlang$core$array$$ArrayView$map$11$","f","moonbitlang$core$array$$Array$push_iter$12$","iter","x","moonbitlang$core$math$$maximum$3$","y","moonbitlang$core$option$$Option$map$13$","*t","moonbitlang$core$builtin$$Eq$op_equal$9$","*x_2446","*x_2447","moonbitlang$core$builtin$$abort$14$","msg","moonbitlang$core$builtin$$abort$15$","moonbitlang$core$builtin$$abort$3$","moonbitlang$core$builtin$$abort$5$","moonbitlang$core$builtin$$abort$2$","moonbitlang$core$builtin$$abort$10$","moonbitlang$core$builtin$$abort$6$","moonbitlang$core$builtin$$rotl","r","moonbitlang$core$builtin$$StringBuilder$new","moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default","moonbitlang$core$builtin$$StringBuilder$to_string","moonbitlang$core$builtin$$fail$16$","loc","moonbitlang$core$builtin$$fail$18$","moonbitlang$core$builtin$$fail$19$","moonbitlang$core$builtin$$fail$20$","moonbitlang$core$builtin$$fail$21$","moonbitlang$core$builtin$$op_notequal$4$","moonbitlang$core$builtin$$op_lt$1$","self_","other","moonbitlang$core$builtin$$Logger$write_char$7$","ch","moonbitlang$core$builtin$$op_gt$1$","moonbitlang$core$builtin$$op_le$1$","moonbitlang$core$builtin$$is_leading_surrogate","moonbitlang$core$builtin$$op_ge$1$","moonbitlang$core$builtin$$code_point_of_surrogate_pair","moonbitlang$core$string$$String$unsafe_char_at","moonbitlang$core$builtin$$Logger$write_string$7$","moonbitlang$core$builtin$$MyInt64$from_int","moonbitlang$core$int$$Int$to_int64","moonbitlang$core$builtin$$MyInt64$to_int","moonbitlang$core$int64$$Int64$to_int","moonbitlang$core$builtin$$output$46$abs$124$2187","moonbitlang$core$builtin$$output$46$write_digits$124$2189","*env","num","logger","radix","num2","moonbitlang$core$int$$Int$output","moonbitlang$core$int$$Int$output_size_hint","moonbitlang$core$builtin$$Show$output$22$","moonbitlang$core$string$$String$substring","moonbitlang$core$builtin$$Logger$write_substring$7$","moonbitlang$core$builtin$$Hasher$combine$4$","moonbitlang$core$builtin$$power_2_above","next","moonbitlang$core$builtin$$calc_grow_threshold","capacity","moonbitlang$core$builtin$$Map$new$23$","moonbitlang$core$builtin$$Map$new$24$","moonbitlang$core$builtin$$Map$new$25$","moonbitlang$core$builtin$$Map$new$26$","moonbitlang$core$array$$Array$each$27$","moonbitlang$core$array$$Array$each$28$","moonbitlang$core$array$$Array$each$19$","moonbitlang$core$array$$Array$each$29$","moonbitlang$core$array$$Array$each$20$","moonbitlang$core$array$$Array$each$30$","moonbitlang$core$builtin$$Map$add_entry_to_tail$23$","entry","*tail","moonbitlang$core$builtin$$Map$add_entry_to_tail$24$","moonbitlang$core$builtin$$Map$add_entry_to_tail$25$","moonbitlang$core$builtin$$Map$add_entry_to_tail$26$","moonbitlang$core$builtin$$Map$set$23$","key","hash","insert_entry","list_node","*curr_entry","curr_node","moonbitlang$core$builtin$$Map$set$24$","moonbitlang$core$builtin$$Map$set$25$","moonbitlang$core$builtin$$Map$set$26$","moonbitlang$core$builtin$$Map$grow$23$","old_head","old_list","new_capacity","*idx","*key","*value","moonbitlang$core$builtin$$Map$grow$24$","moonbitlang$core$builtin$$Map$grow$25$","moonbitlang$core$builtin$$Map$grow$26$","moonbitlang$core$builtin$$Map$from_array$23$","arr","m","e","moonbitlang$core$builtin$$Map$from_array$24$","moonbitlang$core$builtin$$Map$from_array$25$","moonbitlang$core$builtin$$Map$from_array$26$","moonbitlang$core$builtin$$Map$get$26$","idx","*entry","moonbitlang$core$builtin$$Map$contains$26$","moonbitlang$core$option$$Option$unwrap$32$","moonbitlang$core$option$$Option$unwrap$33$","moonbitlang$core$option$$Option$unwrap$34$","moonbitlang$core$option$$Option$unwrap$35$","moonbitlang$core$builtin$$Map$each$25$","moonbitlang$core$builtin$$Map$each$24$","moonbitlang$core$builtin$$Iter$new$4$","moonbitlang$core$builtin$$Iter$new$12$","moonbitlang$core$builtin$$Iter$new$27$","moonbitlang$core$builtin$$Iter$new$8$","moonbitlang$core$builtin$$Iter2$new$26$","moonbitlang$core$builtin$$Map$iter2$26$","moonbitlang$core$builtin$$Map$to_array$23$","moonbitlang$core$builtin$$Map$from_iter$26$","moonbitlang$core$array$$ArrayView$length$4$","moonbitlang$core$array$$ArrayView$length$10$","moonbitlang$core$array$$ArrayView$op_get$10$","moonbitlang$core$array$$Array$op_as_view$4$","moonbitlang$core$array$$Array$push$36$","moonbitlang$core$array$$Array$push$12$","moonbitlang$core$array$$Array$push$37$","moonbitlang$core$array$$Array$push$4$","moonbitlang$core$array$$Array$push$38$","moonbitlang$core$builtin$$Hasher$new","seed","moonbitlang$core$builtin$$Hasher$new$46$seed$46$default","moonbitlang$core$builtin$$Hasher$consume4","input","moonbitlang$core$builtin$$Hasher$combine_uint","moonbitlang$core$builtin$$Hasher$combine_string","*end1546","moonbitlang$core$builtin$$Hasher$avalanche","moonbitlang$core$builtin$$Hasher$finalize","moonbitlang$core$builtin$$Hash$hash_combine$4$","hasher","moonbitlang$core$int$$Int$to_string","moonbitlang$core$int$$Int$to_string$46$radix$46$default","moonbitlang$core$builtin$$Show$to_string$3$","moonbitlang$core$array$$Array$map$39$","moonbitlang$core$array$$Array$map$40$","moonbitlang$core$array$$Array$map$41$","moonbitlang$core$array$$Array$make$10$","elem","moonbitlang$core$builtin$$Show$to_string$4$","moonbitlang$core$array$$Array$iter$12$","moonbitlang$core$array$$Array$iter$27$","moonbitlang$core$builtin$$Hash$hash$31$","*self","moonbitlang$core$builtin$$Show$to_string$17$","moonbitlang$core$builtin$$MyInt64$add_hi_lo","bhi","blo","*ahi","*alo","lo","as_","bs","hi","moonbitlang$core$builtin$$Add$op_add$42$","moonbitlang$core$builtin$$Sub$op_sub$42$","moonbitlang$core$builtin$$Mul$op_mul$42$","*bhi","*blo","ahi","alo","a48","a32","a16","a00","b48","b32","b16","b00","c00","c16","c32","c48","moonbitlang$core$builtin$$Div$op_div$42$","exports","*func","moonbitlang$core$builtin$$Add$op_add$1$","moonbitlang$core$builtin$$Sub$op_sub$1$","moonbitlang$core$builtin$$Mul$op_mul$1$","moonbitlang$core$builtin$$Div$op_div$1$","moonbitlang$core$builtin$$Compare$compare$1$","moonbitlang$core$builtin$$Eq$op_equal$43$","*y","moonbitlang$core$array$$Array$op_set$10$","moonbitlang$core$builtin$$Iter$run$27$","moonbitlang$core$builtin$$Iter$map$44$","a","moonbitlang$core$builtin$$Iter$collect$4$","result","moonbitlang$core$builtin$$Eq$op_equal$45$","*x_79","*x_80","*x0_81","*y0_82","*Other","**x0_81","**y0_82","Yoorkin$rabbit$45$tea$url$$parse","url","protocol","remain","*remain","*protocol","mid","query_and_fragment","*mid","*query_and_fragment","mid_part","fragment1","fragment","*fragment","*mid_part","*fragment1","path","paths","*path","host","port","*host","*port","*try_err","*err","number","query","fragment2","*query","*fragment2","f1","f2","*f","*f1","*f2","rami3l$js$45$ffi$js$$Nullable$to_option$33$","Yoorkin$rabbit$45$tea$browser$$Sandbox$get_on_url_request$46$","Yoorkin$rabbit$45$tea$browser$$Sandbox$update$46$","message","cmd","model","*cmd","*model","Yoorkin$rabbit$45$tea$browser$$Sandbox$launch$46$","update","Yoorkin$rabbit$45$tea$browser$$Sandbox$refersh$46$","Yoorkin$rabbit$45$tea$browser$$Sandbox$new$47$","after_update","url_changed","url_request","sandbox","on_url_changed","on_url_request","_event","*Ok","*url","Yoorkin$rabbit$45$tea$browser$$none$48$","*param1","*param2","Yoorkin$rabbit$45$tea$internal$vdom$$node$48$","tag","attrs","childrens","Yoorkin$rabbit$45$tea$internal$vdom$$text$48$","Yoorkin$rabbit$45$tea$internal$vdom$$is_same_type$48$","Yoorkin$rabbit$45$tea$internal$vdom$$on$48$","event","handler","Yoorkin$rabbit$45$tea$internal$vdom$$attribute$48$","Yoorkin$rabbit$45$tea$internal$vdom$$Node$to_node$46$","attach_attrs","element","generated_listeners","*event","*AttrEvent","*handler","*AttrString","*AttrStyle","*AttrProperty","listener","stop_propagation","prevent_default","*Normal","*msg","*HandleEvent","*Custom","*stop_propagation","*prevent_default","width","node","height","listeners","*Node","*tag","*attrs","*childrens","*listeners","*ExternalNode","*node","*width","*height","*Text","*url_request","href","curr","*curr","*next","request","*arr","child","xs","*xs","Yoorkin$rabbit$45$tea$internal$vdom$$attrs_diff$48$","old","new","old_map","attr","new_map","value_new","*value_new","Yoorkin$rabbit$45$tea$internal$vdom$$do_diff$48$","childrens_old","childrens_new","Yoorkin$rabbit$45$tea$internal$vdom$$diff_without_key$48$","aux","ys","patches","tl1","tl2","l","tl","*some","value_a","value_b","taga","xattrs","yattrs","tagb","new_listeners","*taga","*xattrs","*tagb","*yattrs","*new_listeners","*value_a","*value_b","attrs_patches","childs_patches","Yoorkin$rabbit$45$tea$internal$vdom$$diff$48$","root_old","root_new","attrs_old","*attrs_old","attrs_new","*attrs_new","Yoorkin$rabbit$45$tea$internal$vdom$$Node$patch$46$","mount","current","nodes","*Drop","*index","*length","*Remove","*Replace","*InsertBefore","*Append","*nodes","*Update","*update","*start131","*end132","*UpdateNode","*attrs_patches","*childs_patches","*UpdateText","patch","*AttrRemove","*AttrAdd","*StyleAdd","*StyleRemove","*PropertyAdd","*PropertyRemove","*EventRemove","*listener","*EventAdd","text_node","root","Yoorkin$rabbit$45$tea$html$$node$48$","attributes","Yoorkin$rabbit$45$tea$html$$T$to_virtual_dom$48$","Yoorkin$rabbit$45$tea$html$$attribute$48$","Yoorkin$rabbit$45$tea$html$$new$48$","style","class","id","optional_attrs","optional_attributes","events","p","*attr","*param3","k","*v","*style","*class","*id","*param4","*param5","Yoorkin$rabbit$45$tea$html$$new$46$optional_attrs$46$default$48$","Yoorkin$rabbit$45$tea$html$$new$46$attributes$46$default$48$","Yoorkin$rabbit$45$tea$html$$new$46$optional_attributes$46$default$48$","Yoorkin$rabbit$45$tea$html$$new$46$events$46$default$48$","Yoorkin$rabbit$45$tea$html$$h1$48$","Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$48$","Yoorkin$rabbit$45$tea$html$$div$48$","click","Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$48$","Yoorkin$rabbit$45$tea$html$$text$48$","Yoorkin$rabbit$45$tea$$none$48$","Yoorkin$rabbit$45$tea$$startup$49$","curr_dom","html","*sandbox","new_dom","Yoorkin$rabbit$45$tea$$startup$46$mount$46$default$49$","username$rabbit$45$tea$45$tailwind$views$$button$48$","username$rabbit$45$tea$45$tailwind$main$$update","username$rabbit$45$tea$45$tailwind$main$$view"],"mappings":"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"}